import { defineStore } from 'pinia'
import { eventBus, MQTT_EVENTS, storeHandler } from '@/utils/eventBus'
import { useCentralConfigStore } from './centralConfig'
import { storage } from '@/utils/storage'
import { errorHandler } from '@/utils/errorHandler'

export const useDashboardGeneratorStore = defineStore('dashboardGenerator', {
  state: () => ({
    // Automatische Dashboard-Konfigurationen
    autoGeneratedDashboards: new Map(), // Map<dashboardId, DashboardConfig>

    // Logische Bereiche (unabhÃ¤ngig von Subzones)
    logicalAreas: new Map(), // Map<areaId, LogicalArea>

    // âœ… NEU: Zentrale Visualisierungsdaten-Verwaltung
    visualizationDataMap: new Map(), // Map<`${espId}-${gpio}`, SensorData>

    // âœ… NEU: ZustÃ¤ndigkeits-Trennung
    dataSources: {
      zoneCards: new Set(), // ESP-spezifische Sensoren
      comparisonPanels: new Set(), // Manuell ausgewÃ¤hlte Sensoren
    },

    // ðŸ†• NEU: Zentrale Panel-Verwaltung
    comparisonPanels: new Map(), // Map<panelId, PanelConfig>
    activePanelId: null,

    // Zeitraum-Konfigurationen
    timeRanges: {
      quick: [
        { id: '5min', label: '5 Minuten', value: 5 * 60 * 1000 },
        { id: '15min', label: '15 Minuten', value: 15 * 60 * 1000 },
        { id: '1hour', label: '1 Stunde', value: 60 * 60 * 1000 },
        { id: '6hours', label: '6 Stunden', value: 6 * 60 * 60 * 1000 },
        { id: '24hours', label: '24 Stunden', value: 24 * 60 * 60 * 1000 },
      ],
      custom: [], // Benutzerdefinierte ZeitrÃ¤ume
    },

    // âœ… ERWEITERT: Sensor-Gruppierungen um Visualisierungskonfiguration
    sensorGroups: {
      temperature: {
        name: 'Temperatur',
        sensors: ['SENSOR_TEMP_DS18B20', 'SENSOR_TEMP_DHT22'],
        color: '#ff6b6b',
        icon: 'mdi-thermometer',
        unit: 'Â°C',
        // âœ… NEU: Visualisierungskonfiguration
        visualization: {
          defaultType: 'line',
          availableTypes: ['line', 'gauge', 'status', 'bar', 'value-only'],
          mobileOptimized: true,
          chartOptions: {
            line: { showTrend: true, showMinMax: true },
            gauge: { min: 0, max: 50, thresholds: [15, 30, 40] },
            status: { thresholds: [15, 30, 40] },
            bar: { showHistory: true, maxBars: 24 },
            'value-only': { showUnit: true, showTrend: false },
          },
        },
        criticalRanges: [
          { min: 0, max: 35, color: 'success' },
          { min: 35, max: 40, color: 'warning' },
          { min: 40, max: 50, color: 'error' },
        ],
      },
      humidity: {
        name: 'Luftfeuchtigkeit',
        sensors: ['SENSOR_HUMIDITY', 'SENSOR_SOIL'],
        color: '#4ecdc4',
        icon: 'mdi-water-percent',
        unit: '%',
        // âœ… NEU: Visualisierungskonfiguration
        visualization: {
          defaultType: 'gauge',
          availableTypes: ['gauge', 'line', 'status', 'bar', 'value-only'],
          mobileOptimized: true,
          chartOptions: {
            gauge: { min: 0, max: 100, thresholds: [30, 60, 80] },
            line: { showTrend: true, showMinMax: true },
            status: { thresholds: [30, 60, 80] },
            bar: { showHistory: true, maxBars: 24 },
            'value-only': { showUnit: true, showTrend: false },
          },
        },
        criticalRanges: [
          { min: 0, max: 30, color: 'error' },
          { min: 30, max: 60, color: 'success' },
          { min: 60, max: 80, color: 'warning' },
          { min: 80, max: 100, color: 'error' },
        ],
      },
      light: {
        name: 'Licht',
        sensors: ['SENSOR_LIGHT'],
        color: '#ffe66d',
        icon: 'mdi-white-balance-sunny',
        unit: 'lux',
        // âœ… NEU: Visualisierungskonfiguration
        visualization: {
          defaultType: 'bar',
          availableTypes: ['bar', 'line', 'status', 'gauge', 'value-only'],
          mobileOptimized: true,
          chartOptions: {
            bar: { showHistory: true, maxBars: 24 },
            line: { showTrend: true, showMinMax: true },
            status: { thresholds: [1000, 10000] },
            gauge: { min: 0, max: 50000, thresholds: [1000, 10000] },
            'value-only': { showUnit: true, showTrend: false },
          },
        },
        criticalRanges: [
          { min: 0, max: 1000, color: 'error' },
          { min: 1000, max: 10000, color: 'success' },
          { min: 10000, max: 50000, color: 'warning' },
        ],
      },
      moisture: {
        name: 'Bodenfeuchtigkeit',
        sensors: ['SENSOR_MOISTURE'],
        color: '#4ecdc4',
        icon: 'mdi-water-percent',
        unit: '%',
        // âœ… NEU: Visualisierungskonfiguration
        visualization: {
          defaultType: 'gauge',
          availableTypes: ['gauge', 'line', 'status', 'bar', 'value-only'],
          mobileOptimized: true,
          chartOptions: {
            gauge: { min: 0, max: 100, thresholds: [40, 80] },
            line: { showTrend: true, showMinMax: true },
            status: { thresholds: [40, 80] },
            bar: { showHistory: true, maxBars: 24 },
            'value-only': { showUnit: true, showTrend: false },
          },
        },
        criticalRanges: [
          { min: 0, max: 40, color: 'error' },
          { min: 40, max: 80, color: 'success' },
          { min: 80, max: 100, color: 'warning' },
        ],
      },
      // âœ… NEU: Digitale Sensoren mit logischer Begrenzung
      digital: {
        name: 'Digitale Sensoren',
        sensors: ['SENSOR_DIGITAL', 'SENSOR_SWITCH'],
        color: '#4caf50',
        icon: 'mdi-toggle-switch',
        unit: '',
        // âœ… NEU: Nur passende Visualisierungen fÃ¼r digitale Sensoren
        visualization: {
          defaultType: 'status',
          availableTypes: ['status', 'value-only'], // Keine Charts fÃ¼r binÃ¤re Werte
          mobileOptimized: true,
          chartOptions: {
            status: { thresholds: [0, 1] },
            'value-only': { showUnit: false, showTrend: false },
          },
        },
        criticalRanges: [
          { min: 0, max: 0, color: 'error' },
          { min: 1, max: 1, color: 'success' },
        ],
      },
    },

    // Dashboard-Layout-Konfigurationen
    layoutConfigs: {
      compact: {
        name: 'Kompakt',
        cardSize: 'small',
        showAggregations: false,
        showCharts: false,
        maxCardsPerRow: 4,
      },
      detailed: {
        name: 'Detailliert',
        cardSize: 'medium',
        showAggregations: true,
        showCharts: true,
        maxCardsPerRow: 2,
      },
      overview: {
        name: 'Ãœbersicht',
        cardSize: 'large',
        showAggregations: true,
        showCharts: true,
        maxCardsPerRow: 1,
      },
    },

    // Aktive Konfiguration
    activeConfig: {
      layout: 'detailed',
      timeRange: '1hour',
      showAggregations: true,
      showCharts: true,
      autoRefresh: true,
      refreshInterval: 30000, // 30 Sekunden
    },

    // ðŸ†• NEU: Generierte Layouts
    generatedLayouts: new Map(), // Map<layoutId, Layout>
    layoutTemplates: new Map(), // Map<templateId, LayoutTemplate>
    activeLayout: null,

    // âœ… ERWEITERT: Drag & Drop State um History
    dragState: {
      isDragging: false,
      draggedCard: null,
      dropTarget: null,
    },

    // âœ… NEU: History-Management (konsistent mit systemCommands.js)
    undoStack: [],
    redoStack: [],
    maxHistorySize: 50,

    // ðŸ†• NEU: Audit-Log fÃ¼r Drop-Aktionen
    interactionLog: [], // Array<InteractionLogEntry>
    maxLogEntries: 100,

    // âœ… NEU: Card-Positionen
    cardPositions: new Map(), // Map<cardId, {x, y, width, height}>
    layoutHistory: [], // Array<LayoutSnapshot>

    // âœ… NEU: Visualisierungskonfiguration pro Sensor
    sensorVisualizations: new Map(), // Map<`${espId}-${gpio}`, VisualizationConfig>

    // âœ… NEU: Aktive Visualisierungstypen
    activeVisualizations: {
      defaultType: 'line',
      perSensor: new Map(), // Map<`${espId}-${gpio}`, string>
    },

    // âœ… NEU: Vergleichsmodus
    comparisonMode: {
      enabled: false,
      primaryRange: '1hour',
      comparisonRange: '24hours',
      aggregationMethod: 'avg', // avg, max, min, median, std, count
      showDifference: true,
      differenceThreshold: 0.1, // 10% Unterschied anzeigen
    },

    // âœ… NEU: Erweiterte Aggregationsmethoden
    aggregationMethods: {
      avg: { name: 'Durchschnitt', icon: 'mdi-chart-line' },
      max: { name: 'Maximum', icon: 'mdi-arrow-up' },
      min: { name: 'Minimum', icon: 'mdi-arrow-down' },
      median: { name: 'Median', icon: 'mdi-chart-bell-curve' },
      std: { name: 'Standardabweichung', icon: 'mdi-chart-scatter-plot' },
      count: { name: 'Anzahl Messungen', icon: 'mdi-counter' },
    },

    // ðŸš¨ NEU: Alert-System
    alertSystem: {
      enabled: false,
      alerts: new Map(), // Map<`${espId}-${gpio}`, AlertConfig>
      activeAlerts: new Map(), // Map<alertKey, Alert>
      alertHistory: [], // Array<Alert>
      maxHistorySize: 100,
      alertTypes: {
        threshold: { name: 'Grenzwert', color: 'warning', icon: 'mdi-alert-circle' },
        critical: { name: 'Kritisch', color: 'error', icon: 'mdi-alert-octagon' },
        trend: { name: 'Trend', color: 'info', icon: 'mdi-trending-up' },
        offline: { name: 'Offline', color: 'grey', icon: 'mdi-wifi-off' },
      },
      notificationChannels: {
        snackbar: true,
        sound: false,
        email: false,
        push: false,
      },
      cooldownSettings: {
        threshold: 5 * 60 * 1000, // 5 Minuten
        critical: 1 * 60 * 1000, // 1 Minute
        trend: 10 * 60 * 1000, // 10 Minuten
        offline: 30 * 60 * 1000, // 30 Minuten
      },
    },

    // ðŸ†• NEU: Alert-Konfigurations-Profile
    alertProfiles: {
      profiles: new Map(), // Map<profileId, AlertProfile>
      activeProfileId: null,
      defaultProfileId: 'default',
    },

    // Loading & Error States (konsistent mit anderen Stores)
    loading: false,
    error: null,
    lastUpdate: null,
  }),

  getters: {
    // Automatisch erkannte Sensoren gruppieren
    getDetectedSensorGroups: () => {
      const groups = new Map()

      // Event fÃ¼r ESP-Devices anfordern
      eventBus.emit(MQTT_EVENTS.REQUEST_ESP_DEVICES)

      // TemporÃ¤r leere Map zurÃ¼ckgeben - wird Ã¼ber Event-System aktualisiert
      return groups
    },

    // Liefert die aktuelle Layout-Konfiguration
    getActiveLayoutConfig: (state) => {
      return state.layoutConfigs[state.activeConfig.layout] || state.layoutConfigs.detailed
    },

    // Liefert alle logischen Bereiche
    getLogicalAreas: (state) => {
      return Array.from(state.logicalAreas.values())
    },

    // ðŸ†• NEU: Layout-Getter
    getGeneratedLayouts: (state) => Array.from(state.generatedLayouts.values()),
    getLayoutTemplates: (state) => Array.from(state.layoutTemplates.values()),
    getActiveLayout: (state) => state.activeLayout,

    // âœ… NEU: Visualisierungstyp fÃ¼r Sensor
    getSensorVisualization: (state) => (espId, gpio) => {
      const key = `${espId}-${gpio}`
      return state.activeVisualizations.perSensor.get(key) || state.activeVisualizations.defaultType
    },

    // âœ… NEU: Standard-Visualisierung fÃ¼r Sensortyp
    getDefaultVisualizationForSensor: (state) => (sensorType) => {
      for (const [, group] of Object.entries(state.sensorGroups)) {
        if (group.sensors.includes(sensorType)) {
          return group.visualization?.defaultType || 'line'
        }
      }
      return 'line'
    },

    // âœ… NEU: VerfÃ¼gbare Visualisierungstypen fÃ¼r Sensor
    getAvailableVisualizationsForSensor: (state) => (sensorType) => {
      for (const [, group] of Object.entries(state.sensorGroups)) {
        if (group.sensors.includes(sensorType)) {
          return group.visualization?.availableTypes || ['line']
        }
      }
      return ['line']
    },

    // âœ… NEU: Visualisierungstyp-Labels
    getVisualizationTypeLabel: () => (type) => {
      const labels = {
        line: 'Liniendiagramm',
        gauge: 'MessgerÃ¤t',
        status: 'Status',
        bar: 'Balkendiagramm',
        'value-only': 'Nur Wert',
      }
      return labels[type] || type
    },

    // âœ… NEU: History-Status
    canUndo: (state) => state.undoStack.length > 0,
    canRedo: (state) => state.redoStack.length > 0,
  },

  actions: {
    // Dashboard automatisch generieren
    autoGenerateDashboard() {
      const centralConfig = useCentralConfigStore()
      // Beispiel: Erzeuge fÃ¼r jede Zone eine Dashboard-Card mit allen zugehÃ¶rigen ESPs und Sensoren
      const dashboards = new Map()
      for (const zone of centralConfig.getAvailableZones) {
        const espIds = centralConfig.getEspIdsForZone(zone)
        dashboards.set(zone, {
          zone,
          espIds,
          cards: espIds.map((espId) => ({
            espId,
            sensors: this.getSensorsForEsp(espId),
            subzones: this.getSubzonesForEsp(espId),
          })),
        })
      }
      this.autoGeneratedDashboards = dashboards
      this.saveConfig()
    },

    // ðŸ†• NEU: Automatische Layout-VorschlÃ¤ge generieren
    generateSuggestedLayouts(sensorAnalysis) {
      const layouts = []

      // Layout 1: Alle Sensoren nach Typ gruppiert
      if (sensorAnalysis.length > 0) {
        layouts.push({
          id: 'layout_sensor_types',
          name: 'Sensor-Typ Gruppierung',
          description: 'Gruppiert alle Sensoren nach ihrem Typ (Temperatur, Feuchtigkeit, etc.)',
          logicalAreas: sensorAnalysis.map((group) => ({
            id: `area_${group.type}`,
            name: `${group.label} Bereich`,
            sensorTypes: [group.type],
            sensors: group.sensors,
          })),
        })
      }

      // Layout 2: ESP-basierte Gruppierung
      const espGroups = this.groupSensorsByEsp(sensorAnalysis)
      if (espGroups.length > 0) {
        layouts.push({
          id: 'layout_esp_groups',
          name: 'ESP-GerÃ¤te Gruppierung',
          description: 'Gruppiert Sensoren nach ESP-GerÃ¤ten',
          logicalAreas: espGroups.map((group) => ({
            id: `area_esp_${group.espId}`,
            name: `ESP ${group.espId} Bereich`,
            sensorTypes: group.sensorTypes,
            sensors: group.sensors,
          })),
        })
      }

      // Layout 3: Funktionsbasierte Gruppierung
      const functionalGroups = this.groupSensorsByFunction(sensorAnalysis)
      if (functionalGroups.length > 0) {
        layouts.push({
          id: 'layout_functional',
          name: 'Funktionsbasierte Gruppierung',
          description: 'Gruppiert Sensoren nach ihrer Funktion (Klima, BewÃ¤sserung, etc.)',
          logicalAreas: functionalGroups.map((group) => ({
            id: `area_functional_${group.function}`,
            name: `${group.name} Bereich`,
            sensorTypes: group.sensorTypes,
            sensors: group.sensors,
          })),
        })
      }

      return layouts
    },

    // ðŸ†• NEU: Schnell-Layout generieren
    generateQuickLayout(config) {
      const layoutId = `layout_quick_${Date.now()}`

      const layout = {
        id: layoutId,
        name: 'Schnell-Layout',
        description: 'Automatisch generiertes Layout',
        logicalAreas: config.sensorTypes.map((sensorType) => {
          const sensors = config.sensors.filter((s) => s.type === sensorType)
          return {
            id: `area_quick_${sensorType}`,
            name: `${this.getSensorTypeLabel(sensorType)} Bereich`,
            sensorTypes: [sensorType],
            sensors: sensors,
            timeInterval: config.timeInterval,
            criticalRanges: this.generateDefaultCriticalRanges(sensorType),
          }
        }),
      }

      this.generatedLayouts.set(layoutId, layout)
      return layout
    },

    // ðŸ†• NEU: Layout anwenden
    applyLayout(layout) {
      this.activeLayout = layout
      this.saveConfig()
    },

    // ðŸ†• NEU: Sensoren nach ESP gruppieren
    groupSensorsByEsp(sensorAnalysis) {
      const espGroups = new Map()

      sensorAnalysis.forEach((group) => {
        group.sensors.forEach((sensor) => {
          if (!espGroups.has(sensor.espId)) {
            espGroups.set(sensor.espId, {
              espId: sensor.espId,
              sensorTypes: new Set(),
              sensors: [],
            })
          }

          const espGroup = espGroups.get(sensor.espId)
          espGroup.sensorTypes.add(sensor.type)
          espGroup.sensors.push(sensor)
        })
      })

      return Array.from(espGroups.values()).map((group) => ({
        ...group,
        sensorTypes: Array.from(group.sensorTypes),
      }))
    },

    // ðŸ†• NEU: Sensoren nach Funktion gruppieren
    groupSensorsByFunction(sensorAnalysis) {
      const functionGroups = {
        climate: {
          name: 'Klima',
          function: 'climate',
          sensorTypes: ['SENSOR_TEMP_DS18B20', 'SENSOR_HUMIDITY', 'SENSOR_PRESSURE'],
          sensors: [],
        },
        irrigation: {
          name: 'BewÃ¤sserung',
          function: 'irrigation',
          sensorTypes: ['SENSOR_MOISTURE', 'SENSOR_SOIL'],
          sensors: [],
        },
        lighting: {
          name: 'Beleuchtung',
          function: 'lighting',
          sensorTypes: ['SENSOR_LIGHT'],
          sensors: [],
        },
      }

      sensorAnalysis.forEach((group) => {
        group.sensors.forEach((sensor) => {
          for (const funcGroup of Object.values(functionGroups)) {
            if (funcGroup.sensorTypes.includes(sensor.type)) {
              funcGroup.sensors.push(sensor)
              break
            }
          }
        })
      })

      return Object.values(functionGroups).filter((group) => group.sensors.length > 0)
    },

    // ðŸ†• NEU: Sensor-Typ-Label
    getSensorTypeLabel(type) {
      const labels = {
        SENSOR_TEMP_DS18B20: 'Temperatur',
        SENSOR_MOISTURE: 'Feuchtigkeit',
        SENSOR_LIGHT: 'Licht',
        SENSOR_PRESSURE: 'Druck',
        SENSOR_CO2: 'CO2',
      }
      return labels[type] || type
    },

    // ðŸ†• NEU: Standard-Grenzwerte generieren
    generateDefaultCriticalRanges(sensorType) {
      const ranges = {
        SENSOR_TEMP_DS18B20: [
          { min: 15, max: 30, color: 'warning', description: 'Temperatur-Bereich' },
        ],
        SENSOR_MOISTURE: [
          { min: 40, max: 80, color: 'warning', description: 'Feuchtigkeits-Bereich' },
        ],
        SENSOR_LIGHT: [{ min: 1000, max: 10000, color: 'warning', description: 'Licht-Bereich' }],
      }

      return ranges[sensorType] || []
    },

    // Sensoren fÃ¼r ein ESP-Device abrufen
    getSensorsForEsp(espId) {
      // Event fÃ¼r ESP-Sensoren anfordern
      eventBus.emit(MQTT_EVENTS.REQUEST_ESP_SENSORS, { espId })
      return [] // Wird Ã¼ber Event-System aktualisiert
    },

    // Subzones fÃ¼r ein ESP-Device abrufen
    getSubzonesForEsp(espId) {
      // Event fÃ¼r ESP-Subzones anfordern
      eventBus.emit(MQTT_EVENTS.REQUEST_ESP_SUBZONES, { espId })
      return [] // Wird Ã¼ber Event-System aktualisiert
    },

    // Logischen Bereich hinzufÃ¼gen
    addLogicalArea(area) {
      this.logicalAreas.set(area.id, area)
      this.saveConfig()
    },

    // Logischen Bereich entfernen
    removeLogicalArea(areaId) {
      this.logicalAreas.delete(areaId)
      this.saveConfig()
    },

    // Zeitbereich hinzufÃ¼gen
    addCustomTimeRange(range) {
      this.timeRanges.custom.push(range)
      this.saveConfig()
    },

    // Layout-Konfiguration Ã¤ndern
    setActiveLayout(layoutKey) {
      if (this.layoutConfigs[layoutKey]) {
        this.activeConfig.layout = layoutKey
        this.saveConfig()
      }
    },

    // Zeitbereich Ã¤ndern
    setActiveTimeRange(timeRangeId) {
      this.activeConfig.timeRange = timeRangeId
      this.saveConfig()
    },

    // Aggregationen und Diagramme umschalten
    setShowAggregations(show) {
      this.activeConfig.showAggregations = show
      this.saveConfig()
    },
    setShowCharts(show) {
      this.activeConfig.showCharts = show
      this.saveConfig()
    },

    // Drag & Drop State verwalten
    setDragState(state) {
      this.dragState = { ...this.dragState, ...state }
    },

    // âœ… NEU: Visualisierungstyp fÃ¼r Sensor setzen
    setSensorVisualization(espId, gpio, visualizationType) {
      const key = `${espId}-${gpio}`
      this.activeVisualizations.perSensor.set(key, visualizationType)
      this.saveConfig()
    },

    // âœ… NEU: Vergleichsmodus umschalten
    toggleComparisonMode(enabled = null) {
      this.comparisonMode.enabled = enabled !== null ? enabled : !this.comparisonMode.enabled
      this.saveConfig()
    },

    // âœ… NEU: Vergleichszeitraum setzen
    setComparisonRange(rangeId) {
      this.comparisonMode.comparisonRange = rangeId
      this.saveConfig()
    },

    // âœ… NEU: Aggregationsmethode setzen
    setAggregationMethod(method) {
      if (this.aggregationMethods[method]) {
        this.comparisonMode.aggregationMethod = method
        this.saveConfig()
      }
    },

    // âœ… NEU: Layout-Snapshot erstellen (konsistent mit systemCommands.js)
    createLayoutSnapshot() {
      const snapshot = {
        id: `snapshot_${Date.now()}`,
        timestamp: Date.now(),
        layout: {
          logicalAreas: Array.from(this.logicalAreas.entries()),
          cardPositions: Array.from(this.cardPositions.entries()),
          activeConfig: { ...this.activeConfig },
          activeLayout: this.activeLayout ? { ...this.activeLayout } : null,
        },
      }

      this.undoStack.unshift(snapshot)
      if (this.undoStack.length > this.maxHistorySize) {
        this.undoStack.pop()
      }

      // Redo-Stack leeren bei neuer Aktion
      this.redoStack = []

      return snapshot
    },

    // âœ… NEU: Undo-Funktion
    undo() {
      if (this.undoStack.length === 0) return false

      const currentSnapshot = this.createLayoutSnapshot()
      this.redoStack.unshift(currentSnapshot)

      const previousSnapshot = this.undoStack.shift()
      this.restoreLayoutSnapshot(previousSnapshot)

      this.saveConfig()
      return true
    },

    // âœ… NEU: Redo-Funktion
    redo() {
      if (this.redoStack.length === 0) return false

      const currentSnapshot = this.createLayoutSnapshot()
      this.undoStack.unshift(currentSnapshot)

      const nextSnapshot = this.redoStack.shift()
      this.restoreLayoutSnapshot(nextSnapshot)

      this.saveConfig()
      return true
    },

    // âœ… NEU: Layout-Snapshot wiederherstellen
    restoreLayoutSnapshot(snapshot) {
      if (!snapshot?.layout) return false

      this.logicalAreas = new Map(snapshot.layout.logicalAreas)
      this.cardPositions = new Map(snapshot.layout.cardPositions)
      this.activeConfig = { ...snapshot.layout.activeConfig }
      this.activeLayout = snapshot.layout.activeLayout ? { ...snapshot.layout.activeLayout } : null

      return true
    },

    // âœ… NEU: Card-Position speichern
    updateCardPosition(cardId, position) {
      this.cardPositions.set(cardId, { ...position })
      this.createLayoutSnapshot()
      this.saveConfig()
    },

    // âœ… NEU: Export-Funktionen (konsistent mit storage.js)
    exportDashboardConfig() {
      return {
        version: '1.0.0',
        timestamp: Date.now(),
        layout: {
          logicalAreas: Array.from(this.logicalAreas.entries()),
          cardPositions: Array.from(this.cardPositions.entries()),
          activeConfig: { ...this.activeConfig },
          activeLayout: this.activeLayout ? { ...this.activeLayout } : null,
        },
        visualizations: {
          activeVisualizations: Array.from(this.activeVisualizations.perSensor.entries()),
          sensorVisualizations: Array.from(this.sensorVisualizations.entries()),
        },
        timeRanges: { ...this.timeRanges },
        sensorGroups: { ...this.sensorGroups },
        comparisonMode: { ...this.comparisonMode },
      }
    },

    // âœ… NEU: Import-Funktion
    importDashboardConfig(config) {
      try {
        if (!config.version || !config.layout) {
          throw new Error('Invalid dashboard configuration format')
        }

        // Backup erstellen
        const backup = this.exportDashboardConfig()

        // Konfiguration importieren
        this.logicalAreas = new Map(config.layout.logicalAreas || [])
        this.cardPositions = new Map(config.layout.cardPositions || [])
        this.activeConfig = { ...this.activeConfig, ...config.layout.activeConfig }
        this.activeLayout = config.layout.activeLayout ? { ...config.layout.activeLayout } : null

        if (config.visualizations) {
          this.activeVisualizations.perSensor = new Map(
            config.visualizations.activeVisualizations || [],
          )
          this.sensorVisualizations = new Map(config.visualizations.sensorVisualizations || [])
        }

        if (config.timeRanges) {
          this.timeRanges = { ...this.timeRanges, ...config.timeRanges }
        }

        if (config.comparisonMode) {
          this.comparisonMode = { ...this.comparisonMode, ...config.comparisonMode }
        }

        this.saveConfig()
        this.createLayoutSnapshot()

        return { success: true, backup }
      } catch (error) {
        console.error('Failed to import dashboard config:', error)
        return { success: false, error: error.message }
      }
    },

    // âœ… NEU: Konfiguration als JSON-Datei exportieren
    exportDashboardConfigAsFile() {
      const config = this.exportDashboardConfig()
      const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' })
      const url = URL.createObjectURL(blob)

      const a = document.createElement('a')
      a.href = url
      a.download = `dashboard_config_${new Date().toISOString().split('T')[0]}.json`
      a.click()

      URL.revokeObjectURL(url)
    },

    // âœ… NEU: Konfiguration aus Datei importieren
    async importDashboardConfigFromFile(file) {
      try {
        const text = await file.text()
        const config = JSON.parse(text)
        return this.importDashboardConfig(config)
      } catch (error) {
        console.error('Failed to import dashboard config from file:', error)
        return { success: false, error: error.message }
      }
    },

    // âœ… NEU: Zeitvergleichsdaten berechnen
    calculateTimeComparison(sensorData, primaryRange, comparisonRange) {
      const primaryData = this.filterDataByTimeRange(sensorData, primaryRange)
      const comparisonData = this.filterDataByTimeRange(sensorData, comparisonRange)

      const primaryAgg = this.aggregateData(primaryData, this.comparisonMode.aggregationMethod)
      const comparisonAgg = this.aggregateData(
        comparisonData,
        this.comparisonMode.aggregationMethod,
      )

      const difference = primaryAgg - comparisonAgg
      const percentageChange = comparisonAgg !== 0 ? (difference / comparisonAgg) * 100 : 0

      return {
        primary: primaryAgg,
        comparison: comparisonAgg,
        difference,
        percentageChange,
        isSignificant: Math.abs(percentageChange) > this.comparisonMode.differenceThreshold,
      }
    },

    // âœ… NEU: Daten nach Zeitraum filtern
    filterDataByTimeRange(data, timeRangeId) {
      const timeRange =
        this.timeRanges.quick.find((tr) => tr.id === timeRangeId) ||
        this.timeRanges.custom.find((tr) => tr.id === timeRangeId)

      if (!timeRange) return data

      const cutoffTime = Date.now() - timeRange.value
      return data.filter((item) => item.timestamp && item.timestamp > cutoffTime)
    },

    // âœ… NEU: Daten aggregieren
    aggregateData(data, method) {
      if (!data || data.length === 0) return 0

      const values = data.map((item) => Number(item.value)).filter((val) => !isNaN(val))
      if (values.length === 0) return 0

      switch (method) {
        case 'avg':
          return values.reduce((sum, val) => sum + val, 0) / values.length
        case 'max':
          return Math.max(...values)
        case 'min':
          return Math.min(...values)
        case 'median': {
          const sorted = values.sort((a, b) => a - b)
          const mid = Math.floor(sorted.length / 2)
          return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid]
        }
        case 'std': {
          const mean = values.reduce((sum, val) => sum + val, 0) / values.length
          const squaredDiffs = values.map((val) => Math.pow(val - mean, 2))
          return Math.sqrt(squaredDiffs.reduce((sum, val) => sum + val, 0) / values.length)
        }
        case 'count':
          return values.length
        default:
          return values[0] || 0
      }
    },

    // âœ… NEU: Sensor-Daten registrieren
    registerSensorData(espId, gpio, sensorData) {
      const key = `${espId}-${gpio}`
      this.visualizationDataMap.set(key, {
        ...sensorData,
        lastUpdate: Date.now(),
        source: 'mqtt',
      })

      // ðŸš¨ NEU: Alerts prÃ¼fen
      this.checkSensorAlerts(espId, gpio, sensorData)
    },

    // âœ… NEU: Datenquelle fÃ¼r Zone-Cards
    getZoneSensorData(espId) {
      const zoneData = []
      this.visualizationDataMap.forEach((data, key) => {
        if (key.startsWith(`${espId}-`)) {
          zoneData.push(data)
        }
      })
      return zoneData
    },

    // âœ… NEU: Datenquelle fÃ¼r Comparison-Panels
    getComparisonSensorData(selectedSensors) {
      return selectedSensors.map((sensor) => {
        const key = `${sensor.espId}-${sensor.gpio}`
        return this.visualizationDataMap.get(key) || sensor
      })
    },

    // âœ… NEU: Panel erstellen
    createPanel(config = {}) {
      const panelId = `panel_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

      const panel = {
        id: panelId,
        name: config.name || `Analysepanel #${this.comparisonPanels.size + 1}`,
        sensors: config.sensors || [],
        timeRange: config.timeRange || '1hour',
        visualizationType: config.visualizationType || 'line',
        layout: config.layout || { x: 0, y: 0, width: 400, height: 300 },
        createdAt: Date.now(),
        updatedAt: Date.now(),
      }

      this.comparisonPanels.set(panelId, panel)
      this.activePanelId = panelId
      this.saveConfig()

      return panel
    },

    // âœ… NEU: Panel aktualisieren
    updatePanel(panelId, updates) {
      const panel = this.comparisonPanels.get(panelId)
      if (!panel) return false

      const updatedPanel = {
        ...panel,
        ...updates,
        updatedAt: Date.now(),
      }

      this.comparisonPanels.set(panelId, updatedPanel)
      this.saveConfig()
      return true
    },

    // âœ… NEU: Panel duplizieren
    duplicatePanel(panelId) {
      const original = this.comparisonPanels.get(panelId)
      if (!original) return null

      const duplicated = {
        ...original,
        id: `panel_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        name: `${original.name} (Kopie)`,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      }

      this.comparisonPanels.set(duplicated.id, duplicated)
      this.saveConfig()
      return duplicated
    },

    // âœ… NEU: Panel lÃ¶schen
    deletePanel(panelId) {
      const deleted = this.comparisonPanels.delete(panelId)
      if (deleted) {
        this.saveConfig()
      }
      return deleted
    },

    // âœ… NEU: Panel-Position aktualisieren
    updatePanelPosition(panelId, position) {
      return this.updatePanel(panelId, {
        layout: { ...this.comparisonPanels.get(panelId)?.layout, ...position },
      })
    },

    // âœ… NEU: Panel-Name aktualisieren
    updatePanelName(panelId, name) {
      const panel = this.comparisonPanels.get(panelId)
      if (panel) {
        panel.name = name
        this.saveConfig()
      }
    },

    // ðŸš¨ NEU: Alert-Konfiguration erstellen
    createAlertConfig(espId, gpio, config) {
      const key = `${espId}-${gpio}`
      const alertConfig = {
        id: key,
        espId,
        gpio,
        enabled: config.enabled ?? true,
        thresholds: config.thresholds ?? [],
        criticalThresholds: config.criticalThresholds ?? [],
        offlineTimeout: config.offlineTimeout ?? 5 * 60 * 1000, // 5 Minuten
        trendAnalysis: config.trendAnalysis ?? false,
        notificationChannels: {
          ...this.alertSystem.notificationChannels,
          ...config.notificationChannels,
        },
        createdAt: Date.now(),
        updatedAt: Date.now(),
      }

      this.alertSystem.alerts.set(key, alertConfig)
      this.saveConfig()
      return alertConfig
    },

    // ðŸš¨ NEU: Alert-Konfiguration aktualisieren
    updateAlertConfig(espId, gpio, updates) {
      const key = `${espId}-${gpio}`
      const config = this.alertSystem.alerts.get(key)
      if (!config) return false

      const updatedConfig = {
        ...config,
        ...updates,
        updatedAt: Date.now(),
      }

      this.alertSystem.alerts.set(key, updatedConfig)
      this.saveConfig()
      return true
    },

    // ðŸš¨ NEU: Alert-Konfiguration lÃ¶schen
    deleteAlertConfig(espId, gpio) {
      const key = `${espId}-${gpio}`
      const deleted = this.alertSystem.alerts.delete(key)
      if (deleted) {
        this.saveConfig()
      }
      return deleted
    },

    // ðŸš¨ NEU: Sensor-Wert auf Alerts prÃ¼fen
    checkSensorAlerts(espId, gpio, sensorData) {
      const key = `${espId}-${gpio}`
      const alertConfig = this.alertSystem.alerts.get(key)

      if (!alertConfig || !alertConfig.enabled) return

      const value = Number(sensorData.value)
      const timestamp = Date.now()

      // Threshold-Alerts prÃ¼fen
      this.checkThresholdAlerts(alertConfig, value, timestamp)

      // Critical-Alerts prÃ¼fen
      this.checkCriticalAlerts(alertConfig, value, timestamp)

      // Trend-Analyse prÃ¼fen
      if (alertConfig.trendAnalysis) {
        this.checkTrendAlerts(alertConfig, value, timestamp)
      }
    },

    // ðŸš¨ NEU: Threshold-Alerts prÃ¼fen
    checkThresholdAlerts(config, value, timestamp) {
      config.thresholds.forEach((threshold) => {
        const isTriggered = value < threshold.min || value > threshold.max
        const alertKey = `${config.id}_threshold_${threshold.id}`

        if (isTriggered) {
          this.triggerAlert(
            alertKey,
            'threshold',
            {
              sensorId: config.id,
              threshold,
              value,
              message: `${config.name}: ${value}${config.unit} auÃŸerhalb des Bereichs ${threshold.min}-${threshold.max}${config.unit}`,
            },
            timestamp,
          )
        } else {
          this.clearAlert(alertKey)
        }
      })
    },

    // ðŸš¨ NEU: Critical-Alerts prÃ¼fen
    checkCriticalAlerts(config, value, timestamp) {
      config.criticalThresholds.forEach((threshold) => {
        const isTriggered = value < threshold.min || value > threshold.max
        const alertKey = `${config.id}_critical_${threshold.id}`

        if (isTriggered) {
          this.triggerAlert(
            alertKey,
            'critical',
            {
              sensorId: config.id,
              threshold,
              value,
              message: `KRITISCH: ${config.name}: ${value}${config.unit} im kritischen Bereich ${threshold.min}-${threshold.max}${config.unit}`,
            },
            timestamp,
          )
        } else {
          this.clearAlert(alertKey)
        }
      })
    },

    // ðŸš¨ NEU: Trend-Alerts prÃ¼fen
    checkTrendAlerts(config, value, timestamp) {
      // Einfache Trend-Analyse: PrÃ¼fe ob Wert sich in kritische Richtung bewegt
      const recentValues = this.getRecentSensorValues(config.espId, config.gpio, 10)
      if (recentValues.length < 5) return

      const trend = this.calculateTrend(recentValues)
      const isCriticalTrend = Math.abs(trend) > 0.1 // 10% Ã„nderung pro Messung

      if (isCriticalTrend) {
        const alertKey = `${config.id}_trend`
        this.triggerAlert(
          alertKey,
          'trend',
          {
            sensorId: config.id,
            trend,
            value,
            message: `TREND: ${config.name} zeigt kritischen Trend (${trend > 0 ? 'steigend' : 'fallend'})`,
          },
          timestamp,
        )
      }
    },

    // ðŸš¨ NEU: Alert auslÃ¶sen
    triggerAlert(alertKey, type, data, timestamp) {
      const cooldown = this.alertSystem.cooldownSettings[type]
      const lastAlert = this.alertSystem.activeAlerts.get(alertKey)

      // Cooldown prÃ¼fen
      if (lastAlert && timestamp - lastAlert.timestamp < cooldown) {
        return
      }

      const alert = {
        id: alertKey,
        type,
        data,
        timestamp,
        acknowledged: false,
      }

      this.alertSystem.activeAlerts.set(alertKey, alert)

      // Alert-Historie hinzufÃ¼gen
      this.addAlertToHistory(alert)

      // Benachrichtigungen senden
      this.sendAlertNotifications(alert)

      return alert
    },

    // ðŸš¨ NEU: Alert lÃ¶schen
    clearAlert(alertKey) {
      const alert = this.alertSystem.activeAlerts.get(alertKey)
      if (alert) {
        alert.acknowledged = true
        alert.clearedAt = Date.now()
        this.alertSystem.activeAlerts.delete(alertKey)
        this.addAlertToHistory(alert)
      }
    },

    // ðŸš¨ NEU: Alert bestÃ¤tigen
    acknowledgeAlert(alertKey) {
      const alert = this.alertSystem.activeAlerts.get(alertKey)
      if (alert) {
        alert.acknowledged = true
        alert.acknowledgedAt = Date.now()
        this.alertSystem.activeAlerts.delete(alertKey)
        this.addAlertToHistory(alert)
      }
    },

    // ðŸš¨ NEU: Alert zur Historie hinzufÃ¼gen
    addAlertToHistory(alert) {
      this.alertSystem.alertHistory.unshift(alert)

      // Historie begrenzen
      if (this.alertSystem.alertHistory.length > this.alertSystem.maxHistorySize) {
        this.alertSystem.alertHistory = this.alertSystem.alertHistory.slice(
          0,
          this.alertSystem.maxHistorySize,
        )
      }
    },

    // ðŸš¨ NEU: Benachrichtigungen senden
    sendAlertNotifications(alert) {
      const config = this.alertSystem.alerts.get(alert.data.sensorId)
      if (!config) return

      // Snackbar-Benachrichtigung (konsistent mit GlobalSnackbar)
      if (config.notificationChannels.snackbar) {
        this.showAlertSnackbar(alert)
      }

      // Sound-Benachrichtigung
      if (config.notificationChannels.sound) {
        this.playAlertSound(alert.type)
      }

      // Email-Benachrichtigung (wenn implementiert)
      if (config.notificationChannels.email) {
        this.sendAlertEmail(alert)
      }

      // Push-Benachrichtigung (wenn implementiert)
      if (config.notificationChannels.push) {
        this.sendAlertPush(alert)
      }
    },

    // ðŸš¨ NEU: Snackbar-Benachrichtigung anzeigen (konsistent mit GlobalSnackbar)
    showAlertSnackbar(alert) {
      const alertType = this.alertSystem.alertTypes[alert.type]

      if (window.$snackbar) {
        window.$snackbar.showAlert({
          message: alert.data.message,
          color: alertType.color,
          icon: alertType.icon,
          timeout: 10000, // 10 Sekunden fÃ¼r Alerts
          actions: [
            {
              text: 'BestÃ¤tigen',
              action: () => this.acknowledgeAlert(alert.id),
            },
            {
              text: 'Details',
              action: () => this.showAlertDetails(alert),
            },
          ],
        })
      }
    },

    // ðŸš¨ NEU: Alert-Sound abspielen
    playAlertSound(alertType) {
      // Einfache Sound-Implementierung
      const audioContext = new (window.AudioContext || window.webkitAudioContext)()
      const oscillator = audioContext.createOscillator()
      const gainNode = audioContext.createGain()

      oscillator.connect(gainNode)
      gainNode.connect(audioContext.destination)

      // Verschiedene Frequenzen fÃ¼r verschiedene Alert-Typen
      const frequencies = {
        threshold: 800,
        critical: 1200,
        offline: 600,
        trend: 1000,
      }

      oscillator.frequency.setValueAtTime(frequencies[alertType] || 800, audioContext.currentTime)
      gainNode.gain.setValueAtTime(0.1, audioContext.currentTime)

      oscillator.start()
      oscillator.stop(audioContext.currentTime + 0.5)
    },

    // ðŸš¨ NEU: Email-Benachrichtigung senden (Platzhalter)
    sendAlertEmail(alert) {
      // TODO: Email-Integration implementieren
      console.log('Email alert would be sent:', alert)
    },

    // ðŸš¨ NEU: Push-Benachrichtigung senden (Platzhalter)
    sendAlertPush(alert) {
      // TODO: Push-Integration implementieren
      console.log('Push alert would be sent:', alert)
    },

    // ðŸš¨ NEU: Alert-Details anzeigen
    showAlertDetails(alert) {
      // Event fÃ¼r Alert-Details-Dialog auslÃ¶sen
      this.$emit('show-alert-details', alert)
    },

    // ðŸš¨ NEU: Offline-Sensoren prÃ¼fen
    checkOfflineSensors() {
      const now = Date.now()

      this.alertSystem.alerts.forEach((config, key) => {
        if (!config.enabled) return

        const sensorData = this.visualizationDataMap.get(key)
        if (!sensorData) return

        const timeSinceLastUpdate = now - sensorData.lastUpdate
        const isOffline = timeSinceLastUpdate > config.offlineTimeout

        if (isOffline) {
          this.triggerAlert(
            `${key}_offline`,
            'offline',
            {
              sensorId: key,
              lastUpdate: sensorData.lastUpdate,
              offlineSince: timeSinceLastUpdate,
              message: `${config.name} ist offline (letztes Update: ${this.formatTimeAgo(sensorData.lastUpdate)})`,
            },
            now,
          )
        } else {
          this.clearAlert(`${key}_offline`)
        }
      })
    },

    // ðŸš¨ NEU: Hilfsfunktionen
    getRecentSensorValues(espId, gpio, count) {
      // Implementierung fÃ¼r Trend-Analyse
      const key = `${espId}-${gpio}`
      const sensorData = this.visualizationDataMap.get(key)
      if (!sensorData || !sensorData.history) return []

      return sensorData.history.slice(-count).map((entry) => entry.value)
    },

    calculateTrend(values) {
      if (values.length < 2) return 0

      const n = values.length
      const sumX = (n * (n - 1)) / 2
      const sumY = values.reduce((sum, val) => sum + val, 0)
      const sumXY = values.reduce((sum, val, index) => sum + index * val, 0)
      const sumX2 = values.reduce((sum, val, index) => sum + index * index, 0)

      const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX)
      return slope
    },

    formatTimeAgo(timestamp) {
      const now = Date.now()
      const diff = now - timestamp

      if (diff < 60000) return 'vor weniger als 1 Minute'
      if (diff < 3600000) return `vor ${Math.floor(diff / 60000)} Minuten`
      if (diff < 86400000) return `vor ${Math.floor(diff / 3600000)} Stunden`
      return `vor ${Math.floor(diff / 86400000)} Tagen`
    },

    // ðŸš¨ NEU: Alert-System ein-/ausschalten
    toggleAlertSystem(enabled = null) {
      this.alertSystem.enabled = enabled !== null ? enabled : !this.alertSystem.enabled
      this.saveConfig()
    },

    // ðŸš¨ NEU: Benachrichtigungskanal ein-/ausschalten
    toggleNotificationChannel(channel, enabled = null) {
      const newValue = enabled !== null ? enabled : !this.alertSystem.notificationChannels[channel]
      this.alertSystem.notificationChannels[channel] = newValue
      this.saveConfig()
    },

    // ðŸ†• NEU: Alert-Profil-Management
    createAlertProfile(name, description = '') {
      const profileId = `profile_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

      const profile = {
        id: profileId,
        name,
        description,
        createdAt: Date.now(),
        updatedAt: Date.now(),
        alertSystem: {
          enabled: this.alertSystem.enabled,
          alerts: Array.from(this.alertSystem.alerts.entries()),
          notificationChannels: { ...this.alertSystem.notificationChannels },
          cooldownSettings: { ...this.alertSystem.cooldownSettings },
          alertTypes: { ...this.alertSystem.alertTypes },
        },
      }

      this.alertProfiles.profiles.set(profileId, profile)
      this.saveConfig()
      return profile
    },

    // ðŸ†• NEU: Alert-Profil aktualisieren
    updateAlertProfile(profileId, updates) {
      const profile = this.alertProfiles.profiles.get(profileId)
      if (!profile) return false

      Object.assign(profile, updates, { updatedAt: Date.now() })
      this.saveConfig()
      return true
    },

    // ðŸ†• NEU: Alert-Profil lÃ¶schen
    deleteAlertProfile(profileId) {
      if (profileId === this.alertProfiles.defaultProfileId) {
        throw new Error('Das Standard-Profil kann nicht gelÃ¶scht werden')
      }

      const deleted = this.alertProfiles.profiles.delete(profileId)
      if (deleted && this.alertProfiles.activeProfileId === profileId) {
        this.alertProfiles.activeProfileId = this.alertProfiles.defaultProfileId
      }
      this.saveConfig()
      return deleted
    },

    // ðŸ†• NEU: Alert-Profil aktivieren
    activateAlertProfile(profileId) {
      const profile = this.alertProfiles.profiles.get(profileId)
      if (!profile) return false

      // Aktuelle Konfiguration als Backup speichern
      if (this.alertProfiles.activeProfileId) {
        this.saveCurrentConfigAsProfile(this.alertProfiles.activeProfileId)
      }

      // Profil-Konfiguration laden
      this.alertSystem.enabled = profile.alertSystem.enabled
      this.alertSystem.alerts = new Map(profile.alertSystem.alerts || [])
      this.alertSystem.notificationChannels = profile.alertSystem.notificationChannels || {}
      this.alertSystem.cooldownSettings = profile.alertSystem.cooldownSettings || {}
      this.alertSystem.alertTypes = profile.alertSystem.alertTypes || {}

      this.alertProfiles.activeProfileId = profileId
      this.saveConfig()
      return true
    },

    // ðŸ†• NEU: Aktuelle Konfiguration als Profil speichern
    saveCurrentConfigAsProfile(profileId) {
      const profile = this.alertProfiles.profiles.get(profileId)
      if (!profile) return false

      profile.alertSystem = {
        enabled: this.alertSystem.enabled,
        alerts: Array.from(this.alertSystem.alerts.entries()),
        notificationChannels: { ...this.alertSystem.notificationChannels },
        cooldownSettings: { ...this.alertSystem.cooldownSettings },
        alertTypes: { ...this.alertSystem.alertTypes },
      }
      profile.updatedAt = Date.now()

      this.saveConfig()
      return true
    },

    // ðŸ†• NEU: Alle verfÃ¼gbaren Profile abrufen
    getAlertProfiles() {
      return Array.from(this.alertProfiles.profiles.values()).sort(
        (a, b) => a.createdAt - b.createdAt,
      )
    },

    // ðŸ†• NEU: Aktives Profil abrufen
    getActiveAlertProfile() {
      return this.alertProfiles.profiles.get(this.alertProfiles.activeProfileId)
    },

    // ðŸ†• NEU: Standard-Profil erstellen (falls nicht vorhanden)
    ensureDefaultProfile() {
      if (!this.alertProfiles.profiles.has(this.alertProfiles.defaultProfileId)) {
        this.createAlertProfile('Standard', 'Standard-Alert-Konfiguration')
        this.alertProfiles.activeProfileId = this.alertProfiles.defaultProfileId
        this.saveConfig()
      }
    },

    // Konfiguration speichern (persistent)
    saveConfig() {
      storage.save('dashboard_config', {
        autoGeneratedDashboards: this.autoGeneratedDashboards,
        logicalAreas: this.logicalAreas,
        activeConfig: this.activeConfig,
        activeVisualizations: this.activeVisualizations,
        comparisonMode: this.comparisonMode,
        cardPositions: this.cardPositions,
        timeRanges: this.timeRanges,
        // âœ… NEU: Panel-Daten speichern
        comparisonPanels: Array.from(this.comparisonPanels.entries()),
        activePanelId: this.activePanelId,
        visualizationDataMap: Array.from(this.visualizationDataMap.entries()),
        alertSystem: {
          enabled: this.alertSystem.enabled,
          alerts: Array.from(this.alertSystem.alerts.entries()),
          activeAlerts: Array.from(this.alertSystem.activeAlerts.entries()),
          alertHistory: this.alertSystem.alertHistory,
          maxHistorySize: this.alertSystem.maxHistorySize,
          alertTypes: this.alertSystem.alertTypes,
          notificationChannels: this.alertSystem.notificationChannels,
          cooldownSettings: this.alertSystem.cooldownSettings,
        },
        // ðŸ†• NEU: Alert-Profile speichern
        alertProfiles: {
          profiles: Array.from(this.alertProfiles.profiles.entries()),
          activeProfileId: this.alertProfiles.activeProfileId,
          defaultProfileId: this.alertProfiles.defaultProfileId,
        },
      })
    },

    // Konfiguration laden (persistent)
    loadConfig() {
      const config = storage.load('dashboard_config', null)
      if (config) {
        this.autoGeneratedDashboards = config.autoGeneratedDashboards || new Map()
        this.logicalAreas = config.logicalAreas || new Map()
        this.activeConfig = config.activeConfig || this.activeConfig
        this.activeVisualizations = config.activeVisualizations || this.activeVisualizations
        this.comparisonMode = config.comparisonMode || this.comparisonMode
        this.cardPositions = config.cardPositions || new Map()
        this.timeRanges = { ...this.timeRanges, ...(config.timeRanges || {}) }

        // âœ… NEU: Panel-Daten laden
        if (config.comparisonPanels) {
          this.comparisonPanels = new Map(config.comparisonPanels)
        }
        this.activePanelId = config.activePanelId || null

        // âœ… NEU: Visualisierungsdaten laden
        if (config.visualizationDataMap) {
          this.visualizationDataMap = new Map(config.visualizationDataMap)
        }

        // âœ… NEU: Alert-System laden
        if (config.alertSystem) {
          this.alertSystem.enabled = config.alertSystem.enabled
          this.alertSystem.alerts = new Map(config.alertSystem.alerts || [])
          this.alertSystem.activeAlerts = new Map(config.alertSystem.activeAlerts || [])
          this.alertSystem.alertHistory = config.alertSystem.alertHistory || []
          this.alertSystem.maxHistorySize = config.alertSystem.maxHistorySize || 100
          this.alertSystem.alertTypes = config.alertSystem.alertTypes || {}
          this.alertSystem.notificationChannels = config.alertSystem.notificationChannels || {}
          this.alertSystem.cooldownSettings = config.alertSystem.cooldownSettings || {}
        }

        // ðŸ†• NEU: Alert-Profile laden
        if (config.alertProfiles) {
          this.alertProfiles.profiles = new Map(config.alertProfiles.profiles || [])
          this.alertProfiles.activeProfileId = config.alertProfiles.activeProfileId || null
          this.alertProfiles.defaultProfileId = config.alertProfiles.defaultProfileId || 'default'
        }

        // ðŸ†• NEU: Standard-Profil sicherstellen
        this.ensureDefaultProfile()
      }
    },

    // âœ… NEU: Restore-Methode fÃ¼r Konsistenz mit main.js (robust)
    restoreDashboards() {
      try {
        // âœ… NEU: Sicherstellen, dass der Store vollstÃ¤ndig initialisiert ist
        if (!this.sensorGroups || typeof this.sensorGroups !== 'object') {
          console.warn('DashboardGenerator: Store not ready for restore, initializing...')
          this.loadConfig()
        } else {
          this.loadConfig()
        }

        // âœ… NEU: Validierung nach dem Laden
        if (typeof this.getSensorGroupKey !== 'function') {
          console.warn('DashboardGenerator: getSensorGroupKey method not available after restore')
        } else {
          console.log('DashboardGenerator: Store fully initialized and ready')
        }
      } catch (error) {
        console.warn('DashboardGenerator: Error during restore:', error.message)
      }
    },

    // âœ… NEU: Sensor-Gruppe fÃ¼r Typ ermitteln (robust)
    // âœ… KORRIGIERT: getSensorGroupKey als Action-Methode (fÃ¼r interne Verwendung)
    getSensorGroupKey(sensorType) {
      try {
        if (!this.sensorGroups || typeof this.sensorGroups !== 'object') {
          console.warn('DashboardGenerator: sensorGroups not available')
          return null
        }

        for (const [key, group] of Object.entries(this.sensorGroups)) {
          if (group?.sensors?.includes(sensorType)) {
            return key
          }
        }
        return null
      } catch (error) {
        console.warn('Error in getSensorGroupKey method:', error.message)
        return null
      }
    },

    // âœ… NEU: Validierung fÃ¼r Visualisierungstypen
    validateVisualizationType(sensorType, visualizationType) {
      const group = this.getSensorGroupKey(sensorType)
      if (!group) return { valid: true, reason: null }

      const availableTypes = this.sensorGroups[group].visualization.availableTypes
      if (!availableTypes.includes(visualizationType)) {
        return {
          valid: false,
          reason: `${visualizationType} ist nicht fÃ¼r ${this.sensorGroups[group].name} Sensoren verfÃ¼gbar`,
        }
      }

      return { valid: true, reason: null }
    },

    // âœ… NEU: Vorgeschlagener Visualisierungstyp
    getSuggestedVisualizationType(sensorType) {
      const group = this.getSensorGroupKey(sensorType)
      return this.sensorGroups[group]?.visualization?.defaultType || 'line'
    },

    // ðŸ†• NEU: Audit-Log fÃ¼r Drop-Aktionen
    addLogEntry(entry) {
      const logEntry = {
        id: `log_${Date.now()}_${Math.random()}`,
        timestamp: Date.now(),
        ...entry,
      }

      this.interactionLog.unshift(logEntry)

      // Begrenzung fÃ¼r Performance
      if (this.interactionLog.length > this.maxLogEntries) {
        this.interactionLog = this.interactionLog.slice(0, this.maxLogEntries)
      }

      // Dev-Modus Logging
      if (import.meta.env.DEV) {
        console.log('ðŸ” [Dashboard Log]', logEntry)
      }
    },

    // ðŸ†• NEU: Drop-Aktion loggen
    logDropAction(data) {
      this.addLogEntry({
        type: 'drop',
        action: 'element_dropped',
        elementType: data.type,
        elementName: data.name || data.zoneId || data.sensorId,
        mode: data.mode || 'unknown',
        success: true,
      })
    },

    // ðŸ†• NEU: Validierungsfehler loggen
    logValidationError(data, reason) {
      this.addLogEntry({
        type: 'validation',
        action: 'drop_rejected',
        elementType: data.type,
        reason: reason,
        success: false,
      })
    },

    // ðŸ†• NEU: Log-EintrÃ¤ge abrufen
    getInteractionLog(limit = 50) {
      return this.interactionLog.slice(0, limit)
    },

    // ðŸ†• NEU: Log nach Typ filtern
    getFilteredLog(type, limit = 50) {
      return this.interactionLog.filter((entry) => entry.type === type).slice(0, limit)
    },

    // ðŸ†• NEU: Log lÃ¶schen
    clearInteractionLog() {
      this.interactionLog = []
    },

    // ðŸ†• NEU: Log-Statistiken
    getLogStats() {
      const log = this.interactionLog
      const total = log.length
      const successCount = log.filter((entry) => entry.success).length
      const successRate = total > 0 ? (successCount / total) * 100 : 0

      // Gruppierung nach Typ
      const byType = {}
      log.forEach((entry) => {
        byType[entry.type] = (byType[entry.type] || 0) + 1
      })

      // Gruppierung nach Aktion
      const byAction = {}
      log.forEach((entry) => {
        byAction[entry.action] = (byAction[entry.action] || 0) + 1
      })

      // Letzte Stunde
      const oneHourAgo = Date.now() - 60 * 60 * 1000
      const recentActivity = log.filter((entry) => entry.timestamp > oneHourAgo).length

      return {
        total,
        successCount,
        successRate,
        byType,
        byAction,
        recentActivity,
      }
    },

    // ðŸ†• NEU: Export-Funktionen
    exportInteractionLogAsCSV(filterOptions = {}) {
      const log = this.getFilteredLogForExport(filterOptions)

      const headers = [
        'Timestamp',
        'Type',
        'Action',
        'ElementType',
        'ElementName',
        'Mode',
        'Success',
        'Reason',
        'Duration',
      ]

      const csvContent = [
        headers.join(','),
        ...log.map((entry) =>
          [
            new Date(entry.timestamp).toISOString(),
            entry.type,
            entry.action,
            entry.elementType || '',
            entry.elementName || '',
            entry.mode || '',
            entry.success ? 'true' : 'false',
            entry.reason || '',
            entry.duration || '',
          ].join(','),
        ),
      ].join('\n')

      return this.downloadAsFile(csvContent, 'interaction-log.csv', 'text/csv')
    },

    exportInteractionLogAsJSON(filterOptions = {}) {
      const log = this.getFilteredLogForExport(filterOptions)

      const exportData = {
        version: '1.0',
        timestamp: new Date().toISOString(),
        filterOptions,
        totalEntries: log.length,
        entries: log,
      }

      return this.downloadAsFile(
        JSON.stringify(exportData, null, 2),
        'interaction-log.json',
        'application/json',
      )
    },

    getFilteredLogForExport(filterOptions) {
      let log = this.interactionLog

      if (filterOptions.type) {
        log = log.filter((entry) => entry.type === filterOptions.type)
      }

      if (filterOptions.success !== undefined) {
        log = log.filter((entry) => entry.success === filterOptions.success)
      }

      if (filterOptions.mode) {
        log = log.filter((entry) => entry.mode === filterOptions.mode)
      }

      if (filterOptions.timeRange) {
        const cutoff = Date.now() - filterOptions.timeRange
        log = log.filter((entry) => entry.timestamp > cutoff)
      }

      return log
    },

    downloadAsFile(content, filename, mimeType) {
      const blob = new Blob([content], { type: mimeType })
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = filename
      document.body.appendChild(a)
      a.click()
      document.body.removeChild(a)
      URL.revokeObjectURL(url)

      return { success: true, filename }
    },

    // âœ… NEU: Sensor-Gruppen initialisieren (robust)
    initializeSensorGroups() {
      try {
        // âœ… NEU: Sicherstellen, dass sensorGroups korrekt initialisiert ist
        if (!this.sensorGroups || typeof this.sensorGroups !== 'object') {
          this.sensorGroups = {
            temperature: {
              name: 'Temperatur',
              sensors: ['SENSOR_TEMP_DS18B20', 'SENSOR_TEMP_DHT22'],
              color: '#ff6b6b',
              icon: 'mdi-thermometer',
              unit: 'Â°C',
              visualization: {
                defaultType: 'line',
                availableTypes: ['line', 'gauge', 'status', 'bar', 'value-only'],
                mobileOptimized: true,
                chartOptions: {
                  line: { showTrend: true, showMinMax: true },
                  gauge: { min: 0, max: 50, thresholds: [15, 30, 40] },
                  status: { thresholds: [15, 30, 40] },
                  bar: { showHistory: true, maxBars: 24 },
                  'value-only': { showUnit: true, showTrend: false },
                },
              },
              criticalRanges: [
                { min: 0, max: 35, color: 'success' },
                { min: 35, max: 40, color: 'warning' },
                { min: 40, max: 50, color: 'error' },
              ],
            },
            humidity: {
              name: 'Luftfeuchtigkeit',
              sensors: ['SENSOR_HUMIDITY', 'SENSOR_SOIL'],
              color: '#4ecdc4',
              icon: 'mdi-water-percent',
              unit: '%',
              visualization: {
                defaultType: 'gauge',
                availableTypes: ['gauge', 'line', 'status', 'bar', 'value-only'],
                mobileOptimized: true,
                chartOptions: {
                  gauge: { min: 0, max: 100, thresholds: [30, 60, 80] },
                  line: { showTrend: true, showMinMax: true },
                  status: { thresholds: [30, 60, 80] },
                  bar: { showHistory: true, maxBars: 24 },
                  'value-only': { showUnit: true, showTrend: false },
                },
              },
              criticalRanges: [
                { min: 0, max: 30, color: 'error' },
                { min: 30, max: 60, color: 'success' },
                { min: 60, max: 80, color: 'warning' },
                { min: 80, max: 100, color: 'error' },
              ],
            },
            light: {
              name: 'Licht',
              sensors: ['SENSOR_LIGHT'],
              color: '#ffe66d',
              icon: 'mdi-white-balance-sunny',
              unit: 'lux',
              visualization: {
                defaultType: 'bar',
                availableTypes: ['bar', 'line', 'status', 'gauge', 'value-only'],
                mobileOptimized: true,
                chartOptions: {
                  bar: { showHistory: true, maxBars: 24 },
                  line: { showTrend: true, showMinMax: true },
                  status: { thresholds: [1000, 10000] },
                  gauge: { min: 0, max: 50000, thresholds: [1000, 10000] },
                  'value-only': { showUnit: true, showTrend: false },
                },
              },
              criticalRanges: [
                { min: 0, max: 1000, color: 'error' },
                { min: 1000, max: 10000, color: 'success' },
                { min: 10000, max: 50000, color: 'warning' },
              ],
            },
            moisture: {
              name: 'Bodenfeuchtigkeit',
              sensors: ['SENSOR_MOISTURE'],
              color: '#4ecdc4',
              icon: 'mdi-water-percent',
              unit: '%',
              visualization: {
                defaultType: 'gauge',
                availableTypes: ['gauge', 'line', 'status', 'bar', 'value-only'],
                mobileOptimized: true,
                chartOptions: {
                  gauge: { min: 0, max: 100, thresholds: [40, 80] },
                  line: { showTrend: true, showMinMax: true },
                  status: { thresholds: [40, 80] },
                  bar: { showHistory: true, maxBars: 24 },
                  'value-only': { showUnit: true, showTrend: false },
                },
              },
              criticalRanges: [
                { min: 0, max: 40, color: 'error' },
                { min: 40, max: 80, color: 'success' },
                { min: 80, max: 100, color: 'warning' },
              ],
            },
            digital: {
              name: 'Digitale Sensoren',
              sensors: ['SENSOR_DIGITAL', 'SENSOR_SWITCH'],
              color: '#4caf50',
              icon: 'mdi-toggle-switch',
              unit: '',
              visualization: {
                defaultType: 'status',
                availableTypes: ['status', 'value-only'],
                mobileOptimized: true,
                chartOptions: {
                  status: { thresholds: [0, 1] },
                  'value-only': { showUnit: false, showTrend: false },
                },
              },
              criticalRanges: [
                { min: 0, max: 0, color: 'error' },
                { min: 1, max: 1, color: 'success' },
              ],
            },
          }
        }

        return true
      } catch (error) {
        errorHandler.error('Failed to initialize sensor groups', error)
        return false
      }
    },

    // ðŸ†• NEU: Event-Handler fÃ¼r Dashboard Generator Events
    handleRequestEspDevices(data) {
      try {
        console.log('[DashboardGenerator] Request ESP devices received:', data)
        // Response mit verfÃ¼gbaren ESP-GerÃ¤ten senden
        const espDevices = this.getAvailableEspDevices()
        eventBus.emit(MQTT_EVENTS.REQUEST_ESP_DEVICES, {
          devices: espDevices,
          timestamp: Date.now(),
        })
      } catch (error) {
        errorHandler.error('Failed to handle request ESP devices', error, { data })
      }
    },

    handleRequestEspSensors(data) {
      try {
        console.log('[DashboardGenerator] Request ESP sensors received:', data)
        const sensors = this.getSensorsForEsp(data.espId)
        eventBus.emit(MQTT_EVENTS.REQUEST_ESP_SENSORS, {
          espId: data.espId,
          sensors: sensors,
          timestamp: Date.now(),
        })
      } catch (error) {
        errorHandler.error('Failed to handle request ESP sensors', error, { data })
      }
    },

    handleRequestEspSubzones(data) {
      try {
        console.log('[DashboardGenerator] Request ESP subzones received:', data)
        const subzones = this.getSubzonesForEsp(data.espId)
        eventBus.emit(MQTT_EVENTS.REQUEST_ESP_SUBZONES, {
          espId: data.espId,
          subzones: subzones,
          timestamp: Date.now(),
        })
      } catch (error) {
        errorHandler.error('Failed to handle request ESP subzones', error, { data })
      }
    },

    // ðŸ†• NEU: Helper-Methoden fÃ¼r Event-Handler
    getAvailableEspDevices() {
      // Implementierung fÃ¼r verfÃ¼gbare ESP-GerÃ¤te
      return []
    },

    // ðŸ†• NEU: Event-Listener-Initialisierung
    initializeEventListeners() {
      // Dashboard Generator Event-Handler registrieren
      eventBus.on(MQTT_EVENTS.REQUEST_ESP_DEVICES, (data) => this.handleRequestEspDevices(data))
      eventBus.on(MQTT_EVENTS.REQUEST_ESP_SENSORS, (data) => this.handleRequestEspSensors(data))
      eventBus.on(MQTT_EVENTS.REQUEST_ESP_SUBZONES, (data) => this.handleRequestEspSubzones(data))

      console.log('âœ… DashboardGenerator Event-Listener initialisiert')
    },
  },

  // ðŸ†• NEU: Store-Initialisierung mit Event-Listenern
  setup() {
    const store = useDashboardGeneratorStore()

    // âœ… NEU: Sensor-Gruppen initialisieren
    store.initializeSensorGroups()

    // âœ… NEU: Event-Listener initialisieren
    store.initializeEventListeners()

    // âœ… NEU: Konfiguration laden
    store.loadConfig()

    // âœ… NEU: Store im Event-System registrieren
    storeHandler.registerStore('dashboardGenerator', store)

    // âŒ ENTFERNT: ZirkulÃ¤re Event-Emission
    // eventBus.emit(STORE_EVENTS.STORE_READY, {
    //   storeName: 'dashboardGenerator',
    //   timestamp: Date.now(),
    // })

    console.log('âœ… DashboardGenerator Store setup completed')
    return {}
  },
})
