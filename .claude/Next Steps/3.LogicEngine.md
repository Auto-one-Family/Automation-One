# DEV-BRIEFING 03: Logic Engine Visual Builder

> **Ziel:** Node-Red-ähnlicher visueller Rule-Editor für Cross-ESP-Automation mit Drag-and-Drop und Verbindungslinien
> **Priorität:** KRITISCH - Kern-Feature für Benutzerfreundlichkeit
> **Geschätzter Aufwand:** 5-8 Entwicklertage

---

## 1. Problemstellung

### 1.1 Aktuelle Situation

Die Logic Engine ist **serverseitig vollständig implementiert**:
- ✅ Rule-CRUD via API
- ✅ Condition-Evaluation (Sensor-Threshold, Time-Window, Compound)
- ✅ Action-Execution (Actuator-Command, Delay, Notification)
- ✅ Cooldown & Rate-Limiting
- ✅ Execution-History

**Frontend-Status:**
- `LogicView.vue` ist nur ein **Placeholder** (zeigt Beispiel-Rule)
- Keine Rule-Erstellung möglich
- Keine visuelle Darstellung von Sensor→Actuator-Verbindungen

### 1.2 Gewünschter Zustand

**Node-Red-ähnlicher Visual Builder:**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Logic Engine - Visual Builder                         │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌─────────────┐          ┌─────────────────┐         ┌─────────────┐   │
│  │  ESP_TEMP   │          │   RULE EDITOR   │         │  ESP_PUMP   │   │
│  │  ┌───────┐  │──────────│                 │─────────│  ┌───────┐  │   │
│  │  │Temp   │──┼──────────│ Wenn Temp > 30  │─────────┼──│Pumpe  │  │   │
│  │  │GPIO 4 │  │          │ Dann Pumpe AN   │         │  │GPIO 5 │  │   │
│  │  └───────┘  │          │ Cooldown: 5min  │         │  └───────┘  │   │
│  │             │          └─────────────────┘         │             │   │
│  │  ┌───────┐  │                                      │  ┌───────┐  │   │
│  │  │Humid  │──┼──────────────────────────────────────┼──│Lüfter │  │   │
│  │  │GPIO 21│  │          (weitere Regel)             │  │GPIO 12│  │   │
│  │  └───────┘  │                                      │  └───────┘  │   │
│  └─────────────┘                                      └─────────────┘   │
│                                                                          │
│  [+ Neue Regel]  [Regeln: 5 aktiv]  [History: 42 Ausführungen]          │
└─────────────────────────────────────────────────────────────────────────┘
```

**User-Flow beim Erstellen einer Regel:**

1. **Sensor auswählen:** Klick auf Sensor-Dot → Verbindungslinie startet
2. **Actuator verbinden:** Linie zum Actuator-Dot ziehen → Drop
3. **Rule-Editor öffnet sich automatisch:** Bedingungen und Aktionen definieren
4. **Regel speichern:** Rule wird in DB gespeichert, Verbindungslinie wird permanent

---

## 2. Systemverständnis (PFLICHTLEKTÜRE)

**Bevor du Code schreibst, lies diese Dokumentation:**

| Dokument | Pfad | Relevanz |
|----------|------|----------|
| **Logic Engine Flow** | `El Servador/docs/system-flows-server-frontend/13-logic-engine-flow-server-frontend.md` | API, Datenstrukturen, Flows |
| **CLAUDE_SERVER.md** | `.claude/CLAUDE_SERVER.md` | Section 3.5: Automation Rule |
| **Hierarchie.md** | `Hierarchie.md` | Cross-ESP-Kommunikation |
| **View-Summary** | `El Frontend/Docs/02-Individual-Views-Summary.md` | LogicView Placeholder |

### 2.1 Logic Engine API (bereits implementiert)

| Endpoint | Methode | Beschreibung |
|----------|---------|--------------|
| `/api/v1/logic/rules` | GET | Alle Rules auflisten |
| `/api/v1/logic/rules` | POST | Neue Rule erstellen |
| `/api/v1/logic/rules/{id}` | GET | Single Rule abrufen |
| `/api/v1/logic/rules/{id}` | PUT | Rule aktualisieren |
| `/api/v1/logic/rules/{id}` | DELETE | Rule löschen |
| `/api/v1/logic/rules/{id}/toggle` | POST | Rule aktivieren/deaktivieren |
| `/api/v1/logic/rules/{id}/test` | POST | Rule testen (Dry-Run) |
| `/api/v1/logic/execution_history` | GET | Ausführungs-Historie |

### 2.2 Rule-Datenstruktur

```typescript
interface LogicRule {
  id: string;
  rule_name: string;
  description?: string;
  enabled: boolean;
  priority: number;
  
  // Trigger-Conditions (Sensor-basiert)
  conditions: {
    logic: "AND" | "OR";
    conditions: Condition[];
  };
  
  // Actions (Actuator-basiert)
  actions: Action[];
  
  // Rate-Limiting
  cooldown_seconds: number;
  max_executions_per_hour?: number;
  
  // Time-Window (optional)
  time_start?: string; // "06:00"
  time_end?: string;   // "22:00"
  
  // Metadata
  last_triggered?: string;
  execution_count: number;
  created_at: string;
  updated_at: string;
}

interface Condition {
  type: "sensor_threshold" | "sensor" | "time_window";
  esp_id: string;
  gpio: number;
  sensor_type?: string;
  operator: ">" | ">=" | "<" | "<=" | "==" | "between";
  value: number;
  min?: number;  // für "between"
  max?: number;  // für "between"
}

interface Action {
  type: "actuator_command" | "actuator" | "delay" | "notification";
  esp_id: string;
  gpio: number;
  command: "ON" | "OFF" | "SET";
  value?: number;  // 0.0-1.0 für PWM
  duration_seconds?: number;
}
```

---

## 3. Codebase-Analyse (PHASE 1)

### 3.1 Frontend analysieren

**Bestehende Komponenten prüfen:**

| Datei | Pfad | Prüfen auf |
|-------|------|------------|
| `LogicView.vue` | `El Frontend/src/views/LogicView.vue` | Aktueller Placeholder |
| `ESPOrbitalLayout.vue` | `El Frontend/src/components/esp/ESPOrbitalLayout.vue` | Sensor/Actuator-Dots |
| `DashboardView.vue` | `El Frontend/src/views/DashboardView.vue` | ESP-Cards mit Satellites |
| `useRealTimeData.ts` | `El Frontend/src/composables/useRealTimeData.ts` | WebSocket-Events |
| `espDevices.ts` | `El Frontend/src/stores/espDevices.ts` | ESP-Daten |

**Fragen für die Analyse:**

1. **Wie werden Sensoren/Actuatoren aktuell dargestellt?**
   - Orbital-Layout mit Dots
   - Position: Sensoren links, Actuatoren rechts

2. **Welche Daten sind pro Sensor/Actuator verfügbar?**
   - `esp_id`, `gpio`, `sensor_type`/`actuator_type`, `name`, `value`/`state`

3. **Gibt es bereits Drag-and-Drop-Logik?**
   - Ja, für Zone-Assignment (ZoneAssignmentPanel)

### 3.2 Backend analysieren

**Logic Engine Dateien:**

| Datei | Pfad | Funktion |
|-------|------|----------|
| `logic.py` | `El Servador/.../api/v1/logic.py` | REST-API |
| `logic_engine.py` | `El Servador/.../services/logic_engine.py` | Evaluation & Execution |
| `logic_scheduler.py` | `El Servador/.../services/logic_scheduler.py` | Timer-Trigger |
| `logic_validation.py` | `El Servador/.../db/models/logic_validation.py` | Validation |
| `logic.py` | `El Servador/.../db/models/logic.py` | Database-Models |
| `logic_repo.py` | `El Servador/.../db/repositories/logic_repo.py` | Repository |

**WebSocket-Events:**
- `logic_execution` - Wird bei Rule-Ausführung gebroadcastet (bereits implementiert)

---

## 4. Frontend-Architektur (PHASE 2)

### 4.1 Komponenten-Hierarchie

```
LogicBuilderView.vue (Hauptseite)
├── LogicCanvas.vue (SVG-Canvas für Verbindungslinien)
│   ├── ConnectionLine.vue (einzelne Verbindung)
│   └── DragPreviewLine.vue (während Drag)
├── LogicESPCard.vue (ESP mit Sensor/Actuator-Dots)
│   ├── SensorDot.vue (draggable)
│   └── ActuatorDot.vue (drop-target)
├── RuleEditorModal.vue (Rule-Konfiguration)
│   ├── ConditionBuilder.vue
│   │   ├── SensorCondition.vue
│   │   └── TimeCondition.vue
│   ├── ActionBuilder.vue
│   │   └── ActuatorAction.vue
│   └── RuleSettings.vue (Cooldown, Priority)
├── RuleList.vue (Sidebar mit allen Rules)
│   └── RuleListItem.vue
└── ExecutionHistory.vue (letzte Ausführungen)
```

### 4.2 Canvas-System für Verbindungslinien

**SVG-basiertes Line-Drawing:**

```vue
<!-- LogicCanvas.vue -->
<template>
  <svg class="logic-canvas" :viewBox="viewBox">
    <!-- Bestehende Verbindungen -->
    <ConnectionLine
      v-for="rule in activeRules"
      :key="rule.id"
      :from="getSensorPosition(rule.conditions)"
      :to="getActuatorPosition(rule.actions)"
      :rule="rule"
      @click="openRuleEditor(rule)"
    />
    
    <!-- Drag-Preview während Verbindung erstellen -->
    <DragPreviewLine
      v-if="isDragging"
      :from="dragStart"
      :to="mousePosition"
    />
  </svg>
</template>
```

**Bezier-Kurven für elegante Linien:**

```typescript
// ConnectionLine.vue
const calculatePath = (from: Point, to: Point): string => {
  const midX = (from.x + to.x) / 2;
  
  // Bezier-Kontrollpunkte
  return `M ${from.x} ${from.y} 
          C ${midX} ${from.y}, 
            ${midX} ${to.y}, 
            ${to.x} ${to.y}`;
};
```

### 4.3 Drag-and-Drop-System

**Sensor-Dot (Drag-Source):**

```vue
<!-- SensorDot.vue -->
<template>
  <div
    class="sensor-dot"
    draggable="true"
    @dragstart="handleDragStart"
    @dragend="handleDragEnd"
  >
    <div class="dot-icon">{{ sensorIcon }}</div>
    <div class="dot-label">{{ sensor.name }}</div>
  </div>
</template>

<script setup>
const handleDragStart = (e: DragEvent) => {
  // Sensor-Daten in DataTransfer
  e.dataTransfer.setData('application/json', JSON.stringify({
    type: 'sensor',
    esp_id: props.espId,
    gpio: props.sensor.gpio,
    sensor_type: props.sensor.sensor_type,
  }));
  
  // Visual-Feedback
  emit('drag-start', { espId: props.espId, gpio: props.sensor.gpio });
};
</script>
```

**Actuator-Dot (Drop-Target):**

```vue
<!-- ActuatorDot.vue -->
<template>
  <div
    class="actuator-dot"
    :class="{ 'drop-active': isDropTarget }"
    @dragover.prevent="handleDragOver"
    @dragleave="handleDragLeave"
    @drop="handleDrop"
  >
    <div class="dot-icon">{{ actuatorIcon }}</div>
    <div class="dot-label">{{ actuator.name }}</div>
  </div>
</template>

<script setup>
const handleDrop = (e: DragEvent) => {
  const sensorData = JSON.parse(e.dataTransfer.getData('application/json'));
  
  // Öffne Rule-Editor mit vorausgefüllten Daten
  emit('create-rule', {
    sensor: sensorData,
    actuator: {
      esp_id: props.espId,
      gpio: props.actuator.gpio,
      actuator_type: props.actuator.actuator_type,
    }
  });
};
</script>
```

### 4.4 Rule-Editor-Modal

**Workflow:**
1. User verbindet Sensor → Actuator (Drag-and-Drop)
2. Modal öffnet sich mit vorausgefüllten Sensor/Actuator-Daten
3. User definiert Bedingungen (Threshold, Operator)
4. User definiert Aktionen (ON/OFF/SET, Duration)
5. User speichert → API-Call → Linie wird permanent

```vue
<!-- RuleEditorModal.vue -->
<template>
  <v-dialog v-model="isOpen" max-width="800">
    <v-card>
      <v-card-title>
        {{ isEdit ? 'Regel bearbeiten' : 'Neue Regel erstellen' }}
      </v-card-title>
      
      <v-card-text>
        <!-- Sensor-Seite (readonly wenn aus Drag) -->
        <div class="rule-visualization">
          <div class="sensor-side">
            <h4>Wenn...</h4>
            <ConditionBuilder
              :conditions="rule.conditions"
              :available-sensors="availableSensors"
              @update="updateConditions"
            />
          </div>
          
          <div class="connection-arrow">→</div>
          
          <div class="actuator-side">
            <h4>Dann...</h4>
            <ActionBuilder
              :actions="rule.actions"
              :available-actuators="availableActuators"
              @update="updateActions"
            />
          </div>
        </div>
        
        <!-- Erweiterte Einstellungen -->
        <RuleSettings
          :cooldown="rule.cooldown_seconds"
          :priority="rule.priority"
          :time-window="{ start: rule.time_start, end: rule.time_end }"
          @update="updateSettings"
        />
      </v-card-text>
      
      <v-card-actions>
        <v-btn @click="testRule" :loading="testing">
          Test (Dry-Run)
        </v-btn>
        <v-spacer />
        <v-btn @click="close">Abbrechen</v-btn>
        <v-btn color="primary" @click="save" :loading="saving">
          Speichern
        </v-btn>
      </v-card-actions>
    </v-card>
  </v-dialog>
</template>
```

### 4.5 Condition Builder

**Menschenlesbare Condition-Erstellung:**

```vue
<!-- ConditionBuilder.vue -->
<template>
  <div class="condition-builder">
    <!-- Bestehende Conditions -->
    <div v-for="(condition, index) in conditions.conditions" :key="index" class="condition-row">
      <SensorCondition
        v-if="condition.type === 'sensor_threshold'"
        :condition="condition"
        :sensors="availableSensors"
        @update="(c) => updateCondition(index, c)"
        @remove="removeCondition(index)"
      />
      
      <TimeCondition
        v-else-if="condition.type === 'time_window'"
        :condition="condition"
        @update="(c) => updateCondition(index, c)"
        @remove="removeCondition(index)"
      />
      
      <!-- Logic-Operator zwischen Conditions -->
      <v-select
        v-if="index < conditions.conditions.length - 1"
        v-model="conditions.logic"
        :items="['AND', 'OR']"
        density="compact"
        class="logic-select"
      />
    </div>
    
    <!-- Neue Condition hinzufügen -->
    <v-btn
      variant="outlined"
      size="small"
      @click="addCondition"
    >
      + Bedingung hinzufügen
    </v-btn>
  </div>
</template>
```

**SensorCondition mit natürlicher Sprache:**

```vue
<!-- SensorCondition.vue -->
<template>
  <div class="sensor-condition">
    <span class="condition-text">
      Wenn 
      <v-select
        v-model="selectedSensor"
        :items="sensorOptions"
        item-title="label"
        item-value="value"
        density="compact"
        class="inline-select"
      />
      <v-select
        v-model="condition.operator"
        :items="operators"
        density="compact"
        class="inline-select small"
      />
      <v-text-field
        v-model.number="condition.value"
        type="number"
        density="compact"
        class="inline-input"
      />
      {{ sensorUnit }}
    </span>
  </div>
</template>
```

---

## 5. Backend-Erweiterungen

### 5.1 API für Visual Builder

**Neuer Endpoint für Sensor/Actuator-Liste:**

```python
# In logic.py hinzufügen
@router.get("/available-devices")
async def get_available_devices(db: AsyncSession = Depends(get_db)):
    """
    Gibt alle ESPs mit ihren Sensoren und Actuatoren zurück.
    Formatiert für den Visual Builder.
    """
    esp_service = ESPService(ESPRepository(db), get_mqtt_publisher())
    devices = await esp_service.get_all_with_sensors_and_actuators()
    
    return {
        "esps": [
            {
                "esp_id": esp.esp_id,
                "name": esp.name,
                "zone_id": esp.zone_id,
                "is_mock": esp.is_mock,
                "sensors": [
                    {
                        "gpio": s.gpio,
                        "sensor_type": s.sensor_type,
                        "name": s.sensor_name,
                        "unit": s.unit,
                        "current_value": s.last_value,
                    }
                    for s in esp.sensors
                ],
                "actuators": [
                    {
                        "gpio": a.gpio,
                        "actuator_type": a.actuator_type,
                        "name": a.actuator_name,
                        "current_state": a.state,
                    }
                    for a in esp.actuators
                ],
            }
            for esp in devices
        ]
    }
```

### 5.2 WebSocket für Live-Updates

**Neue Events:**

| Event | Trigger | Payload |
|-------|---------|---------|
| `logic_rule_created` | Rule erstellt | `{ rule_id, rule_name }` |
| `logic_rule_updated` | Rule aktualisiert | `{ rule_id, changes }` |
| `logic_rule_deleted` | Rule gelöscht | `{ rule_id }` |
| `logic_execution` | Rule ausgeführt | Bereits implementiert |

---

## 6. Mock-ESP vs. Real-ESP

### 6.1 Identische Behandlung

**Beide Typen funktionieren gleich:**
- Mock-ESPs haben Sensoren/Actuatoren wie echte ESPs
- Logic Engine unterscheidet nicht nach Mock/Real
- Visual Builder zeigt beide Typen

**Visuelle Unterscheidung:**
- Mock-ESPs: Gestrichelter Rahmen, "MOCK"-Badge
- Real-ESPs: Durchgehender Rahmen, "LIVE"-Badge

### 6.2 Cross-Type Rules

**Erlaubt:**
- Mock-Sensor → Real-Actuator
- Real-Sensor → Mock-Actuator
- Mock-Sensor → Mock-Actuator

**Wichtig für Tests:** Kann Mock-Sensor nutzen, um Real-Actuator zu testen

---

## 7. Implementierungs-Checkliste

### Phase 1: Grundstruktur (Tag 1-2)

- [ ] `LogicBuilderView.vue` erstellen
- [ ] `LogicCanvas.vue` mit SVG-Grundgerüst
- [ ] `LogicESPCard.vue` basierend auf ESPOrbitalLayout
- [ ] `SensorDot.vue` und `ActuatorDot.vue`
- [ ] Drag-and-Drop-System implementieren
- [ ] Pinia Store für Rules erstellen

### Phase 2: Rule-Editor (Tag 2-3)

- [ ] `RuleEditorModal.vue` erstellen
- [ ] `ConditionBuilder.vue` mit SensorCondition/TimeCondition
- [ ] `ActionBuilder.vue` mit ActuatorAction
- [ ] `RuleSettings.vue` für Cooldown/Priority
- [ ] API-Integration (Create, Update)

### Phase 3: Visualisierung (Tag 3-4)

- [ ] `ConnectionLine.vue` mit Bezier-Kurven
- [ ] `DragPreviewLine.vue` für Live-Preview
- [ ] Farb-Kodierung für Rule-Status
- [ ] Pulsierender Effekt bei Ausführung
- [ ] Hover-Info auf Linien

### Phase 4: Rule-Management (Tag 4-5)

- [ ] `RuleList.vue` Sidebar
- [ ] Toggle-Funktionalität
- [ ] Delete mit Bestätigung
- [ ] Duplicate-Rule-Funktion
- [ ] `ExecutionHistory.vue`

### Phase 5: WebSocket & Live (Tag 5-6)

- [ ] WebSocket-Events für Rule-Updates
- [ ] Live-Execution-Visualisierung
- [ ] Sensor-Wert-Updates auf Dots
- [ ] Actuator-State-Updates auf Dots

### Phase 6: Polish & Testing (Tag 6-8)

- [ ] Responsive Design
- [ ] Error-Handling
- [ ] Loading-States
- [ ] Test mit Mock-ESPs
- [ ] Test mit (simulierten) Real-ESPs
- [ ] Dokumentation

---

## 8. Design-Richtlinien

### 8.1 Visuelle Sprache

- **Sensoren:** Blaue Dots (links am ESP-Card)
- **Actuatoren:** Grüne Dots (rechts am ESP-Card)
- **Verbindungslinien:** Farbverlauf Blau→Grün
- **Aktive Rules:** Durchgezogene Linie
- **Deaktivierte Rules:** Gestrichelte Linie
- **Ausführung:** Pulsierende Animation

### 8.2 Menschenlesbare Darstellung

**Auf Verbindungslinie anzeigen:**
```
"Wenn Temp > 30°C → Pumpe AN (5min)"
```

**Tooltips:**
- Letzte Ausführung
- Ausführungs-Count
- Cooldown-Status

---

## 9. Code-Locations Referenz

| Komponente | Pfad | Beschreibung |
|------------|------|--------------|
| **Logic API** | `El Servador/.../api/v1/logic.py` | REST-Endpoints |
| **Logic Engine** | `El Servador/.../services/logic_engine.py` | Evaluation |
| **Logic Models** | `El Servador/.../db/models/logic.py` | Database |
| **LogicView** | `El Frontend/src/views/LogicView.vue` | Placeholder |
| **ESPOrbitalLayout** | `El Frontend/src/components/esp/ESPOrbitalLayout.vue` | Vorlage |
| **useRealTimeData** | `El Frontend/src/composables/useRealTimeData.ts` | WebSocket |

---

**Dokument-Version:** 1.0  
**Erstellt:** 2026-01-05  
**Autor:** Claude (Manager-Modus)  
**Nächste Review:** Nach Phase 2