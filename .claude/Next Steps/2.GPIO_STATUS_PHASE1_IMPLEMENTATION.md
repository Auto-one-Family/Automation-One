# Phase 1: GPIO-Status-Übertragung - Implementierungsplan

**Erstellt:** 2026-01-08
**Basis-Analyse:** `GPIO_SAFE_MODE_ANALYSE.md`
**Status:** BEREIT ZUR IMPLEMENTIERUNG
**Priorität:** KRITISCH - Blockiert alle weiteren Phasen
**Geschätzter Aufwand:** 4-6 Stunden

---

## 1. Executive Summary

### 1.1 Ziel dieser Phase

Der ESP32 hat ein vollständiges GPIO-Management-System, aber diese Information verlässt den ESP nicht. Phase 1 etabliert die **Datenbrücke** zwischen ESP32 und Server.

```
VORHER:                              NACHHER:
┌─────────┐     ┌─────────┐         ┌─────────┐     ┌─────────┐
│  ESP32  │     │ Server  │         │  ESP32  │────▶│ Server  │
│ GPIO:4  │  X  │  ???    │         │ GPIO:4  │     │ GPIO:4  │
│ GPIO:5  │     │  ???    │         │ GPIO:5  │     │ GPIO:5  │
└─────────┘     └─────────┘         └─────────┘     └─────────┘
   weiß           weiß                 weiß           weiß
   alles          nichts               alles          alles
```

### 1.2 Scope

| In Scope | Out of Scope |
|----------|--------------|
| ESP32 GPIOManager erweitern | Frontend-Änderungen (Phase 3) |
| Heartbeat-Payload erweitern | GPIO-Validierung im Server (Phase 2) |
| Server Heartbeat-Handler anpassen | Neue API-Endpoints (Phase 3) |
| DB-Speicherung GPIO-Status | Cross-Component GPIO-Check (Phase 2) |
| MQTT-Protokoll dokumentieren | GPIO-Picker UI (Phase 3) |

### 1.3 Änderungsübersicht

| Komponente | Datei | Änderungstyp |
|------------|-------|--------------|
| ESP32 | `gpio_manager.h` | Neue Methoden-Deklarationen |
| ESP32 | `gpio_manager.cpp` | Neue Methoden-Implementierung |
| ESP32 | `mqtt_client.cpp` | Heartbeat-Payload erweitern |
| Server | `heartbeat_handler.py` | Payload-Model + Handler-Logik |
| Server | `esp_repo.py` | Metadata-Update-Methode |
| Server | `esp.py` (Model) | device_metadata Feld prüfen |
| Docs | `Mqtt_Protocoll.md` | Payload-Dokumentation |

---

## 2. Technische Spezifikation

### 2.1 Neues Payload-Format (Heartbeat)

**Aktuelles Format:**
```json
{
  "esp_id": "ESP_12AB34CD",
  "zone_id": "zone_1",
  "master_zone_id": "master",
  "zone_assigned": true,
  "ts": 1704722400,
  "uptime": 12345,
  "heap_free": 123456,
  "wifi_rssi": -65,
  "sensor_count": 3,
  "actuator_count": 2
}
```

**Erweitertes Format (Phase 1):**
```json
{
  "esp_id": "ESP_12AB34CD",
  "zone_id": "zone_1",
  "master_zone_id": "master",
  "zone_assigned": true,
  "ts": 1704722400,
  "uptime": 12345,
  "heap_free": 123456,
  "wifi_rssi": -65,
  "sensor_count": 3,
  "actuator_count": 2,
  "gpio_status": [
    {"gpio": 4, "owner": "sensor", "component": "DS18B20", "safe": false},
    {"gpio": 21, "owner": "system", "component": "I2C_SDA", "safe": false},
    {"gpio": 22, "owner": "system", "component": "I2C_SCL", "safe": false},
    {"gpio": 5, "owner": "actuator", "component": "pump_1", "safe": false}
  ],
  "gpio_reserved_count": 4
}
```

### 2.2 GPIO-Status-Item Schema

| Feld | Typ | Beschreibung | Beispiel |
|------|-----|--------------|----------|
| `gpio` | int | GPIO-Pin-Nummer | `4`, `21`, `5` |
| `owner` | string | Besitzer-Kategorie | `"sensor"`, `"actuator"`, `"system"` |
| `component` | string | Komponenten-Name | `"DS18B20"`, `"pump_1"`, `"I2C_SDA"` |
| `safe` | bool | Safe-Mode-Status | `false` (aktiv genutzt) |

**Wichtig:** `gpio_status` enthält NUR Pins die NICHT in Safe-Mode sind (also aktiv reserviert). Pins in Safe-Mode werden nicht gelistet.

### 2.3 Server-Speicherung

```
ESPDevice.device_metadata = {
  "gpio": {
    "gpio_status": [...],
    "gpio_updated_at": "2026-01-08T14:30:00Z"
  },
  // andere metadata...
}
```

---

## 3. Implementierung ESP32

### 3.1 gpio_manager.h - Neue Deklarationen

**Datei:** `El Trabajante/src/drivers/gpio_manager.h`
**Position:** Nach Zeile ~85 (nach `getSubzonePins` Deklaration)

```cpp
// ============================================
// GPIO STATUS REPORTING (Phase 1)
// ============================================

/**
 * @brief Returns list of all reserved (non-safe-mode) pins with details
 * @return Vector of GpioPinInfo for all reserved pins
 *
 * Used by MQTTClient to include GPIO status in heartbeat payload.
 * Only returns pins that are NOT in safe mode (i.e., actively used).
 *
 * @example
 * std::vector<GpioPinInfo> reserved = gpioManager.getReservedPinsList();
 * for (const auto& pin : reserved) {
 *     Serial.printf("GPIO %d: %s (%s)\n", pin.pin, pin.owner, pin.component_name);
 * }
 */
std::vector<GpioPinInfo> getReservedPinsList() const;

/**
 * @brief Returns total count of reserved pins
 * @return Number of pins not in safe mode
 *
 * Quick check without building full list.
 * Useful for JSON payload size estimation.
 */
uint8_t getReservedPinCount() const;
```

### 3.2 gpio_manager.cpp - Implementierung

**Datei:** `El Trabajante/src/drivers/gpio_manager.cpp`
**Position:** Am Ende der Datei (vor letzter schließender Klammer)

```cpp
// ============================================
// GPIO STATUS REPORTING (Phase 1)
// ============================================

std::vector<GpioPinInfo> GPIOManager::getReservedPinsList() const {
    std::vector<GpioPinInfo> reserved;
    reserved.reserve(16);  // Pre-allocate für Performance

    try {
        for (const auto& pair : pin_info_) {
            // Nur Pins die NICHT in Safe-Mode sind (also aktiv genutzt)
            if (!pair.second.in_safe_mode) {
                reserved.push_back(pair.second);
            }
        }
    } catch (...) {
        LOG_ERROR("GPIOManager: Failed to build reserved pins list");
        // Leere Liste zurückgeben statt crashen
        return std::vector<GpioPinInfo>();
    }

    LOG_DEBUG("GPIOManager: " + String(reserved.size()) + " reserved pins");
    return reserved;
}

uint8_t GPIOManager::getReservedPinCount() const {
    uint8_t count = 0;

    for (const auto& pair : pin_info_) {
        if (!pair.second.in_safe_mode) {
            count++;
        }
    }

    return count;
}
```

### 3.3 mqtt_client.cpp - Heartbeat erweitern

**Datei:** `El Trabajante/src/services/communication/mqtt_client.cpp`
**Position:** In `publishHeartbeat()` Funktion, nach den bestehenden JSON-Feldern

**Schritt 1:** Include hinzufügen (am Anfang der Datei, falls nicht vorhanden)
```cpp
#include "drivers/gpio_manager.h"
```

**Schritt 2:** In `publishHeartbeat()` nach bestehenden Feldern einfügen

```cpp
// ══════════════════════════════════════════════════════════════════
// GPIO STATUS (Phase 1)
// ══════════════════════════════════════════════════════════════════

// GPIO Manager Referenz holen
GPIOManager& gpioManager = GPIOManager::getInstance();

// GPIO Status Array aufbauen
json += ",\"gpio_status\":[";

std::vector<GpioPinInfo> reservedPins = gpioManager.getReservedPinsList();
bool first = true;

for (const auto& pin : reservedPins) {
    if (!first) json += ",";
    first = false;

    json += "{";
    json += "\"gpio\":" + String(pin.pin) + ",";
    json += "\"owner\":\"" + String(pin.owner) + "\",";
    json += "\"component\":\"" + String(pin.component_name) + "\",";
    json += "\"safe\":" + String(pin.in_safe_mode ? "true" : "false");
    json += "}";
}

json += "]";

// Gesamtzahl für schnellen Check (ohne Array-Parse)
json += ",\"gpio_reserved_count\":" + String(reservedPins.size());

// ══════════════════════════════════════════════════════════════════
```

### 3.4 Speicherabschätzung

| Komponente | Größe | Anmerkung |
|------------|-------|-----------|
| Pro GPIO-Item | ~80 Bytes | `{"gpio":XX,"owner":"YYYY","component":"ZZZZZZZZ","safe":false}` |
| Max 16 Pins | ~1.3 KB | Worst-Case für ESP32_DEV |
| Typisch 4-6 Pins | ~400-500 Bytes | Normaler Betrieb |
| Heartbeat Overhead | <5% | Minimal im Vergleich zu Gesamtgröße |

---

## 4. Implementierung Server

### 4.1 heartbeat_handler.py - Pydantic Models

**Datei:** `El Servador/god_kaiser_server/src/mqtt/handlers/heartbeat_handler.py`
**Position:** Am Anfang der Datei (bei Imports/Models)

```python
from typing import List, Optional
from datetime import datetime
from pydantic import BaseModel, Field, validator


class GpioStatusItem(BaseModel):
    """
    Single GPIO pin status from ESP32.

    Represents the current reservation state of a GPIO pin as reported
    by the ESP32's GPIOManager. This is the SOURCE OF TRUTH for which
    GPIOs are actually in use on the physical device.
    """
    gpio: int = Field(..., ge=0, le=48, description="GPIO pin number")
    owner: str = Field(..., description="Owner category: sensor, actuator, system")
    component: str = Field(..., description="Component name, e.g., DS18B20, pump_1")
    safe: bool = Field(..., description="True if in safe mode (not actively used)")

    @validator('owner')
    def validate_owner(cls, v):
        allowed = {'sensor', 'actuator', 'system'}
        if v not in allowed:
            raise ValueError(f"owner must be one of {allowed}")
        return v


class HeartbeatPayload(BaseModel):
    """
    Extended heartbeat payload with GPIO status (Phase 1).

    Backwards compatible: gpio_status defaults to empty list for
    older ESP firmware that doesn't send GPIO information.
    """
    esp_id: str = Field(..., description="ESP device ID, e.g., ESP_12AB34CD")
    zone_id: Optional[str] = Field(None, description="Assigned zone ID")
    master_zone_id: Optional[str] = Field(None, description="Master zone ID")
    zone_assigned: bool = Field(False, description="Whether zone is assigned")
    ts: int = Field(..., description="Unix timestamp in seconds")
    uptime: int = Field(..., ge=0, description="Uptime in seconds")
    heap_free: int = Field(..., ge=0, description="Free heap in bytes")
    wifi_rssi: int = Field(..., description="WiFi signal strength in dBm")
    sensor_count: int = Field(0, ge=0, description="Number of active sensors")
    actuator_count: int = Field(0, ge=0, description="Number of active actuators")

    # Phase 1: GPIO Status
    gpio_status: List[GpioStatusItem] = Field(
        default_factory=list,
        description="List of reserved GPIO pins"
    )
    gpio_reserved_count: int = Field(
        0,
        ge=0,
        description="Total count of reserved pins"
    )

    @validator('gpio_reserved_count', always=True)
    def validate_count_matches(cls, v, values):
        """Warn if count doesn't match array length (data integrity check)."""
        gpio_status = values.get('gpio_status', [])
        if v != len(gpio_status):
            # Log warning but don't reject - ESP array is truth
            import logging
            logging.getLogger(__name__).warning(
                f"gpio_reserved_count ({v}) != len(gpio_status) ({len(gpio_status)})"
            )
        return v
```

### 4.2 heartbeat_handler.py - Handler erweitern

**Position:** In `handle_heartbeat()` Methode

```python
async def handle_heartbeat(self, topic: str, payload: dict) -> None:
    """
    Handle ESP heartbeat message with GPIO status.

    Flow:
    1. Validate payload with Pydantic
    2. Find/update ESP device
    3. Update health status (existing)
    4. Update GPIO status (NEW - Phase 1)
    5. Broadcast via WebSocket
    """
    try:
        # ═══════════════════════════════════════════════════════════
        # STEP 1: Payload validieren
        # ═══════════════════════════════════════════════════════════
        try:
            heartbeat = HeartbeatPayload(**payload)
        except ValidationError as e:
            # Backward compatibility: versuche ohne gpio_status
            logger.warning(f"Heartbeat validation failed, trying without gpio: {e}")
            payload_compat = {k: v for k, v in payload.items()
                            if k not in ('gpio_status', 'gpio_reserved_count')}
            heartbeat = HeartbeatPayload(**payload_compat)

        # ═══════════════════════════════════════════════════════════
        # STEP 2: ESP Device finden
        # ═══════════════════════════════════════════════════════════
        esp = await self.esp_repo.get_by_device_id(heartbeat.esp_id)
        if not esp:
            logger.warning(
                f"Heartbeat from unknown ESP: {heartbeat.esp_id}. "
                f"Device must be registered first via POST /api/v1/esp/register"
            )
            return

        # ═══════════════════════════════════════════════════════════
        # STEP 3: Health Status aktualisieren (bestehende Logik)
        # ═══════════════════════════════════════════════════════════
        await self.esp_repo.update_health_status(
            esp_id=esp.id,
            heap_free=heartbeat.heap_free,
            wifi_rssi=heartbeat.wifi_rssi,
            uptime=heartbeat.uptime,
            sensor_count=heartbeat.sensor_count,
            actuator_count=heartbeat.actuator_count,
            last_heartbeat=datetime.utcnow()
        )

        # ═══════════════════════════════════════════════════════════
        # STEP 4: GPIO Status aktualisieren (NEU - Phase 1)
        # ═══════════════════════════════════════════════════════════
        if heartbeat.gpio_status:
            await self._update_gpio_status(
                esp_id=esp.id,
                device_id=heartbeat.esp_id,
                gpio_status=heartbeat.gpio_status
            )
            logger.debug(
                f"GPIO status updated for {heartbeat.esp_id}: "
                f"{len(heartbeat.gpio_status)} reserved pins"
            )

        # ═══════════════════════════════════════════════════════════
        # STEP 5: WebSocket Broadcast
        # ═══════════════════════════════════════════════════════════
        await self.ws_manager.broadcast("esp_health", {
            "esp_id": heartbeat.esp_id,
            "status": "online",
            "uptime": heartbeat.uptime,
            "heap_free": heartbeat.heap_free,
            "wifi_rssi": heartbeat.wifi_rssi,
            "sensor_count": heartbeat.sensor_count,
            "actuator_count": heartbeat.actuator_count,
            "timestamp": heartbeat.ts,
            # NEU - Phase 1:
            "gpio_status": [s.dict() for s in heartbeat.gpio_status],
            "gpio_reserved_count": len(heartbeat.gpio_status)
        })

        logger.debug(f"Heartbeat processed for {heartbeat.esp_id}")

    except ValidationError as e:
        logger.error(f"Invalid heartbeat payload: {e}")
    except Exception as e:
        logger.exception(f"Error handling heartbeat: {e}")


async def _update_gpio_status(
    self,
    esp_id: int,
    device_id: str,
    gpio_status: List[GpioStatusItem]
) -> None:
    """
    Update GPIO status for ESP device.

    Stores the current GPIO reservation state reported by the ESP.
    This is the SOURCE OF TRUTH for which GPIOs are actually in use.

    Args:
        esp_id: Database ID of ESP device
        device_id: ESP device ID string (for logging)
        gpio_status: List of GPIO status items from heartbeat
    """
    gpio_data = {
        "gpio_status": [s.dict() for s in gpio_status],
        "gpio_updated_at": datetime.utcnow().isoformat(),
        "gpio_count": len(gpio_status)
    }

    await self.esp_repo.update_device_metadata(
        esp_id=esp_id,
        metadata_key="gpio",
        metadata_value=gpio_data
    )
```

### 4.3 esp_repo.py - Metadata-Update-Methode

**Datei:** `El Servador/god_kaiser_server/src/db/repositories/esp_repo.py`
**Position:** Als neue Methode in `ESPRepository` Klasse

```python
async def update_device_metadata(
    self,
    esp_id: int,
    metadata_key: str,
    metadata_value: dict
) -> None:
    """
    Update a specific metadata key for an ESP device.

    The device_metadata column is a JSON field that stores
    various runtime information including GPIO status.

    Args:
        esp_id: Database ID of the ESP device
        metadata_key: Key to update (e.g., "gpio", "diagnostics")
        metadata_value: Value to store (will be JSON serialized)

    Raises:
        ValueError: If ESP device not found

    Example:
        await esp_repo.update_device_metadata(
            esp_id=1,
            metadata_key="gpio",
            metadata_value={
                "gpio_status": [...],
                "gpio_updated_at": "2026-01-08T14:30:00Z"
            }
        )
    """
    async with self.session_factory() as session:
        esp = await session.get(ESPDevice, esp_id)
        if not esp:
            raise ValueError(f"ESP not found: {esp_id}")

        # Merge mit existierenden Metadata (nicht überschreiben!)
        current_metadata = esp.device_metadata or {}
        current_metadata[metadata_key] = metadata_value

        esp.device_metadata = current_metadata
        esp.updated_at = datetime.utcnow()

        await session.commit()

        logger.debug(
            f"Updated device_metadata[{metadata_key}] for ESP {esp_id}"
        )
```

### 4.4 esp.py (Model) - device_metadata Feld

**Datei:** `El Servador/god_kaiser_server/src/db/models/esp.py`
**Aktion:** Prüfen ob `device_metadata` JSON-Feld existiert

```python
from sqlalchemy import Column, Integer, String, Boolean, DateTime, JSON, Text
from sqlalchemy.orm import relationship
from datetime import datetime

from ..base import Base


class ESPDevice(Base):
    """
    ESP32 Device Registry.

    Stores device information, health status, and runtime metadata.
    """
    __tablename__ = "esp_devices"

    id = Column(Integer, primary_key=True, index=True)
    device_id = Column(String(50), unique=True, nullable=False, index=True)
    name = Column(String(100), nullable=True)

    # Zone Assignment
    zone_id = Column(String(50), nullable=True, index=True)
    master_zone_id = Column(String(50), nullable=True)
    zone_assigned = Column(Boolean, default=False)

    # Hardware Info
    hardware_type = Column(String(50), default="ESP32_WROOM")
    firmware_version = Column(String(20), nullable=True)

    # Health Status
    is_online = Column(Boolean, default=False)
    last_heartbeat = Column(DateTime, nullable=True)
    heap_free = Column(Integer, nullable=True)
    wifi_rssi = Column(Integer, nullable=True)
    uptime = Column(Integer, nullable=True)

    # Counts
    sensor_count = Column(Integer, default=0)
    actuator_count = Column(Integer, default=0)

    # ═══════════════════════════════════════════════════════════════
    # RUNTIME METADATA (JSON) - Für GPIO-Status und andere Daten
    # ═══════════════════════════════════════════════════════════════
    device_metadata = Column(
        JSON,
        nullable=True,
        default=dict,
        comment="Runtime metadata: gpio_status, diagnostics, etc."
    )

    # Mock Device Flag
    is_mock = Column(Boolean, default=False)

    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relationships
    sensors = relationship("SensorConfig", back_populates="esp", cascade="all, delete-orphan")
    actuators = relationship("ActuatorConfig", back_populates="esp", cascade="all, delete-orphan")
```

### 4.5 Migration (falls device_metadata fehlt)

**Befehl:**
```bash
cd "El Servador/god_kaiser_server"
poetry run alembic revision --autogenerate -m "Add device_metadata to esp_devices"
poetry run alembic upgrade head
```

**Migrations-Datei (auto-generiert, zur Referenz):**
```python
"""Add device_metadata to esp_devices

Revision ID: xxxx
Revises: yyyy
Create Date: 2026-01-08
"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

def upgrade():
    op.add_column(
        'esp_devices',
        sa.Column('device_metadata', sa.JSON(), nullable=True, default={})
    )

def downgrade():
    op.drop_column('esp_devices', 'device_metadata')
```

---

## 5. MQTT-Protokoll-Dokumentation

### 5.1 Update für Mqtt_Protocoll.md

**Datei:** `El Trabajante/docs/Mqtt_Protocoll.md`
**Position:** Bei der Heartbeat-Payload-Dokumentation

```markdown
### System-Heartbeat (ERWEITERT - Phase 1)

**Topic:** `kaiser/{kaiser_id}/esp/{esp_id}/system/heartbeat`
**QoS:** 1
**Retain:** false
**Interval:** 60 Sekunden (konfigurierbar via `HEARTBEAT_INTERVAL_MS`)

#### Payload-Schema

```json
{
    "esp_id": "ESP_12AB34CD",
    "zone_id": "zone_1",
    "master_zone_id": "master",
    "zone_assigned": true,
    "ts": 1704722400,
    "uptime": 12345,
    "heap_free": 123456,
    "wifi_rssi": -65,
    "sensor_count": 3,
    "actuator_count": 2,
    "gpio_status": [
        {
            "gpio": 4,
            "owner": "sensor",
            "component": "DS18B20",
            "safe": false
        },
        {
            "gpio": 21,
            "owner": "system",
            "component": "I2C_SDA",
            "safe": false
        }
    ],
    "gpio_reserved_count": 2
}
```

#### Feld-Beschreibung

| Feld | Typ | Required | Beschreibung |
|------|-----|----------|--------------|
| `esp_id` | string | Ja | ESP Device ID (Format: `ESP_XXXXXXXX`) |
| `zone_id` | string | Nein | Zugewiesene Zone ID |
| `master_zone_id` | string | Nein | Master Zone ID |
| `zone_assigned` | bool | Ja | Zone-Zuweisung aktiv |
| `ts` | int | Ja | Unix Timestamp (Sekunden) |
| `uptime` | int | Ja | Laufzeit in Sekunden |
| `heap_free` | int | Ja | Freier Heap in Bytes |
| `wifi_rssi` | int | Ja | WiFi Signalstärke (dBm) |
| `sensor_count` | int | Ja | Anzahl aktiver Sensoren |
| `actuator_count` | int | Ja | Anzahl aktiver Aktoren |
| `gpio_status` | array | Nein | Liste reservierter GPIOs (Phase 1) |
| `gpio_reserved_count` | int | Nein | Anzahl reservierter GPIOs (Phase 1) |

#### gpio_status Array Item

| Feld | Typ | Beschreibung | Erlaubte Werte |
|------|-----|--------------|----------------|
| `gpio` | int | GPIO-Pin-Nummer | 0-48 (board-abhängig) |
| `owner` | string | Besitzer-Kategorie | `"sensor"`, `"actuator"`, `"system"` |
| `component` | string | Komponenten-Name | z.B. `"DS18B20"`, `"pump_1"`, `"I2C_SDA"` |
| `safe` | bool | Safe-Mode-Status | `false` = aktiv genutzt |

#### Hinweise

1. **gpio_status enthält nur aktive Pins:** Pins in Safe-Mode werden NICHT gelistet
2. **Backward Compatibility:** Server akzeptiert Heartbeats ohne gpio_status (ältere Firmware)
3. **gpio_reserved_count:** Redundant zum Array, ermöglicht schnellen Check ohne Parse
4. **Owner-Kategorien:**
   - `sensor`: Pin von SensorManager reserviert
   - `actuator`: Pin von ActuatorManager reserviert
   - `system`: Pin von System reserviert (I2C, SPI, etc.)

#### Beispiel: Minimaler Heartbeat (ohne GPIOs)

```json
{
    "esp_id": "ESP_12AB34CD",
    "zone_assigned": false,
    "ts": 1704722400,
    "uptime": 100,
    "heap_free": 200000,
    "wifi_rssi": -50,
    "sensor_count": 0,
    "actuator_count": 0
}
```

#### Beispiel: Voller Heartbeat (mit GPIOs)

```json
{
    "esp_id": "ESP_12AB34CD",
    "zone_id": "greenhouse_north",
    "master_zone_id": "main",
    "zone_assigned": true,
    "ts": 1704722400,
    "uptime": 86400,
    "heap_free": 150000,
    "wifi_rssi": -65,
    "sensor_count": 4,
    "actuator_count": 2,
    "gpio_status": [
        {"gpio": 4, "owner": "sensor", "component": "DS18B20", "safe": false},
        {"gpio": 5, "owner": "sensor", "component": "SHT31", "safe": false},
        {"gpio": 14, "owner": "actuator", "component": "pump_main", "safe": false},
        {"gpio": 15, "owner": "actuator", "component": "valve_1", "safe": false},
        {"gpio": 21, "owner": "system", "component": "I2C_SDA", "safe": false},
        {"gpio": 22, "owner": "system", "component": "I2C_SCL", "safe": false}
    ],
    "gpio_reserved_count": 6
}
```
```

---

## 6. Verifizierungs-Checkliste

### 6.1 ESP32 Build-Test

```bash
cd "El Trabajante"
~/.platformio/penv/Scripts/platformio.exe run -e esp32_dev
```

**Erwartetes Ergebnis:**
- [ ] Kompiliert ohne Errors
- [ ] Keine neuen Warnings (oder erklärbar)
- [ ] Binary-Größe nicht signifikant gestiegen (< 2KB)

### 6.2 ESP32 Runtime-Test

**Serial Monitor:**
```bash
cd "El Trabajante"
~/.platformio/penv/Scripts/platformio.exe device monitor
```

**Erwartete Ausgabe:**
```
[INFO] GPIO 21 reserved by system for I2C_SDA
[INFO] GPIO 22 reserved by system for I2C_SCL
[INFO] GPIO 4 reserved by sensor for DS18B20
...
[DEBUG] GPIOManager: 4 reserved pins
[INFO] Heartbeat published to kaiser/god/esp/ESP_XXXXXXXX/system/heartbeat
```

**MQTT Subscriber (separates Terminal):**
```bash
mosquitto_sub -h localhost -t "kaiser/god/esp/+/system/heartbeat" -v
```

- [ ] Heartbeat enthält `gpio_status` Array
- [ ] Array enthält alle reservierten Pins
- [ ] System-Pins (I2C) sind enthalten
- [ ] `gpio_reserved_count` stimmt mit Array-Länge

### 6.3 Server Unit-Tests

**Datei:** `El Servador/god_kaiser_server/tests/unit/test_heartbeat_payload.py`

```python
import pytest
from pydantic import ValidationError
from src.mqtt.handlers.heartbeat_handler import (
    HeartbeatPayload,
    GpioStatusItem
)


class TestGpioStatusItem:
    """Tests for GpioStatusItem model."""

    def test_valid_gpio_status(self):
        """Test valid GPIO status item."""
        item = GpioStatusItem(
            gpio=4,
            owner="sensor",
            component="DS18B20",
            safe=False
        )
        assert item.gpio == 4
        assert item.owner == "sensor"
        assert item.component == "DS18B20"
        assert item.safe is False

    def test_invalid_owner(self):
        """Test that invalid owner raises ValidationError."""
        with pytest.raises(ValidationError):
            GpioStatusItem(
                gpio=4,
                owner="invalid",
                component="test",
                safe=False
            )

    def test_gpio_range(self):
        """Test GPIO pin range validation."""
        # Valid
        item = GpioStatusItem(gpio=0, owner="sensor", component="test", safe=False)
        assert item.gpio == 0

        item = GpioStatusItem(gpio=48, owner="sensor", component="test", safe=False)
        assert item.gpio == 48

        # Invalid
        with pytest.raises(ValidationError):
            GpioStatusItem(gpio=-1, owner="sensor", component="test", safe=False)

        with pytest.raises(ValidationError):
            GpioStatusItem(gpio=49, owner="sensor", component="test", safe=False)


class TestHeartbeatPayload:
    """Tests for HeartbeatPayload model."""

    def test_minimal_payload(self):
        """Test heartbeat without GPIO status (backward compat)."""
        payload = {
            "esp_id": "ESP_TEST",
            "ts": 1704722400,
            "uptime": 100,
            "heap_free": 100000,
            "wifi_rssi": -60,
        }

        heartbeat = HeartbeatPayload(**payload)

        assert heartbeat.esp_id == "ESP_TEST"
        assert heartbeat.gpio_status == []
        assert heartbeat.gpio_reserved_count == 0

    def test_full_payload_with_gpio(self):
        """Test heartbeat with GPIO status."""
        payload = {
            "esp_id": "ESP_TEST",
            "zone_id": "zone_1",
            "zone_assigned": True,
            "ts": 1704722400,
            "uptime": 100,
            "heap_free": 100000,
            "wifi_rssi": -60,
            "sensor_count": 2,
            "actuator_count": 1,
            "gpio_status": [
                {"gpio": 4, "owner": "sensor", "component": "DS18B20", "safe": False},
                {"gpio": 5, "owner": "actuator", "component": "pump_1", "safe": False}
            ],
            "gpio_reserved_count": 2
        }

        heartbeat = HeartbeatPayload(**payload)

        assert len(heartbeat.gpio_status) == 2
        assert heartbeat.gpio_status[0].gpio == 4
        assert heartbeat.gpio_status[0].owner == "sensor"
        assert heartbeat.gpio_reserved_count == 2

    def test_count_mismatch_warning(self, caplog):
        """Test that count mismatch logs warning but doesn't reject."""
        payload = {
            "esp_id": "ESP_TEST",
            "ts": 1704722400,
            "uptime": 100,
            "heap_free": 100000,
            "wifi_rssi": -60,
            "gpio_status": [
                {"gpio": 4, "owner": "sensor", "component": "test", "safe": False}
            ],
            "gpio_reserved_count": 5  # Wrong!
        }

        # Should not raise, but log warning
        heartbeat = HeartbeatPayload(**payload)
        assert len(heartbeat.gpio_status) == 1
        assert "gpio_reserved_count" in caplog.text
```

**Test ausführen:**
```bash
cd "El Servador/god_kaiser_server"
poetry run pytest tests/unit/test_heartbeat_payload.py -v
```

- [ ] Alle Tests bestanden
- [ ] Coverage für neue Code-Pfade

### 6.4 Server Integration-Tests

**Datei:** `El Servador/god_kaiser_server/tests/integration/test_heartbeat_gpio.py`

```python
import pytest
from unittest.mock import AsyncMock, MagicMock
from src.mqtt.handlers.heartbeat_handler import HeartbeatHandler


@pytest.fixture
def mock_handler():
    """Create HeartbeatHandler with mocked dependencies."""
    handler = HeartbeatHandler()
    handler.esp_repo = AsyncMock()
    handler.ws_manager = AsyncMock()
    return handler


@pytest.fixture
def sample_esp():
    """Create mock ESP device."""
    esp = MagicMock()
    esp.id = 1
    esp.device_id = "ESP_TEST123"
    esp.device_metadata = {}
    return esp


@pytest.mark.asyncio
async def test_heartbeat_updates_gpio_status(mock_handler, sample_esp):
    """Test that heartbeat handler updates GPIO status in DB."""
    mock_handler.esp_repo.get_by_device_id.return_value = sample_esp

    payload = {
        "esp_id": "ESP_TEST123",
        "ts": 1704722400,
        "uptime": 100,
        "heap_free": 100000,
        "wifi_rssi": -60,
        "gpio_status": [
            {"gpio": 4, "owner": "sensor", "component": "DS18B20", "safe": False}
        ],
        "gpio_reserved_count": 1
    }

    await mock_handler.handle_heartbeat("topic", payload)

    # Verify GPIO update was called
    mock_handler.esp_repo.update_device_metadata.assert_called_once()
    call_args = mock_handler.esp_repo.update_device_metadata.call_args
    assert call_args.kwargs['metadata_key'] == 'gpio'
    assert len(call_args.kwargs['metadata_value']['gpio_status']) == 1


@pytest.mark.asyncio
async def test_heartbeat_backward_compatible(mock_handler, sample_esp):
    """Test that old heartbeats without GPIO still work."""
    mock_handler.esp_repo.get_by_device_id.return_value = sample_esp

    # Old payload format (no gpio_status)
    payload = {
        "esp_id": "ESP_TEST123",
        "ts": 1704722400,
        "uptime": 100,
        "heap_free": 100000,
        "wifi_rssi": -60,
    }

    await mock_handler.handle_heartbeat("topic", payload)

    # Should not call GPIO update
    mock_handler.esp_repo.update_device_metadata.assert_not_called()

    # But should still process health update
    mock_handler.esp_repo.update_health_status.assert_called_once()
```

**Test ausführen:**
```bash
cd "El Servador/god_kaiser_server"
poetry run pytest tests/integration/test_heartbeat_gpio.py -v
```

- [ ] Integration-Tests bestanden
- [ ] Backward-Kompatibilität verifiziert

### 6.5 Datenbank-Verifizierung

**SQL Query (nach einigen Heartbeats):**
```sql
SELECT
    device_id,
    device_metadata->'gpio'->'gpio_status' as gpio_status,
    device_metadata->'gpio'->'gpio_updated_at' as updated_at,
    device_metadata->'gpio'->'gpio_count' as count
FROM esp_devices
WHERE device_id = 'ESP_XXXXXXXX';
```

**Erwartetes Ergebnis:**
```
device_id     | gpio_status                                    | updated_at              | count
--------------+------------------------------------------------+-------------------------+------
ESP_12AB34CD  | [{"gpio":4,"owner":"sensor","component":...}]  | 2026-01-08T14:30:00Z    | 4
```

- [ ] `device_metadata` enthält `gpio` Key
- [ ] `gpio_status` Array ist korrekt
- [ ] `gpio_updated_at` wird bei jedem Heartbeat aktualisiert
- [ ] `gpio_count` stimmt mit Array-Länge

---

## 7. Edge-Cases & Fehlerbehandlung

### 7.1 ESP32 Edge-Cases

| Situation | Erwartetes Verhalten | Test |
|-----------|---------------------|------|
| Keine Pins reserviert | `gpio_status: []`, `gpio_reserved_count: 0` | Boot ohne Config |
| Nur System-Pins (I2C) | Array enthält nur I2C-Pins (2) | Boot mit I2C-Sensor |
| Alle Safe-Pins belegt | Array mit 16 Einträgen (ESP32_DEV) | Stress-Test |
| Pin-Reservation fehlgeschlagen | Pin erscheint NICHT in gpio_status | GPIO-Konflikt |
| getReservedPinsList() Exception | Leeres Array, Error geloggt | Memory-Pressure |

### 7.2 Server Edge-Cases

| Situation | Erwartetes Verhalten | Test |
|-----------|---------------------|------|
| Alter ESP ohne gpio_status | Default: `[]`, kein GPIO-Update | Legacy-Firmware |
| Malformed gpio_status | Validation-Error loggen, trotzdem verarbeiten | Corrupt-Payload |
| ESP sendet widersprüchliche Daten | ESP ist Source of Truth, überschreiben | Config-Drift |
| Sehr großes Array (>50 Pins) | Warnung loggen, trotzdem speichern | Anomalie-Test |
| Unknown ESP | Warning loggen, Heartbeat ignorieren | Unregistered-Device |
| DB-Write fehlgeschlagen | Exception loggen, nächster Heartbeat retry | DB-Ausfall |

### 7.3 Fehlerbehandlung Code

**ESP32 (defensive):**
```cpp
std::vector<GpioPinInfo> GPIOManager::getReservedPinsList() const {
    std::vector<GpioPinInfo> reserved;

    try {
        reserved.reserve(16);  // Pre-allocate
        for (const auto& pair : pin_info_) {
            if (!pair.second.in_safe_mode) {
                reserved.push_back(pair.second);
            }
        }
    } catch (const std::exception& e) {
        LOG_ERROR("getReservedPinsList failed: " + String(e.what()));
        return std::vector<GpioPinInfo>();  // Leere Liste statt Crash
    } catch (...) {
        LOG_ERROR("getReservedPinsList: Unknown exception");
        return std::vector<GpioPinInfo>();
    }

    return reserved;
}
```

**Server (backward-kompatibel):**
```python
async def handle_heartbeat(self, topic: str, payload: dict):
    try:
        heartbeat = HeartbeatPayload(**payload)
    except ValidationError as e:
        # Fallback: Parse ohne neue Felder
        logger.warning(f"Heartbeat validation failed: {e}")

        payload_compat = {k: v for k, v in payload.items()
                        if k not in ('gpio_status', 'gpio_reserved_count')}

        try:
            heartbeat = HeartbeatPayload(**payload_compat)
            logger.info("Heartbeat parsed in compatibility mode")
        except ValidationError:
            logger.error(f"Cannot parse heartbeat even in compat mode")
            return

    # ... rest of handler
```

---

## 8. Rollback-Plan

Falls Phase 1 Probleme verursacht:

### 8.1 ESP32 Rollback

1. `git checkout HEAD~1 -- src/drivers/gpio_manager.h`
2. `git checkout HEAD~1 -- src/drivers/gpio_manager.cpp`
3. `git checkout HEAD~1 -- src/services/communication/mqtt_client.cpp`
4. Rebuild: `pio run -e esp32_dev`
5. Flash: `pio run -e esp32_dev -t upload`

### 8.2 Server Rollback

1. `git checkout HEAD~1 -- src/mqtt/handlers/heartbeat_handler.py`
2. `git checkout HEAD~1 -- src/db/repositories/esp_repo.py`
3. Server restart: `systemctl restart god-kaiser`

### 8.3 DB Rollback (falls Migration)

```bash
poetry run alembic downgrade -1
```

---

## 9. Nächste Phasen (Out of Scope)

| Phase | Beschreibung | Abhängigkeit |
|-------|--------------|--------------|
| Phase 2 | Cross-Component GPIO-Check im Server | Phase 1 |
| Phase 3 | Frontend GPIO-Picker Component | Phase 1 + 2 |
| Phase 4 | Config-Validation vor Push | Phase 1 + 2 |
| Phase 5 | Detailliertes Konflikt-Feedback | Phase 1 - 4 |

---

## 10. Anhang: Vollständige Code-Referenzen

| Datei | Zeilen | Beschreibung |
|-------|--------|--------------|
| `gpio_manager.h` | ~85 | Neue Methoden-Deklarationen |
| `gpio_manager.cpp` | Ende | Neue Methoden-Implementierung |
| `mqtt_client.cpp` | In publishHeartbeat() | GPIO-Array im Payload |
| `heartbeat_handler.py` | Anfang | Pydantic Models |
| `heartbeat_handler.py` | handle_heartbeat() | Handler-Erweiterung |
| `heartbeat_handler.py` | _update_gpio_status() | Neue Hilfsmethode |
| `esp_repo.py` | Neue Methode | update_device_metadata() |
| `esp.py` | Model | device_metadata Feld |
| `Mqtt_Protocoll.md` | Heartbeat-Section | Payload-Dokumentation |

---

## 11. Zusammenfassung

### Was wird implementiert:
1. **ESP32:** GPIOManager gibt reservierte Pins als Liste zurück
2. **ESP32:** Heartbeat enthält `gpio_status` Array
3. **Server:** Heartbeat-Handler parst und speichert GPIO-Status
4. **Server:** ESP Device Metadata enthält GPIO-Information
5. **Docs:** MQTT-Protokoll aktualisiert

### Was wird NICHT implementiert:
- Frontend-Änderungen
- GPIO-Validierung im Server
- Neue API-Endpoints
- Konflikt-Feedback-System

### Erfolgskriterien:
- [ ] ESP32 kompiliert ohne Errors
- [ ] Heartbeat enthält GPIO-Array
- [ ] Server speichert GPIO-Status in DB
- [ ] Backward-kompatibel mit alter Firmware
- [ ] Alle Tests bestanden
- [ ] Dokumentation aktualisiert

---

**Ende des Implementierungsplans**

*Bereit zur Implementierung nach Review mit Robin.*
