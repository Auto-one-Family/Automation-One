# DEV-BRIEFING 02: Logging-Infrastruktur

> **Ziel:** Menschenverständliche Logs (Server, MQTT, ESP-Errors, Debug) zentral im Frontend anzeigen
> **Priorität:** HOCH - Essentiell für Debugging und Monitoring
> **Geschätzter Aufwand:** 2-3 Entwicklertage

---

## 1. Problemstellung

### 1.1 Aktuelle Situation

Das System hat bereits grundlegende Logging-Komponenten:
- **Server-Logs:** Python `logging` in Dateien und Konsole ✅ VOLLSTÄNDIG
- **MQTT-Nachrichten:** MqttLogView zeigt WebSocket-Events ✅ VOLLSTÄNDIG
- **ESP-Logs:** Logger-Klasse existiert, aber **KEIN MQTT-Topic für Logs** ❌ LÜCKE

**Kritische Erkenntnisse aus Code-Analyse:**
- ❌ **ESP32 hat KEIN dediziertes Log-Topic** - Logs werden nur lokal gespeichert und über Serial ausgegeben
- ❌ **Server hat KEINEN log_handler.py** - Es gibt 11 Handler, aber keinen für ESP-Logs
- ❌ **WebSocket hat KEINEN `esp_log` Event-Type** - Nur 5 Typen definiert
- ❌ **AuditLog hat KEINEN `ESP_LOG` Event-Type** - 13 Event-Types, aber keinen für ESP-Logs
- ✅ **Logger-Klasse auf ESP32 existiert** - Circular Buffer mit 50 Einträgen
- ✅ **TopicBuilder ist erweiterbar** - Muster für neue Topics vorhanden

### 1.2 Gewünschter Zustand

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Frontend: Unified Log Center                     │
├─────────────────────────────────────────────────────────────────────┤
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌─────────┐ │
│  │ Server Logs  │  │  MQTT Logs   │  │  ESP Logs    │  │ Errors  │ │
│  │              │  │              │  │              │  │         │ │
│  │ - INFO       │  │ - sensor     │  │ - DEBUG      │  │ - 1xxx  │ │
│  │ - WARNING    │  │ - actuator   │  │ - INFO       │  │ - 2xxx  │ │
│  │ - ERROR      │  │ - heartbeat  │  │ - WARNING    │  │ - 3xxx  │ │
│  │ - DEBUG      │  │ - config     │  │ - ERROR      │  │ - 4xxx  │ │
│  └──────────────┘  └──────────────┘  └──────────────┘  └─────────┘ │
│                                                                     │
│  [Filter: ESP-ID] [Filter: Level] [Filter: Zeit] [Suche: ______]   │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 2. Systemverständnis (PFLICHTLEKTÜRE)

**Bevor du Code schreibst, lies diese Dokumentation:**

| Dokument | Pfad | Relevanz |
|----------|------|----------|
| **CLAUDE.md** | `.claude/CLAUDE.md` | Error-Codes (Section 5) |
| **CLAUDE_SERVER.md** | `.claude/CLAUDE_SERVER.md` | Server-Logging, MQTT-Handler |
| **Hierarchie.md** | `Hierarchie.md` | Kommunikationsflüsse |
| **MQTT-Protokoll** | `El Trabajante/docs/Mqtt_Protocoll.md` | Log-Topic-Struktur |
| **View-Summary** | `El Frontend/Docs/02-Individual-Views-Summary.md` | MqttLogView, LogViewerView |

---

## 3. Codebase-Analyse (VOLLSTÄNDIG VERIFIZIERT)

### 3.1 ESP32 Log-System

#### 3.1.1 Logger-Klasse (VOLLSTÄNDIG IMPLEMENTIERT)

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `logger.h` | `El Trabajante/src/utils/logger.h` | ~105 | ✅ Vollständig |
| `logger.cpp` | `El Trabajante/src/utils/logger.cpp` | ~195 | ✅ Vollständig |

**Log-Levels (logger.h:9-15):**
```cpp
enum LogLevel {
  LOG_DEBUG = 0,
  LOG_INFO = 1,
  LOG_WARNING = 2,
  LOG_ERROR = 3,
  LOG_CRITICAL = 4
};
```

**LogEntry-Struktur (logger.h:20-24):**
```cpp
struct LogEntry {
  unsigned long timestamp;      // millis() Timestamp
  LogLevel level;               // Log-Level Enum
  char message[128];            // Fixed-Size Buffer (kein Heap!)
};
```

**Wichtige Methoden:**

| Methode | Datei:Zeile | Beschreibung |
|---------|-------------|--------------|
| `getInstance()` | logger.cpp:11-14 | Singleton-Pattern |
| `begin()` | logger.cpp:32-39 | Initialisierung (Startup-Message) |
| `log(LogLevel, const char*)` | logger.cpp:65-78 | Primäre Log-API |
| `debug/info/warning/error/critical()` | logger.cpp:80-98 | Level-spezifische Wrapper |
| `getLogs(LogLevel, size_t)` | logger.cpp:111-132 | Logs mit Filter abrufen |
| `clearLogs()` | logger.cpp:103-109 | Log-Buffer leeren |
| `getLogCount()` | logger.cpp:134-136 | Anzahl Logs |
| `getLogLevelString(LogLevel)` | logger.cpp:145-154 | Enum → String |
| `getLogLevelFromString(const char*)` | logger.cpp:156-163 | String → Enum |

**Interne Buffer-Verwaltung (logger.cpp:176-193):**
- **Buffer-Größe:** 50 Einträge (`MAX_LOG_ENTRIES`, logger.h:81)
- **Circular Buffer:** `log_buffer_index_` für Schreibposition
- **Timestamp-Quelle:** `millis()` (logger.cpp:181)
- **Message-Truncation:** `strncpy()` mit Null-Terminator (logger.cpp:183-184)

**Serial-Output-Format (logger.cpp:168-174):**
```
[  123456] [ERROR   ] GPIO pin already in use
```

**Convenience-Makros (logger.h:99-103):**
```cpp
#define LOG_DEBUG(msg)    logger.debug(msg)
#define LOG_INFO(msg)     logger.info(msg)
#define LOG_WARNING(msg)  logger.warning(msg)
#define LOG_ERROR(msg)    logger.error(msg)
#define LOG_CRITICAL(msg) logger.critical(msg)
```

**Globale Instanz:**
- logger.h:94: `extern Logger& logger;`
- logger.cpp:6: `Logger& logger = Logger::getInstance();`

#### 3.1.2 Error-Codes (VOLLSTÄNDIG IMPLEMENTIERT)

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `error_codes.h` | `El Trabajante/src/models/error_codes.h` | ~335 | ✅ Vollständig |

**Error-Code-Bereiche:**

| Bereich | Range | Kategorie | Beispiele |
|---------|-------|-----------|-----------|
| **HARDWARE** | 1000-1999 | GPIO, I2C, OneWire, PWM, Sensor, Actuator | `ERROR_GPIO_RESERVED (1001)` |
| **SERVICE** | 2000-2999 | NVS, Config, Logger, Storage, Subzone | `ERROR_NVS_INIT_FAILED (2001)` |
| **COMMUNICATION** | 3000-3999 | WiFi, MQTT, HTTP, Network, DNS | `ERROR_MQTT_CONNECT_FAILED (3011)` |
| **APPLICATION** | 4000-4999 | State, Operation, Command, Payload, Memory | `ERROR_STATE_INVALID (4001)` |

**Wichtige Hardware-Codes (error_codes.h:12-35):**
```cpp
#define ERROR_GPIO_RESERVED         1001   // Pin bereits reserviert
#define ERROR_GPIO_CONFLICT         1002   // GPIO-Konflikt
#define ERROR_GPIO_INIT_FAILED      1003   // Hardware-Init fehlgeschlagen
#define ERROR_I2C_INIT_FAILED       1010   // I2C-Initialisierung fehlgeschlagen
#define ERROR_I2C_DEVICE_NOT_FOUND  1011   // I2C-Gerät nicht gefunden
#define ERROR_SENSOR_READ_FAILED    1040   // Sensor antwortet nicht
#define ERROR_SENSOR_INIT_FAILED    1041   // Sensor-Init fehlgeschlagen
#define ERROR_ACTUATOR_SET_FAILED   1050   // Aktor-Command fehlgeschlagen
#define ERROR_ACTUATOR_INIT_FAILED  1051   // Aktor-Init fehlgeschlagen
```

**Subzone-spezifische Codes (error_codes.h:48-56):**
```cpp
#define ERROR_SUBZONE_INVALID_ID          2500
#define ERROR_SUBZONE_GPIO_CONFLICT       2501
#define ERROR_SUBZONE_PARENT_MISMATCH     2502
#define ERROR_SUBZONE_NOT_FOUND           2503
#define ERROR_SUBZONE_GPIO_INVALID        2504
#define ERROR_SUBZONE_SAFE_MODE_FAILED    2505
#define ERROR_SUBZONE_CONFIG_SAVE_FAILED  2506
```

**Kommunikations-Codes (error_codes.h:58-75):**
```cpp
#define ERROR_MQTT_INIT_FAILED      3010
#define ERROR_MQTT_CONNECT_FAILED   3011
#define ERROR_MQTT_PUBLISH_FAILED   3012
#define ERROR_MQTT_SUBSCRIBE_FAILED 3013
#define ERROR_MQTT_DISCONNECT       3014
#define ERROR_MQTT_BUFFER_FULL      3015
#define ERROR_MQTT_PAYLOAD_INVALID  3016
```

**Helper-Funktionen:**

| Funktion | Datei:Zeile | Beschreibung |
|----------|-------------|--------------|
| `getErrorDescription(uint16_t)` | error_codes.h:205-323 | Error-Code → lesbare Beschreibung |
| `getErrorCodeRange(uint16_t)` | error_codes.h:326-332 | Error-Code → Kategorie-String |

**ConfigErrorCode Enum (error_codes.h:139-149):**
```cpp
enum class ConfigErrorCode : uint8_t {
  NONE = 0,
  JSON_PARSE_ERROR,
  VALIDATION_FAILED,
  GPIO_CONFLICT,
  NVS_WRITE_FAILED,
  TYPE_MISMATCH,
  MISSING_FIELD,
  OUT_OF_RANGE,
  UNKNOWN_ERROR
};
```

#### 3.1.3 TopicBuilder (KEIN LOG-TOPIC VORHANDEN!)

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `topic_builder.h` | `El Trabajante/src/utils/topic_builder.h` | ~85 | ✅ Vollständig |
| `topic_builder.cpp` | `El Trabajante/src/utils/topic_builder.cpp` | ~200 | ⚠️ Kein Log-Topic |

**Statische Konfiguration (topic_builder.cpp:7-9):**
```cpp
char TopicBuilder::topic_buffer_[256];           // 256-Byte Buffer
char TopicBuilder::esp_id_[32] = "unknown";      // Default ESP-ID
char TopicBuilder::kaiser_id_[64] = "god";       // Default Kaiser-ID
```

**Vorhandene Topics (13 Patterns):**

| # | Methode | Topic-Format |
|---|---------|--------------|
| 1 | `buildSensorDataTopic(gpio)` | `kaiser/{kaiser}/esp/{esp}/sensor/{gpio}/data` |
| 2 | `buildSensorBatchTopic()` | `kaiser/{kaiser}/esp/{esp}/sensor/batch` |
| 3 | `buildActuatorCommandTopic(gpio)` | `kaiser/{kaiser}/esp/{esp}/actuator/{gpio}/command` |
| 4 | `buildActuatorStatusTopic(gpio)` | `kaiser/{kaiser}/esp/{esp}/actuator/{gpio}/status` |
| 5 | `buildActuatorResponseTopic(gpio)` | `kaiser/{kaiser}/esp/{esp}/actuator/{gpio}/response` |
| 6 | `buildActuatorAlertTopic(gpio)` | `kaiser/{kaiser}/esp/{esp}/actuator/{gpio}/alert` |
| 7 | `buildActuatorEmergencyTopic()` | `kaiser/{kaiser}/esp/{esp}/actuator/emergency` |
| 8 | `buildSystemHeartbeatTopic()` | `kaiser/{kaiser}/esp/{esp}/system/heartbeat` |
| 9 | `buildSystemCommandTopic()` | `kaiser/{kaiser}/esp/{esp}/system/command` |
| 10 | `buildSystemDiagnosticsTopic()` | `kaiser/{kaiser}/esp/{esp}/system/diagnostics` |
| 11 | `buildConfigTopic()` | `kaiser/{kaiser}/esp/{esp}/config` |
| 12 | `buildConfigResponseTopic()` | `kaiser/{kaiser}/esp/{esp}/config_response` |
| 13 | `buildBroadcastEmergencyTopic()` | `kaiser/broadcast/emergency` |

**Subzone-Topics (topic_builder.cpp:155-190):**
```cpp
buildSubzoneAssignTopic()   → kaiser/{kaiser}/esp/{esp}/subzone/assign
buildSubzoneRemoveTopic()   → kaiser/{kaiser}/esp/{esp}/subzone/remove
buildSubzoneAckTopic()      → kaiser/{kaiser}/esp/{esp}/subzone/ack
buildSubzoneStatusTopic()   → kaiser/{kaiser}/esp/{esp}/subzone/status
buildSubzoneSafeTopic()     → kaiser/{kaiser}/esp/{esp}/subzone/safe
```

**❌ FEHLT: `buildSystemLogTopic()` für ESP-Logs!**

**Erforderliche Änderung (topic_builder.h):**
```cpp
// NEU HINZUFÜGEN:
static const char* buildSystemLogTopic();
// Generiert: kaiser/{kaiser}/esp/{esp}/system/log
```

**Erforderliche Änderung (topic_builder.cpp):**
```cpp
const char* TopicBuilder::buildSystemLogTopic() {
  int written = snprintf(topic_buffer_, sizeof(topic_buffer_),
                         "kaiser/%s/esp/%s/system/log",
                         kaiser_id_, esp_id_);
  return validateTopicBuffer(written);
}
```

#### 3.1.4 MQTT-Client (KEIN LOG-PUBLISH!)

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `mqtt_client.h` | `El Trabajante/src/services/communication/mqtt_client.h` | ~145 | ✅ Vollständig |
| `mqtt_client.cpp` | `El Trabajante/src/services/communication/mqtt_client.cpp` | ~600 | ⚠️ Kein Log-Publish |

**Vorhandene Publish-Methoden:**

| Methode | Datei:Zeile | Beschreibung |
|---------|-------------|--------------|
| `publish(topic, payload, qos)` | mqtt_client.cpp:298-358 | Basis-Publish mit Circuit Breaker |
| `safePublish(topic, payload, qos, retries)` | mqtt_client.cpp:360-385 | Publish mit Retry |
| `publishHeartbeat()` | mqtt_client.cpp:435-466 | System-Heartbeat (60s Interval) |

**Heartbeat-Payload (mqtt_client.cpp:451-462):**
```json
{
  "esp_id": "ESP_12AB34CD",
  "zone_id": "zelt_1",
  "master_zone_id": "master",
  "zone_assigned": true,
  "ts": 1234567890,
  "uptime": 3600,
  "heap_free": 102400,
  "wifi_rssi": -45,
  "sensor_count": 3,
  "actuator_count": 2
}
```

**Circuit-Breaker-Konfiguration (mqtt_client.cpp:54-58):**
```cpp
circuit_breaker_("MQTT", 5, 30000, 10000)
// - Name: "MQTT"
// - Failure Threshold: 5 Fehler
// - Recovery Timeout: 30 Sekunden
// - Half-Open Test: 10 Sekunden
```

**Offline-Buffer (mqtt_client.h:95-97):**
```cpp
static const uint16_t MAX_OFFLINE_MESSAGES = 100;
MQTTMessage offline_buffer_[MAX_OFFLINE_MESSAGES];
uint16_t offline_buffer_count_;
```

**❌ FEHLT: `publishLog()` Methode für ESP-Logs!**

**Erforderliche Änderung (mqtt_client.h):**
```cpp
// NEU HINZUFÜGEN:
bool publishLog(LogLevel level, const char* module, const char* message,
                uint16_t error_code = 0, const char* details_json = nullptr);
```

**Erforderliche Änderung (mqtt_client.cpp):**
```cpp
bool MQTTClient::publishLog(LogLevel level, const char* module, const char* message,
                            uint16_t error_code, const char* details_json) {
    const char* topic = TopicBuilder::buildSystemLogTopic();

    String payload = "{";
    payload += "\"ts\":" + String((unsigned long)timeManager.getUnixTimestamp()) + ",";
    payload += "\"esp_id\":\"" + g_system_config.esp_id + "\",";
    payload += "\"level\":\"" + String(Logger::getLogLevelString(level)) + "\",";
    payload += "\"module\":\"" + String(module) + "\",";
    payload += "\"message\":\"" + String(message) + "\"";

    if (error_code > 0) {
        payload += ",\"error_code\":" + String(error_code);
        payload += ",\"error_description\":\"" + String(getErrorDescription(error_code)) + "\"";
    }

    if (details_json != nullptr) {
        payload += ",\"details\":" + String(details_json);
    }

    payload += "}";

    // QoS 0 für Logs (best-effort)
    return publish(topic, payload, 0);
}
```

---

### 3.2 Server Log-System

#### 3.2.1 Core Logging Config (VOLLSTÄNDIG IMPLEMENTIERT)

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `logging_config.py` | `El Servador/god_kaiser_server/src/core/logging_config.py` | ~140 | ✅ Vollständig |

**Klassen und Funktionen:**

| Komponente | Datei:Zeile | Beschreibung |
|------------|-------------|--------------|
| `JSONFormatter` | logging_config.py:15-46 | JSON-Format für strukturiertes Logging |
| `TextFormatter` | logging_config.py:49-62 | Text-Format für Konsole |
| `setup_logging()` | logging_config.py:65-126 | Haupt-Konfigurationsfunktion |
| `get_logger(name)` | logging_config.py:128-138 | Logger-Instanz abrufen |

**JSONFormatter.format() (logging_config.py:22-46):**
```python
log_record = {
    "timestamp": self.formatTime(record, self.datefmt),
    "level": record.levelname,
    "logger": record.name,
    "message": record.getMessage(),
    "module": record.module,
    "function": record.funcName,
    "line": record.lineno,
}
# Exception-Info und Extra-Fields werden hinzugefügt
```

**setup_logging() Ablauf (logging_config.py:65-126):**
1. Log-Verzeichnis erstellen (Zeile 76)
2. Root-Logger konfigurieren (Zeile 80-92)
3. `RotatingFileHandler` erstellen (Zeile 95-103)
4. `StreamHandler` für Konsole erstellen (Zeile 106-115)
5. Externe Libraries leiser stellen (Zeile 118-120)

**Konfiguration aus Settings:**
- `settings.logging.level` - Log-Level (DEBUG, INFO, WARNING, ERROR)
- `settings.logging.format` - Format (JSON oder text)
- `settings.logging.file_path` - Pfad zur Log-Datei
- `settings.logging.file_max_bytes` - Max Dateigröße vor Rotation
- `settings.logging.file_backup_count` - Anzahl Backup-Dateien

#### 3.2.2 MQTT-Handler (KEIN LOG-HANDLER!)

| Verzeichnis | Pfad | Status |
|-------------|------|--------|
| `handlers/` | `El Servador/god_kaiser_server/src/mqtt/handlers/` | ⚠️ Kein log_handler.py |

**Vorhandene Handler (11 + 1 Base):**

| Handler | Datei | MQTT-Topic |
|---------|-------|------------|
| `BaseMQTTHandler` | `base_handler.py` | (Abstract Base) |
| `SensorDataHandler` | `sensor_handler.py` | `kaiser/{id}/esp/+/sensor/+/data` |
| `ActuatorStatusHandler` | `actuator_handler.py` | `kaiser/{id}/esp/+/actuator/+/status` |
| `ActuatorResponseHandler` | `actuator_response_handler.py` | `kaiser/{id}/esp/+/actuator/+/response` |
| `ActuatorAlertHandler` | `actuator_alert_handler.py` | `kaiser/{id}/esp/+/actuator/+/alert` |
| `HeartbeatHandler` | `heartbeat_handler.py` | `kaiser/{id}/esp/+/system/heartbeat` |
| `ConfigHandler` | `config_handler.py` | `kaiser/{id}/esp/+/config_response` |
| `ZoneAckHandler` | `zone_ack_handler.py` | `kaiser/{id}/esp/+/zone/ack` |
| `SubzoneAckHandler` | `subzone_ack_handler.py` | `kaiser/{id}/esp/+/subzone/ack` |
| `DiscoveryHandler` | `discovery_handler.py` | `kaiser/{id}/discovery/esp32_nodes` (legacy) |
| `KaiserHandler` | `kaiser_handler.py` | (geplant) |

**❌ FEHLT: `log_handler.py` für ESP-Logs!**

#### 3.2.3 BaseMQTTHandler Pattern (VORLAGE FÜR LOG-HANDLER)

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `base_handler.py` | `El Servador/god_kaiser_server/src/mqtt/handlers/base_handler.py` | ~570 | ✅ Vollständig |

**Wichtige Datenklassen:**

**ValidationResult (base_handler.py:43-80):**
```python
@dataclass
class ValidationResult:
    valid: bool
    error_code: Optional[int] = None
    error_message: Optional[str] = None
    errors: List[FieldError] = field(default_factory=list)
    data: Any = None

    @classmethod
    def success(cls, data: Any = None) -> "ValidationResult": ...

    @classmethod
    def failure(cls, error_code: int, error_message: str) -> "ValidationResult": ...
```

**TopicParseResult (base_handler.py:83-115):**
```python
@dataclass
class TopicParseResult:
    valid: bool
    kaiser_id: Optional[str] = None
    esp_id: Optional[str] = None
    extra: Dict[str, Any] = field(default_factory=dict)
    error: Optional[str] = None
```

**Handler-Flow (base_handler.py:186-238):**
```python
async def handle(self, topic: str, payload: Dict[str, Any]) -> bool:
    # 1. Topic parsen (Zeile 200)
    topic_result = self.parse_topic(topic)

    # 2. Payload validieren (Zeile 206)
    validation = self.validate_payload(payload)

    # 3. ESP-Device nachschlagen (Zeile 218)
    esp_device = await self._get_esp_device(topic_result.esp_id)

    # 4. Message verarbeiten (Zeile 228)
    await self.process_message(topic_result, payload, esp_device)

    # Error-Isolation: Exceptions werden gefangen (Zeile 233)
```

**Abstrakte Methoden (MÜSSEN implementiert werden):**
- `parse_topic(topic: str) → TopicParseResult`
- `validate_payload(payload: Dict) → ValidationResult`
- `process_message(topic_result, payload, esp_device) → async void`

**Helper-Methoden für Validierung:**

| Methode | Datei:Zeile | Beschreibung |
|---------|-------------|--------------|
| `validate_required_fields()` | base_handler.py:291-321 | Pflichtfelder prüfen |
| `validate_field_type()` | base_handler.py:323-352 | Typ-Validierung |
| `validate_string_field()` | base_handler.py:354-393 | String-Validierung |
| `validate_numeric_field()` | base_handler.py:395-427 | Numerische Validierung |

**WebSocket-Broadcast-Methoden:**

| Methode | Datei:Zeile | Beschreibung |
|---------|-------------|--------------|
| `broadcast_event(type, data)` | base_handler.py:460-476 | Event an alle Clients |
| `broadcast_to_esp(esp_id, type, data)` | base_handler.py:478-493 | Event an ESP-spezifische Clients |

**Audit-Logging-Methoden:**

| Methode | Datei:Zeile | Beschreibung |
|---------|-------------|--------------|
| `_log_validation_error()` | base_handler.py:499-517 | Validation-Fehler loggen |
| `_log_processing_error()` | base_handler.py:519-536 | Processing-Fehler loggen |
| `log_device_event()` | base_handler.py:538-565 | Generische Event-Logs |

#### 3.2.4 MQTT-Subscriber (HANDLER-REGISTRIERUNG)

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `subscriber.py` | `El Servador/god_kaiser_server/src/mqtt/subscriber.py` | ~325 | ✅ Vollständig |

**Wichtige Methoden:**

| Methode | Datei:Zeile | Beschreibung |
|---------|-------------|--------------|
| `__init__()` | subscriber.py:34-68 | ThreadPoolExecutor erstellen |
| `register_handler(pattern, handler)` | subscriber.py:82-97 | Handler registrieren |
| `subscribe_all()` | subscriber.py:99-132 | Alle Patterns subscriben |
| `_route_message(topic, payload)` | subscriber.py:147-182 | Message zu Handler routen |
| `_execute_handler(handler, topic, payload)` | subscriber.py:184-245 | Handler ausführen (async/sync) |
| `get_stats()` | subscriber.py:287-305 | Performance-Metriken |

**Handler-Ausführung (subscriber.py:184-245):**
```python
def _execute_handler(self, handler, topic: str, payload: Dict) -> None:
    # Async Handler erkennen (Zeile 202)
    if asyncio.iscoroutinefunction(handler):
        # In MAIN Event-Loop schedulen (Zeile 214)
        future = asyncio.run_coroutine_threadsafe(
            handler(topic, payload),
            self._main_loop
        )
        # 30-Sekunden Timeout (Zeile 221)
        future.result(timeout=30)
```

**QoS-Bestimmung (subscriber.py:119-124):**
```python
def _get_qos_for_pattern(self, pattern: str) -> int:
    if "heartbeat" in pattern:
        return 0  # Best-effort
    elif "config" in pattern:
        return 2  # Exactly-once
    else:
        return 1  # At-least-once
```

#### 3.2.5 Handler-Registrierung in main.py

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `main.py` | `El Servador/god_kaiser_server/src/main.py` | ~350 | ⚠️ Kein Log-Handler |

**Aktuelle Handler-Registrierung (main.py:194-233):**
```python
# Subscriber erstellen (Zeile 181)
_subscriber_instance = Subscriber(max_workers=settings.mqtt.subscriber_max_workers)

# Handler registrieren (Zeile 194-233)
_subscriber_instance.register_handler(
    f"kaiser/{kaiser_id}/esp/+/sensor/+/data",
    sensor_handler.handle_sensor_data
)
_subscriber_instance.register_handler(
    f"kaiser/{kaiser_id}/esp/+/actuator/+/status",
    actuator_handler.handle_actuator_status
)
# ... weitere Handler ...
_subscriber_instance.register_handler(
    f"kaiser/{kaiser_id}/esp/+/subzone/ack",
    subzone_ack_handler.handle_subzone_ack
)
```

**❌ FEHLT: Log-Handler Registrierung:**
```python
# NEU HINZUFÜGEN nach Zeile 233:
_subscriber_instance.register_handler(
    f"kaiser/{kaiser_id}/esp/+/system/log",
    log_handler.handle_esp_log
)
```

#### 3.2.6 WebSocket Manager (KEIN ESP_LOG EVENT-TYPE!)

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `manager.py` | `El Servador/god_kaiser_server/src/websocket/manager.py` | ~310 | ⚠️ Kein esp_log Typ |

**Vorhandene Event-Types:**
- `sensor_data`
- `actuator_status`
- `esp_health`
- `system_event`
- `config_response`

**❌ FEHLT: `esp_log` Event-Type!**

**Wichtige Methoden:**

| Methode | Datei:Zeile | Beschreibung |
|---------|-------------|--------------|
| `get_instance()` | manager.py:41-53 | Singleton-Getter |
| `connect(websocket, client_id)` | manager.py:74-87 | Client verbinden |
| `subscribe(client_id, filters)` | manager.py:126-143 | Client-Filter setzen |
| `broadcast(type, data, esp_id)` | manager.py:174-235 | Event broadcasten |
| `broadcast_threadsafe(type, data, esp_id)` | manager.py:237-256 | Thread-safe Broadcast |

**Broadcast-Methode (manager.py:174-235):**
```python
async def broadcast(
    self,
    message_type: str,
    data: Dict[str, Any],
    esp_id: Optional[str] = None
) -> int:
    message = {
        "type": message_type,
        "timestamp": int(datetime.now(timezone.utc).timestamp()),
        "data": data
    }
    # Client-Filter anwenden (Zeile 194-216)
    # Rate-Limiting prüfen (Zeile 222)
    # Nachricht senden (Zeile 228)
```

**Rate-Limiting (manager.py:258-287):**
- Limit: 10 Messages/Sekunde pro Client
- Sliding-Window-Algorithmus mit `collections.deque`

#### 3.2.7 Database Models (KEIN ESP_LOG MODEL!)

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `audit_log.py` | `El Servador/god_kaiser_server/src/db/models/audit_log.py` | ~235 | ⚠️ Kein ESP_LOG Event |

**AuditLog Model (audit_log.py:26-178):**

| Spalte | Typ | Beschreibung |
|--------|-----|--------------|
| `id` | UUID | Primary Key |
| `event_type` | String(50) | Event-Klassifikation |
| `severity` | String(20) | info/warning/error/critical |
| `source_type` | String(30) | esp32/user/system/api/mqtt/scheduler |
| `source_id` | String(100) | z.B. esp_id |
| `status` | String(20) | success/failed/pending |
| `message` | Text | Lesbare Beschreibung |
| `details` | JSON | Event-spezifische Daten |
| `error_code` | String(50) | Error-Code falls vorhanden |
| `error_description` | Text | Error-Beschreibung |
| `ip_address` | String(45) | Für API/Web-Events |
| `correlation_id` | String(100) | Für Event-Tracing |
| `created_at` | DateTime | Timestamp |

**Vorhandene Event-Types (audit_log.py:182-211):**
```python
class AuditEventType:
    CONFIG_RESPONSE = "config_response"
    CONFIG_PUBLISHED = "config_published"
    CONFIG_FAILED = "config_failed"
    LOGIN_SUCCESS = "login_success"
    LOGIN_FAILED = "login_failed"
    LOGOUT = "logout"
    TOKEN_REVOKED = "token_revoked"
    PERMISSION_DENIED = "permission_denied"
    API_KEY_INVALID = "api_key_invalid"
    RATE_LIMIT_EXCEEDED = "rate_limit_exceeded"
    EMERGENCY_STOP = "emergency_stop"
    SERVICE_START = "service_start"
    SERVICE_STOP = "service_stop"
    DEVICE_REGISTERED = "device_registered"
    DEVICE_OFFLINE = "device_offline"
    MQTT_ERROR = "mqtt_error"
    DATABASE_ERROR = "database_error"
    VALIDATION_ERROR = "validation_error"
```

**❌ FEHLT: `ESP_LOG_MESSAGE = "esp_log_message"`**

**Severity-Konstanten (audit_log.py:214-220):**
```python
class AuditSeverity:
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"
```

**Source-Type-Konstanten (audit_log.py:223-231):**
```python
class AuditSourceType:
    ESP32 = "esp32"
    USER = "user"
    SYSTEM = "system"
    API = "api"
    MQTT = "mqtt"
    SCHEDULER = "scheduler"
```

#### 3.2.8 Audit Log Repository (KEINE ESP-LOG METHODE!)

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `audit_log_repo.py` | `El Servador/god_kaiser_server/src/db/repositories/audit_log_repo.py` | ~420 | ⚠️ Kein log_esp_message |

**Vorhandene Logging-Methoden:**

| Methode | Datei:Zeile | Beschreibung |
|---------|-------------|--------------|
| `log_config_response()` | audit_log_repo.py:54-103 | Config-Response loggen |
| `log_mqtt_error()` | audit_log_repo.py:106-133 | MQTT-Fehler loggen |
| `log_validation_error()` | audit_log_repo.py:136-165 | Validation-Fehler loggen |
| `log_emergency_stop()` | audit_log_repo.py:168-189 | Emergency-Stop loggen |
| `log_device_event()` | audit_log_repo.py:200-238 | Generische Device-Events |

**❌ FEHLT: `log_esp_message()` für ESP-Logs:**
```python
# NEU HINZUFÜGEN:
async def log_esp_message(
    self,
    esp_id: str,
    level: str,
    module: str,
    message: str,
    error_code: Optional[int] = None,
    details: Optional[Dict[str, Any]] = None
) -> AuditLog:
    """ESP32 Log-Nachricht speichern."""
    severity = self._map_esp_level_to_severity(level)

    return await self.create(
        event_type=AuditEventType.ESP_LOG_MESSAGE,
        severity=severity,
        source_type=AuditSourceType.ESP32,
        source_id=esp_id,
        status="success",
        message=message,
        details={
            "module": module,
            "log_level": level,
            **(details or {})
        },
        error_code=str(error_code) if error_code else None,
        error_description=self._get_error_description(error_code) if error_code else None
    )

def _map_esp_level_to_severity(self, level: str) -> str:
    mapping = {
        "DEBUG": AuditSeverity.INFO,
        "INFO": AuditSeverity.INFO,
        "WARNING": AuditSeverity.WARNING,
        "ERROR": AuditSeverity.ERROR,
        "CRITICAL": AuditSeverity.CRITICAL,
    }
    return mapping.get(level.upper(), AuditSeverity.INFO)
```

#### 3.2.9 Debug API (KEIN ESP-LOGS ENDPOINT!)

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `debug.py` | `El Servador/god_kaiser_server/src/api/v1/debug.py` | ~400+ | ⚠️ Kein /esp-logs |

**Vorhandene Endpoints:**

| Endpoint | Methode | Beschreibung |
|----------|---------|--------------|
| `/v1/debug/logs` | GET | Server-Log-Dateien abfragen |
| `/v1/debug/logs/files` | GET | Verfügbare Log-Dateien auflisten |
| `/v1/debug/mock-esp` | POST | Mock-ESP erstellen |
| `/v1/debug/mock-esp/{id}` | PATCH | Mock-ESP aktualisieren |
| `/v1/debug/mock-esp/{id}` | DELETE | Mock-ESP löschen |
| `/v1/debug/mock-esp/{id}/messages` | GET | Mock-ESP Nachrichten |

**❌ FEHLT: `/v1/debug/esp-logs` Endpoint!**

---

### 3.3 Frontend Log-System

#### 3.3.1 MqttLogView (VOLLSTÄNDIG IMPLEMENTIERT)

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `MqttLogView.vue` | `El Frontend/src/views/MqttLogView.vue` | ~285 | ✅ Vollständig |

**Komponenten-Typ:** Real-time WebSocket Message Viewer

**WebSocket-Integration (MqttLogView.vue:19-23, 125-135):**
```typescript
// Singleton-Pattern
const { subscribe, unsubscribe, isConnected } = useWebSocket({
  autoConnect: true,
  autoReconnect: true,
})

// Subscribe zu allen Message-Types
subscribe(
  { types: messageTypes },
  handleWebSocketMessage
)
```

**Unterstützte Event-Types (MqttLogView.vue:44-54):**
```typescript
messageTypes: MessageType[] = [
  'sensor_data',           // Sensor-Messwerte
  'actuator_status',       // Aktor-Zustandsänderungen
  'actuator_response',     // Command-Bestätigungen
  'actuator_alert',        // Emergency/Timeout-Alerts
  'esp_health',            // Device-Health-Info
  'config_response',       // Config-Bestätigungen
  'zone_assignment',       // Zone-ACK-Bestätigungen
  'logic_execution',       // Logic-Rule-Triggers
  'system_event',          // System-Notifications
]
```

**UI-Struktur:**

| Bereich | Zeilen | Beschreibung |
|---------|--------|--------------|
| Header | 141-179 | Connection-Status, Pause/Resume, Filters, Clear |
| Filter-Panel | 181-225 | Multi-Select Checkboxes, ESP-ID, Topic-Contains |
| Message-Display | 233-280 | Scrollable, Max 500 Messages, Collapsible Rows |
| Message-Row | 240-278 | Time, Type-Badge, ESP-ID, Topic, JSON-Payload |

**Message-Struktur (MqttLogView.vue:63-70):**
```typescript
const msg: MqttMessage = {
  id: `${Date.now()}_${Math.random().toString(36).slice(2)}`,
  timestamp: new Date().toISOString(),
  type: (message.type as MessageType) || 'system_event',
  topic: (message.data.topic as string) || '',
  payload: (message.data.payload || message.data) as Record<string, unknown>,
  esp_id: (message.data.esp_id as string) || undefined,
}
```

**Type-Color-Mapping (MqttLogView.vue:100-113):**
```typescript
const typeColors = {
  'sensor_data': 'badge-info',        // Blau
  'actuator_status': 'badge-success', // Grün
  'actuator_response': 'badge-success',
  'actuator_alert': 'badge-danger',   // Rot
  'system_event': 'badge-danger',
  'config_response': 'badge-warning', // Gelb
  'logic_execution': 'badge-warning',
  'esp_health': 'badge-gray',         // Grau
  'zone_assignment': 'badge-gray',
}
```

#### 3.3.2 LogViewerView (VOLLSTÄNDIG IMPLEMENTIERT)

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `LogViewerView.vue` | `El Frontend/src/views/LogViewerView.vue` | ~430 | ✅ Vollständig |

**Komponenten-Typ:** Server-side Log File Viewer mit HTTP-Polling

**HTTP-Polling (LogViewerView.vue:58-114):**
```typescript
// Log-Dateien laden (Zeile 58-69)
async function loadLogFiles(): Promise<void> {
  const response = await logsApi.listFiles()
  logFiles.value = response.files
}

// Logs mit Filtern laden (Zeile 72-97)
async function loadLogs(): Promise<void> {
  const response = await logsApi.queryLogs(currentQueryParams.value)
  logs.value = response.logs
  totalCount.value = response.total_count
  hasMore.value = response.has_more
}

// Real-time Polling alle 3 Sekunden (Zeile 99-114)
function toggleRealtime(): void {
  isRealtime.value = !isRealtime.value
  if (isRealtime.value) {
    realtimeInterval.value = setInterval(() => loadLogs(), 3000)
  }
}
```

**Filter-Capabilities (LogViewerView.vue:17-56):**

| Filter | Typ | Beschreibung |
|--------|-----|--------------|
| `selectedLevel` | LogLevel | DEBUG/INFO/WARNING/ERROR/CRITICAL |
| `moduleFilter` | String | Logger-Modul-Name |
| `searchQuery` | String | Volltext-Suche |
| `selectedFile` | String | Log-Datei-Auswahl |
| `startTime` | ISO 8601 | Zeit-Range Start |
| `endTime` | ISO 8601 | Zeit-Range Ende |
| `page` | Number | Seiten-Nummer |
| `pageSize` | Number | Items pro Seite (default: 100, max: 1000) |

**UI-Struktur:**

| Bereich | Zeilen | Beschreibung |
|---------|--------|--------------|
| Header | 173-205 | Live/Pause Toggle, Refresh Button |
| Filter-Card | 222-318 | File-Selector, Level-Dropdown, Module, Search, Time-Range |
| Logs-Table | 321-424 | Sticky Header, Expandable Rows, Load More |
| Expanded-Details | 366-391 | Module, Function, Line, Full Message, Exception, Extra Data |

**Log-Entry-Struktur:**
```typescript
interface LogEntry {
  timestamp: string
  level: LogLevel
  logger: string        // Modul-Pfad
  message: string
  module?: string
  function?: string
  line?: number
  exception?: string    // Traceback
  extra?: Record<string, unknown>
}
```

#### 3.3.3 WebSocket Service (SINGLETON)

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `websocket.ts` | `El Frontend/src/services/websocket.ts` | ~580 | ✅ Vollständig |

**WebSocket-Konfiguration (websocket.ts:108-112):**
```typescript
// Endpoint: /api/v1/ws/realtime/{client_id}
// Protokoll: ws:// oder wss:// basierend auf Page-Protokoll
// Auth: JWT-Token als URL-Parameter
```

**Reconnection-Strategie (websocket.ts:237-266):**
- Exponential Backoff: 1s, 2s, 4s, 8s, 16s (max 30s)
- Base Delay: 1000ms, Max Delay: 30000ms
- Jitter (±10%) um Thundering Herd zu vermeiden
- Max 10 Reconnect-Versuche

**Rate-Limiting (websocket.ts:337-372):**
- Limit: 10 Messages/Sekunde
- Warning bei Überschreitung

**Filter-Types (websocket.ts:24-29):**
```typescript
interface WebSocketFilters {
  types?: MessageType[]      // Message-Type Whitelist
  esp_ids?: string[]         // Device-ID Whitelist
  sensor_types?: string[]    // Sensor-Type Whitelist
  topicPattern?: string      // Topic Regex Pattern
}
```

**Wichtige Methoden:**

| Methode | Datei:Zeile | Beschreibung |
|---------|-------------|--------------|
| `connect()` | websocket.ts:149-207 | Verbindung herstellen |
| `disconnect()` | websocket.ts:209-225 | Verbindung trennen |
| `subscribe(filters, callback)` | websocket.ts:427-521 | Event-Subscription |
| `unsubscribe(id)` | websocket.ts:523-535 | Subscription entfernen |
| `routeMessage(message)` | websocket.ts:374-421 | Message zu Subscriptions routen |

#### 3.3.4 useWebSocket Composable

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `useWebSocket.ts` | `El Frontend/src/composables/useWebSocket.ts` | ~265 | ✅ Vollständig |

**Reactive State (useWebSocket.ts:37-50):**
```typescript
isConnected: Ref<boolean>
isConnecting: Ref<boolean>
connectionError: Ref<string | null>
connectionStatus: Computed<'connecting'|'connected'|'error'|'disconnected'>
reconnectAttempts: Ref<number>
lastMessage: Ref<WebSocketMessage | null>
messageCount: Ref<number>
rateLimitWarning: Ref<boolean>
activeFilters: Ref<WebSocketFilters | null>
```

**Wichtige Methoden:**

| Methode | Datei:Zeile | Beschreibung |
|---------|-------------|--------------|
| `connect()` | useWebSocket.ts:70-93 | Verbindung herstellen |
| `disconnect()` | useWebSocket.ts:98-107 | Verbindung trennen |
| `subscribe(filters, callback)` | useWebSocket.ts:113-150 | Mit Filtern subscriben |
| `unsubscribe()` | useWebSocket.ts:152-165 | Subscription entfernen |
| `on(type, callback)` | useWebSocket.ts:167-184 | Für spezifischen Type subscriben |
| `cleanup()` | useWebSocket.ts:233-239 | Alles aufräumen |

#### 3.3.5 Logs API Client

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `logs.ts` | `El Frontend/src/api/logs.ts` | ~100 | ✅ Vollständig |

**API-Funktionen (logs.ts:66-96):**
```typescript
// Log-Dateien auflisten
logsApi.listFiles(): Promise<LogFilesResponse>
// GET /debug/logs/files

// Logs mit Filtern abfragen
logsApi.queryLogs(params: LogQueryParams): Promise<LogsResponse>
// GET /debug/logs?level=...&module=...&search=...
```

**Request-Parameter (logs.ts:51-60):**
```typescript
interface LogQueryParams {
  level?: LogLevel              // DEBUG|INFO|WARNING|ERROR|CRITICAL
  module?: string               // Filter nach Logger-Modul
  search?: string               // Volltext-Suche in Messages
  start_time?: string           // ISO 8601 Datetime
  end_time?: string             // ISO 8601 Datetime
  file?: string                 // Log-Dateiname
  page?: number                 // Seiten-Nummer
  page_size?: number            // Items pro Seite (1-1000)
}
```

**Response-Types (logs.ts:27-49):**
```typescript
interface LogsResponse {
  success: boolean
  logs: LogEntry[]
  total_count: number           // Gesamt-Anzahl
  page: number
  page_size: number
  has_more: boolean             // Weitere Seiten vorhanden
}

interface LogFile {
  name: string                  // Dateiname
  path: string                  // Voller Pfad
  size_bytes: number
  size_human: string            // z.B. "2.5 MB"
  modified: string              // Letzte Änderung
  is_current: boolean           // Aktuelle Log-Datei
}
```

#### 3.3.6 Router-Konfiguration

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `index.ts` | `El Frontend/src/router/index.ts` | ~120 | ✅ Vollständig |

**Logging-relevante Routen:**

| Pfad | Name | Komponente | Auth |
|------|------|------------|------|
| `/logs` | `logs` | `LogViewerView.vue` | Admin only |
| `/audit` | `audit` | `AuditLogView.vue` | Authenticated |
| `/mqtt-log` | `mqtt-log` | `MqttLogView.vue` | Authenticated |

**❌ FEHLT: `/log-center` Route für Unified Log Center!**

#### 3.3.7 Type-Definitionen

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `index.ts` | `El Frontend/src/types/index.ts` | ~200 | ⚠️ Kein esp_log |

**WebSocket Message-Types (types/index.ts:161-186):**
```typescript
export type MessageType =
  | 'sensor_data'           // Sensor-Handler
  | 'actuator_status'       // Actuator-Handler
  | 'actuator_response'     // Actuator-Response-Handler
  | 'actuator_alert'        // Actuator-Alert-Handler
  | 'esp_health'            // Heartbeat-Handler
  | 'config_response'       // Config-Handler
  | 'zone_assignment'       // Zone-ACK-Handler
  | 'logic_execution'       // Logic-Engine
  | 'system_event'          // System-Notifications
```

**❌ FEHLT: `| 'esp_log'` für ESP-Logs!**

---

## 4. Status-Zusammenfassung

### Was VOLLSTÄNDIG implementiert ist:

| Komponente | Pfad | Status |
|------------|------|--------|
| ESP32 Logger-Klasse | `El Trabajante/src/utils/logger.*` | ✅ Vollständig |
| ESP32 Error-Codes | `El Trabajante/src/models/error_codes.h` | ✅ Vollständig |
| ESP32 TopicBuilder (ohne Log) | `El Trabajante/src/utils/topic_builder.*` | ✅ Vollständig |
| ESP32 MQTT-Client (ohne publishLog) | `El Trabajante/src/services/communication/mqtt_client.*` | ✅ Vollständig |
| Server Logging-Config | `El Servador/.../core/logging_config.py` | ✅ Vollständig |
| Server MQTT-Subscriber | `El Servador/.../mqtt/subscriber.py` | ✅ Vollständig |
| Server BaseMQTTHandler | `El Servador/.../mqtt/handlers/base_handler.py` | ✅ Vollständig |
| Server AuditLog Model | `El Servador/.../db/models/audit_log.py` | ✅ Vollständig |
| Server AuditLog Repository | `El Servador/.../db/repositories/audit_log_repo.py` | ✅ Vollständig |
| Server WebSocket Manager | `El Servador/.../websocket/manager.py` | ✅ Vollständig |
| Frontend MqttLogView | `El Frontend/src/views/MqttLogView.vue` | ✅ Vollständig |
| Frontend LogViewerView | `El Frontend/src/views/LogViewerView.vue` | ✅ Vollständig |
| Frontend WebSocket Service | `El Frontend/src/services/websocket.ts` | ✅ Vollständig |
| Frontend useWebSocket | `El Frontend/src/composables/useWebSocket.ts` | ✅ Vollständig |
| Frontend Logs API | `El Frontend/src/api/logs.ts` | ✅ Vollständig |

### Was FEHLT (zu implementieren):

| Komponente | Pfad | Aufwand |
|------------|------|---------|
| **ESP32: Log-Topic in TopicBuilder** | `El Trabajante/src/utils/topic_builder.*` | 30 min |
| **ESP32: publishLog() in MQTT-Client** | `El Trabajante/src/services/communication/mqtt_client.*` | 1h |
| **Server: log_handler.py** | `El Servador/.../mqtt/handlers/log_handler.py` | 2h |
| **Server: Handler-Registrierung in main.py** | `El Servador/.../main.py` (nach Zeile 233) | 15 min |
| **Server: ESP_LOG_MESSAGE Event-Type** | `El Servador/.../db/models/audit_log.py` | 15 min |
| **Server: log_esp_message() Methode** | `El Servador/.../db/repositories/audit_log_repo.py` | 1h |
| **Server: /v1/debug/esp-logs Endpoint** | `El Servador/.../api/v1/debug.py` | 1h |
| **Server: esp_log WebSocket Event-Type** | `El Servador/.../websocket/manager.py` | 15 min |
| **Frontend: esp_log MessageType** | `El Frontend/src/types/index.ts` | 5 min |
| **Frontend: LogCenterView.vue** | `El Frontend/src/views/LogCenterView.vue` | 3h |
| **Frontend: /log-center Route** | `El Frontend/src/router/index.ts` | 15 min |

---

## 5. Implementierung (PHASE 2)

### 5.1 ESP32: TopicBuilder erweitern

**Datei:** `El Trabajante/src/utils/topic_builder.h`

```cpp
// Nach Zeile 45 hinzufügen:

/**
 * @brief Build system log topic
 * @return Topic string: kaiser/{kaiser_id}/esp/{esp_id}/system/log
 */
static const char* buildSystemLogTopic();
```

**Datei:** `El Trabajante/src/utils/topic_builder.cpp`

```cpp
// Nach Zeile 95 hinzufügen (nach buildSystemDiagnosticsTopic):

const char* TopicBuilder::buildSystemLogTopic() {
  int written = snprintf(topic_buffer_, sizeof(topic_buffer_),
                         "kaiser/%s/esp/%s/system/log",
                         kaiser_id_, esp_id_);
  return validateTopicBuffer(written);
}
```

### 5.2 ESP32: MQTT-Client publishLog() hinzufügen

**Datei:** `El Trabajante/src/services/communication/mqtt_client.h`

```cpp
// Nach Zeile 85 hinzufügen (nach publishHeartbeat Deklaration):

/**
 * @brief Publish log message to server
 * @param level Log level (LOG_DEBUG, LOG_INFO, LOG_WARNING, LOG_ERROR, LOG_CRITICAL)
 * @param module Module name (e.g., "sensor_manager", "actuator_manager")
 * @param message Log message text
 * @param error_code Optional error code (0 = no error)
 * @param details_json Optional JSON string with additional details
 * @return true if published successfully
 */
bool publishLog(LogLevel level, const char* module, const char* message,
                uint16_t error_code = 0, const char* details_json = nullptr);
```

**Datei:** `El Trabajante/src/services/communication/mqtt_client.cpp`

```cpp
// Nach Zeile 470 hinzufügen (nach publishHeartbeat):

bool MQTTClient::publishLog(LogLevel level, const char* module, const char* message,
                            uint16_t error_code, const char* details_json) {
    if (!isConnected()) {
        return false;
    }

    // Nur ERROR und CRITICAL werden gesendet (bandwidth optimization)
    if (level < LOG_ERROR) {
        return true;  // Success, aber nicht gesendet
    }

    const char* topic = TopicBuilder::buildSystemLogTopic();

    time_t unix_timestamp = timeManager.getUnixTimestamp();

    String payload = "{";
    payload += "\"ts\":" + String((unsigned long)unix_timestamp) + ",";
    payload += "\"esp_id\":\"" + g_system_config.esp_id + "\",";
    payload += "\"level\":\"" + String(Logger::getLogLevelString(level)) + "\",";
    payload += "\"module\":\"" + String(module) + "\",";
    payload += "\"message\":\"" + String(message) + "\"";

    if (error_code > 0) {
        payload += ",\"error_code\":" + String(error_code);
        payload += ",\"error_description\":\"" + String(getErrorDescription(error_code)) + "\"";
    }

    if (details_json != nullptr && strlen(details_json) > 0) {
        payload += ",\"details\":" + String(details_json);
    }

    payload += "}";

    // QoS 0 für Logs (best-effort, kein ACK benötigt)
    return publish(topic, payload, 0);
}
```

### 5.3 Server: ESP Log Handler erstellen

**Neue Datei:** `El Servador/god_kaiser_server/src/mqtt/handlers/esp_log_handler.py`

```python
"""
Handler für ESP32 Log-Nachrichten.
Topic: kaiser/{kaiser_id}/esp/{esp_id}/system/log

Basiert auf dem BaseMQTTHandler-Pattern (siehe base_handler.py).
"""
import re
from typing import Dict, Any, Optional
from datetime import datetime, timezone

from .base_handler import (
    BaseMQTTHandler,
    TopicParseResult,
    ValidationResult,
)
from ...core.logging_config import get_logger
from ...db.models.esp import ESPDevice
from ...db.models.audit_log import AuditEventType, AuditSeverity, AuditSourceType
from ...db.repositories.audit_log_repo import AuditLogRepository
from ...db.session import get_session

logger = get_logger(__name__)

# Topic Pattern: kaiser/{kaiser_id}/esp/{esp_id}/system/log
TOPIC_PATTERN = re.compile(
    r"^kaiser/(?P<kaiser_id>[^/]+)/esp/(?P<esp_id>[^/]+)/system/log$"
)

# ESP Log-Level zu Audit-Severity Mapping
LEVEL_TO_SEVERITY = {
    "DEBUG": AuditSeverity.INFO,
    "INFO": AuditSeverity.INFO,
    "WARNING": AuditSeverity.WARNING,
    "ERROR": AuditSeverity.ERROR,
    "CRITICAL": AuditSeverity.CRITICAL,
}


class ESPLogHandler(BaseMQTTHandler):
    """Handler für ESP32 Log-Nachrichten."""

    handler_name = "esp_log"
    requires_esp_lookup = True

    def parse_topic(self, topic: str) -> TopicParseResult:
        """Parse das Log-Topic und extrahiere kaiser_id und esp_id."""
        match = TOPIC_PATTERN.match(topic)
        if not match:
            return TopicParseResult.failure(f"Invalid topic format: {topic}")

        return TopicParseResult.success(
            kaiser_id=match.group("kaiser_id"),
            esp_id=match.group("esp_id"),
        )

    def validate_payload(self, payload: Dict[str, Any]) -> ValidationResult:
        """Validiere den Log-Payload."""
        # Pflichtfelder
        required_fields = ["ts", "esp_id", "level", "message"]
        missing = [f for f in required_fields if f not in payload]
        if missing:
            return ValidationResult.failure(
                error_code=5201,
                error_message=f"Missing required fields: {missing}"
            )

        # Level validieren
        level = payload.get("level", "").upper()
        if level not in LEVEL_TO_SEVERITY:
            return ValidationResult.failure(
                error_code=5202,
                error_message=f"Invalid log level: {level}"
            )

        # Timestamp validieren
        ts = payload.get("ts")
        if not isinstance(ts, (int, float)):
            return ValidationResult.failure(
                error_code=5203,
                error_message=f"Invalid timestamp: {ts}"
            )

        return ValidationResult.success(data=payload)

    async def process_message(
        self,
        topic_result: TopicParseResult,
        payload: Dict[str, Any],
        esp_device: Optional[ESPDevice]
    ) -> None:
        """Verarbeite die Log-Nachricht."""
        esp_id = topic_result.esp_id
        level = payload.get("level", "INFO").upper()
        message = payload.get("message", "")
        module = payload.get("module", "unknown")
        error_code = payload.get("error_code")
        error_description = payload.get("error_description")
        details = payload.get("details", {})
        ts = payload.get("ts", 0)

        # Log-Level-basiertes Logging
        severity = LEVEL_TO_SEVERITY.get(level, AuditSeverity.INFO)
        log_method = getattr(logger, severity, logger.info)
        log_method(
            f"ESP Log [{esp_id}][{module}]: {message}",
            extra={
                "esp_id": esp_id,
                "module": module,
                "error_code": error_code,
            }
        )

        # In Datenbank speichern via AuditLog
        async with get_session() as session:
            audit_repo = AuditLogRepository(session)

            await audit_repo.create(
                event_type=AuditEventType.ESP_LOG_MESSAGE,
                severity=severity,
                source_type=AuditSourceType.ESP32,
                source_id=esp_id,
                status="success",
                message=message,
                details={
                    "module": module,
                    "log_level": level,
                    "original_timestamp": ts,
                    **(details if isinstance(details, dict) else {}),
                },
                error_code=str(error_code) if error_code else None,
                error_description=error_description,
            )

        # WebSocket-Broadcast
        await self.broadcast_event(
            message_type="esp_log",
            data={
                "esp_id": esp_id,
                "level": level,
                "module": module,
                "message": message,
                "error_code": error_code,
                "error_description": error_description,
                "details": details,
                "timestamp": ts,
            }
        )


# Handler-Instanz
_handler = ESPLogHandler()


async def handle_esp_log(topic: str, payload: Dict[str, Any]) -> bool:
    """Entry-Point für MQTT-Subscriber."""
    return await _handler.handle(topic, payload)
```

### 5.4 Server: Handler in main.py registrieren

**Datei:** `El Servador/god_kaiser_server/src/main.py`

```python
# Nach Zeile 17 hinzufügen (Imports):
from .mqtt.handlers import esp_log_handler

# Nach Zeile 233 hinzufügen (Handler-Registrierung):
_subscriber_instance.register_handler(
    f"kaiser/{kaiser_id}/esp/+/system/log",
    esp_log_handler.handle_esp_log
)
logger.info("Registered ESP Log handler for system/log topic")
```

### 5.5 Server: ESP_LOG_MESSAGE Event-Type hinzufügen

**Datei:** `El Servador/god_kaiser_server/src/db/models/audit_log.py`

```python
# In class AuditEventType (nach Zeile 211):
ESP_LOG_MESSAGE = "esp_log_message"
ESP_DIAGNOSTIC = "esp_diagnostic"
```

### 5.6 Server: /v1/debug/esp-logs Endpoint

**Datei:** `El Servador/god_kaiser_server/src/api/v1/debug.py`

```python
# Nach den bestehenden Endpoints hinzufügen:

from typing import List, Optional
from datetime import datetime
from pydantic import BaseModel, Field


class ESPLogResponse(BaseModel):
    """Response-Schema für ESP-Logs."""
    id: str
    esp_id: str
    level: str
    module: Optional[str]
    message: str
    error_code: Optional[str]
    error_description: Optional[str]
    details: Optional[dict]
    timestamp: datetime

    class Config:
        from_attributes = True


class ESPLogsListResponse(BaseModel):
    """Liste von ESP-Logs mit Pagination."""
    success: bool
    logs: List[ESPLogResponse]
    total_count: int
    page: int
    page_size: int
    has_more: bool


@router.get("/esp-logs", response_model=ESPLogsListResponse)
async def get_esp_logs(
    esp_id: Optional[str] = None,
    level: Optional[str] = Query(None, description="Log-Level: DEBUG, INFO, WARNING, ERROR, CRITICAL"),
    module: Optional[str] = None,
    error_code: Optional[int] = None,
    start_time: Optional[datetime] = None,
    end_time: Optional[datetime] = None,
    page: int = Query(1, ge=1),
    page_size: int = Query(100, ge=1, le=1000),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_admin_user),
):
    """
    ESP32-Logs abfragen mit Filtern.

    Filter:
    - esp_id: Filter nach spezifischem ESP
    - level: Filter nach Log-Level
    - module: Filter nach ESP-Modul
    - error_code: Filter nach Error-Code
    - start_time/end_time: Zeitraum-Filter
    """
    from ...db.models.audit_log import AuditLog, AuditEventType, AuditSourceType
    from sqlalchemy import select, func, and_

    # Basis-Query
    conditions = [
        AuditLog.event_type == AuditEventType.ESP_LOG_MESSAGE,
        AuditLog.source_type == AuditSourceType.ESP32,
    ]

    # Filter anwenden
    if esp_id:
        conditions.append(AuditLog.source_id == esp_id)

    if level:
        # Level ist in details.log_level gespeichert
        conditions.append(AuditLog.details["log_level"].astext == level.upper())

    if module:
        conditions.append(AuditLog.details["module"].astext.ilike(f"%{module}%"))

    if error_code:
        conditions.append(AuditLog.error_code == str(error_code))

    if start_time:
        conditions.append(AuditLog.created_at >= start_time)

    if end_time:
        conditions.append(AuditLog.created_at <= end_time)

    # Total Count
    count_query = select(func.count()).where(and_(*conditions)).select_from(AuditLog)
    total_count = await db.scalar(count_query) or 0

    # Logs abrufen
    offset = (page - 1) * page_size
    query = (
        select(AuditLog)
        .where(and_(*conditions))
        .order_by(AuditLog.created_at.desc())
        .offset(offset)
        .limit(page_size)
    )

    result = await db.execute(query)
    logs = result.scalars().all()

    # Response formatieren
    log_responses = []
    for log in logs:
        details = log.details or {}
        log_responses.append(ESPLogResponse(
            id=str(log.id),
            esp_id=log.source_id,
            level=details.get("log_level", "INFO"),
            module=details.get("module"),
            message=log.message,
            error_code=log.error_code,
            error_description=log.error_description,
            details=details,
            timestamp=log.created_at,
        ))

    return ESPLogsListResponse(
        success=True,
        logs=log_responses,
        total_count=total_count,
        page=page,
        page_size=page_size,
        has_more=offset + len(logs) < total_count,
    )


@router.get("/error-codes")
async def get_error_codes():
    """
    Gibt alle Error-Codes mit menschenlesbaren Beschreibungen zurück.
    Konsolidiert ESP32 und Server Error-Codes.
    """
    return {
        "esp32": {
            "ranges": {
                "1000-1999": "HARDWARE (GPIO, I2C, SPI, OneWire, Sensor, Actuator)",
                "2000-2999": "SERVICE (NVS, Config, Logger, Storage, Subzone)",
                "3000-3999": "COMMUNICATION (WiFi, MQTT, HTTP, Network)",
                "4000-4999": "APPLICATION (State, Operation, Command, Payload)",
            },
            "codes": {
                "1001": {"name": "ERROR_GPIO_RESERVED", "description": "Pin bereits reserviert", "severity": "ERROR"},
                "1002": {"name": "ERROR_GPIO_CONFLICT", "description": "GPIO-Konflikt", "severity": "ERROR"},
                "1003": {"name": "ERROR_GPIO_INIT_FAILED", "description": "GPIO-Initialisierung fehlgeschlagen", "severity": "CRITICAL"},
                "1010": {"name": "ERROR_I2C_INIT_FAILED", "description": "I2C-Initialisierung fehlgeschlagen", "severity": "CRITICAL"},
                "1011": {"name": "ERROR_I2C_DEVICE_NOT_FOUND", "description": "I2C-Gerät nicht gefunden", "severity": "WARNING"},
                "1040": {"name": "ERROR_SENSOR_READ_FAILED", "description": "Sensor konnte nicht gelesen werden", "severity": "WARNING"},
                "1041": {"name": "ERROR_SENSOR_INIT_FAILED", "description": "Sensor-Initialisierung fehlgeschlagen", "severity": "ERROR"},
                "1050": {"name": "ERROR_ACTUATOR_SET_FAILED", "description": "Aktor-Befehl fehlgeschlagen", "severity": "ERROR"},
                "1051": {"name": "ERROR_ACTUATOR_INIT_FAILED", "description": "Aktor-Initialisierung fehlgeschlagen", "severity": "CRITICAL"},
                "3010": {"name": "ERROR_MQTT_INIT_FAILED", "description": "MQTT-Initialisierung fehlgeschlagen", "severity": "CRITICAL"},
                "3011": {"name": "ERROR_MQTT_CONNECT_FAILED", "description": "MQTT-Verbindung fehlgeschlagen", "severity": "ERROR"},
                "3012": {"name": "ERROR_MQTT_PUBLISH_FAILED", "description": "MQTT-Publish fehlgeschlagen", "severity": "WARNING"},
                "3013": {"name": "ERROR_MQTT_SUBSCRIBE_FAILED", "description": "MQTT-Subscribe fehlgeschlagen", "severity": "ERROR"},
            }
        },
        "server": {
            "ranges": {
                "5000-5099": "CONFIG (Validation-Fehler)",
                "5100-5199": "MQTT (Handler-Fehler)",
                "5200-5299": "VALIDATION (Payload-Fehler)",
                "5300-5399": "DATABASE (DB-Operation-Fehler)",
                "5400-5499": "SERVICE (Business-Logic-Fehler)",
                "5500-5599": "AUDIT (Audit-Log-Fehler)",
            },
            "codes": {
                "5001": {"name": "ERROR_CONFIG_INVALID", "description": "Ungültige Konfiguration", "severity": "ERROR"},
                "5101": {"name": "ERROR_MQTT_HANDLER_FAILED", "description": "MQTT-Handler fehlgeschlagen", "severity": "ERROR"},
                "5201": {"name": "ERROR_PAYLOAD_MISSING_FIELDS", "description": "Pflichtfelder fehlen im Payload", "severity": "WARNING"},
                "5301": {"name": "ERROR_DB_QUERY_FAILED", "description": "Datenbankabfrage fehlgeschlagen", "severity": "ERROR"},
            }
        }
    }
```

### 5.7 Frontend: esp_log MessageType hinzufügen

**Datei:** `El Frontend/src/types/index.ts`

```typescript
// Nach Zeile 175 (vor die schließende Klammer von MessageType):
  | 'esp_log'               // ESP32 Log-Nachrichten
```

### 5.8 Frontend: Logs API erweitern

**Datei:** `El Frontend/src/api/logs.ts`

```typescript
// Nach den bestehenden Interfaces hinzufügen:

export interface ESPLog {
  id: string
  esp_id: string
  level: 'DEBUG' | 'INFO' | 'WARNING' | 'ERROR' | 'CRITICAL'
  module: string | null
  message: string
  error_code: string | null
  error_description: string | null
  details: Record<string, unknown> | null
  timestamp: string
}

export interface ESPLogsResponse {
  success: boolean
  logs: ESPLog[]
  total_count: number
  page: number
  page_size: number
  has_more: boolean
}

export interface ESPLogQueryParams {
  esp_id?: string
  level?: string
  module?: string
  error_code?: number
  start_time?: string
  end_time?: string
  page?: number
  page_size?: number
}

export interface ErrorCodesResponse {
  esp32: {
    ranges: Record<string, string>
    codes: Record<string, { name: string; description: string; severity: string }>
  }
  server: {
    ranges: Record<string, string>
    codes: Record<string, { name: string; description: string; severity: string }>
  }
}

// In logsApi Objekt hinzufügen:
export const logsApi = {
  // Bestehende Methoden...
  listFiles: (): Promise<LogFilesResponse> =>
    apiClient.get('/debug/logs/files').then(r => r.data),

  queryLogs: (params: LogQueryParams): Promise<LogsResponse> =>
    apiClient.get('/debug/logs', { params }).then(r => r.data),

  // NEU:
  getESPLogs: (params: ESPLogQueryParams): Promise<ESPLogsResponse> =>
    apiClient.get('/debug/esp-logs', { params }).then(r => r.data),

  getErrorCodes: (): Promise<ErrorCodesResponse> =>
    apiClient.get('/debug/error-codes').then(r => r.data),
}
```

---

## 6. Datenfluss

### 6.1 ESP → Server → Frontend

```
┌─────────────────┐    MQTT (QoS 0)    ┌─────────────────┐    WebSocket    ┌─────────────────┐
│     ESP32       │───────────────────▶│     Server      │────────────────▶│    Frontend     │
│                 │                    │                 │                 │                 │
│ publishLog()    │                    │ esp_log_handler │                 │ MqttLogView     │
│  ↓              │                    │      ↓          │                 │ LogCenterView   │
│ TopicBuilder    │                    │ AuditLog DB     │                 │                 │
│ .buildSystem    │                    │      ↓          │                 │                 │
│ LogTopic()      │                    │ broadcast_event │                 │                 │
│                 │                    │ ("esp_log")     │                 │                 │
└─────────────────┘                    └─────────────────┘                 └─────────────────┘

Topic: kaiser/{kaiser_id}/esp/{esp_id}/system/log

Payload:
{
  "ts": 1234567890,
  "esp_id": "ESP_12AB34CD",
  "level": "ERROR",
  "module": "sensor_manager",
  "message": "Failed to read DS18B20",
  "error_code": 1040,
  "error_description": "Sensor konnte nicht gelesen werden",
  "details": {"gpio": 4}
}
```

### 6.2 Log-Levels und Farben

| Level | ESP32-Funktion | Server-Severity | Frontend-Badge |
|-------|----------------|-----------------|----------------|
| DEBUG | `LOG_DEBUG()` | info | badge-gray |
| INFO | `LOG_INFO()` | info | badge-info (blau) |
| WARNING | `LOG_WARNING()` | warning | badge-warning (gelb) |
| ERROR | `LOG_ERROR()` | error | badge-danger (rot) |
| CRITICAL | `LOG_CRITICAL()` | critical | badge-danger (dunkelrot) |

---

## 7. Implementierungs-Checkliste

### Phase 1: ESP32 (30 min)

- [ ] `buildSystemLogTopic()` in topic_builder.h/cpp hinzufügen
- [ ] `publishLog()` in mqtt_client.h/cpp hinzufügen
- [ ] Build testen: `cd "El Trabajante" && pio run -e esp32_dev`

### Phase 2: Server Backend (3-4h)

- [ ] `esp_log_handler.py` erstellen (basierend auf BaseMQTTHandler)
- [ ] Handler-Import in `__init__.py` hinzufügen
- [ ] Handler in `main.py` registrieren
- [ ] `ESP_LOG_MESSAGE` Event-Type in audit_log.py hinzufügen
- [ ] `/v1/debug/esp-logs` Endpoint in debug.py hinzufügen
- [ ] `/v1/debug/error-codes` Endpoint in debug.py hinzufügen
- [ ] Server-Tests ausführen: `cd "El Servador" && poetry run pytest -v`

### Phase 3: Frontend (3h)

- [ ] `esp_log` MessageType in types/index.ts hinzufügen
- [ ] logs.ts API-Client erweitern
- [ ] `LogCenterView.vue` erstellen (Tab-basiert)
- [ ] Route `/log-center` hinzufügen
- [ ] Sidebar-Navigation erweitern
- [ ] WebSocket `esp_log` Handler in MqttLogView erweitern

### Phase 4: Integration & Test (1h)

- [ ] ESP32 mit Server testen
- [ ] Frontend mit echten Logs testen
- [ ] Performance-Test (viele Logs)
- [ ] Dokumentation aktualisieren

---

## 8. Code-Locations Referenz (VOLLSTÄNDIG)

### ESP32

| Komponente | Pfad | Beschreibung |
|------------|------|--------------|
| **Logger-Klasse** | `El Trabajante/src/utils/logger.h:9-103` | Log-Levels, LogEntry, Makros |
| **Logger-Implementation** | `El Trabajante/src/utils/logger.cpp:6-193` | Singleton, Circular Buffer |
| **Error-Codes** | `El Trabajante/src/models/error_codes.h:12-332` | Alle Error-Codes + Helper |
| **TopicBuilder** | `El Trabajante/src/utils/topic_builder.h:15-85` | Topic-Generierung |
| **TopicBuilder-Impl** | `El Trabajante/src/utils/topic_builder.cpp:7-195` | 18 Topic-Pattern |
| **MQTT-Client** | `El Trabajante/src/services/communication/mqtt_client.h:17-145` | MQTTConfig, Methoden |
| **MQTT-Client-Impl** | `El Trabajante/src/services/communication/mqtt_client.cpp:32-600` | Publish, Heartbeat |

### Server

| Komponente | Pfad | Beschreibung |
|------------|------|--------------|
| **Logging-Config** | `El Servador/.../core/logging_config.py:15-138` | JSON/Text Formatter, Setup |
| **BaseMQTTHandler** | `El Servador/.../mqtt/handlers/base_handler.py:43-565` | Validation, Topic-Parse, Audit |
| **MQTT-Subscriber** | `El Servador/.../mqtt/subscriber.py:34-323` | Handler-Registrierung, Routing |
| **main.py Lifespan** | `El Servador/.../main.py:81-323` | Startup/Shutdown, Handler-Registration |
| **AuditLog Model** | `El Servador/.../db/models/audit_log.py:26-231` | Spalten, Event-Types, Severity |
| **AuditLog Repo** | `El Servador/.../db/repositories/audit_log_repo.py:54-420` | CRUD, Logging-Methoden |
| **WebSocket Manager** | `El Servador/.../websocket/manager.py:41-308` | Singleton, Broadcast, Rate-Limit |
| **Debug API** | `El Servador/.../api/v1/debug.py:82-400+` | Logs, Mock-ESP, Database-Explorer |

### Frontend

| Komponente | Pfad | Beschreibung |
|------------|------|--------------|
| **MqttLogView** | `El Frontend/src/views/MqttLogView.vue:1-285` | WebSocket Real-time |
| **LogViewerView** | `El Frontend/src/views/LogViewerView.vue:1-430` | Server-Logs HTTP-Polling |
| **WebSocket Service** | `El Frontend/src/services/websocket.ts:24-580` | Singleton, Reconnect, Filter |
| **useWebSocket** | `El Frontend/src/composables/useWebSocket.ts:17-262` | Vue Composable Wrapper |
| **Logs API** | `El Frontend/src/api/logs.ts:27-96` | HTTP-Client für Logs |
| **Types** | `El Frontend/src/types/index.ts:161-195` | MessageType, MqttMessage |
| **Router** | `El Frontend/src/router/index.ts:66-98` | Log-Routes |

---

## 9. Wichtige Hinweise

### 9.1 ESP32 Log-Bandbreite

**WICHTIG:** ESP32 sendet nur ERROR und CRITICAL Logs via MQTT!

```cpp
// In publishLog():
if (level < LOG_ERROR) {
    return true;  // Nicht senden, aber als Erfolg werten
}
```

DEBUG, INFO und WARNING bleiben lokal im Circular Buffer (50 Einträge) und werden nur über Serial ausgegeben.

### 9.2 Log-Retention

Nutze bestehenden `AuditRetentionService` als Vorlage:
- DEBUG-Logs: 7 Tage
- INFO-Logs: 14 Tage
- WARNING-Logs: 30 Tage
- ERROR/CRITICAL-Logs: 90 Tage

### 9.3 Performance-Indizes

In AuditLog sind bereits Indizes definiert:
- `created_at` (für Time-Range Queries)
- `severity, created_at` (für Level-Filter)
- `source_type, source_id, created_at` (für ESP-Filter)

### 9.4 Mock-ESP Log-Support

`MockESP32Client` kann erweitert werden um `publish_log()` für Tests:
```python
# In mock_esp_client.py
async def publish_log(self, level: str, module: str, message: str, error_code: int = 0):
    topic = f"kaiser/{self.kaiser_id}/esp/{self.esp_id}/system/log"
    payload = {
        "ts": int(time.time()),
        "esp_id": self.esp_id,
        "level": level,
        "module": module,
        "message": message,
        "error_code": error_code,
    }
    await self.publish(topic, payload)
```

---

**Dokument-Version:** 2.0
**Erstellt:** 2026-01-05
**Aktualisiert:** 2026-01-05
**Autor:** Claude (Manager-Modus)

---

## Changelog

### v2.0 (2026-01-05)
- Vollständige Codebase-Analyse mit Zeilennummern
- Alle relevanten Dateien dokumentiert
- Status-Übersicht: Was existiert vs. was fehlt
- Konkrete Implementierungsvorlagen basierend auf existierenden Patterns
- Error-Code-Referenz vollständig aus error_codes.h
- WebSocket und BaseMQTTHandler Pattern dokumentiert
- Frontend-Analyse: MqttLogView, LogViewerView, WebSocket Service

### v3.0 (2026-01-05)
- **NEU: Section 10 - Kommunikationsflüsse** hinzugefügt
- Vollständige Analyse aller Kommunikationspfade aus echtem Code
- ESP32→Server: Heartbeat, Sensor, Actuator Flows dokumentiert
- Server→ESP32: Config, Commands, Zone Flows dokumentiert
- Server→Frontend: WebSocket Events mit Broadcasting-Logik
- Frontend→Server: REST API und WebSocket Subscription
- Server-Zentrisches Prinzip mit ESP32 Fallback-Verhalten
- QoS-Levels, Timing-Konstanten, Retry-Logik dokumentiert

---

## 10. Kommunikationsflüsse (VOLLSTÄNDIGE ANALYSE)

> **WICHTIG:** Diese Sektion dokumentiert die tatsächlichen Kommunikationsflüsse aus dem echten Code.
> Alle Werte wurden aus den Quelldateien extrahiert und verifiziert.

---

### 10.1 ESP32 → Server Kommunikation

#### 10.1.1 Heartbeat

**Trigger:** Automatisch in `mqttClient.loop()` (mqtt_client.cpp:484)

| Parameter | Wert | Quelle |
|-----------|------|--------|
| **Interval** | 60 Sekunden | `HEARTBEAT_INTERVAL_MS = 60000` (mqtt_client.h:108) |
| **QoS** | 0 (best-effort) | mqtt_client.cpp:465 `publish(topic, payload, 0)` |
| **Topic** | `kaiser/{kaiser_id}/esp/{esp_id}/system/heartbeat` | TopicBuilder::buildSystemHeartbeatTopic() |
| **Retry** | Nein (QoS 0) | - |

**Payload-Struktur (mqtt_client.cpp:451-462):**
```json
{
  "esp_id": "ESP_12AB34CD",
  "zone_id": "zone_main",
  "master_zone_id": "master",
  "zone_assigned": true,
  "ts": 1704067200,          // Unix timestamp (NTP-sync)
  "uptime": 123456,          // Sekunden seit Boot
  "heap_free": 45000,        // Bytes (ESP.getFreeHeap())
  "wifi_rssi": -45,          // dBm (WiFi.RSSI())
  "sensor_count": 3,         // Aktive Sensoren
  "actuator_count": 2        // Aktive Aktoren
}
```

**Server-Verarbeitung (heartbeat_handler.py:55-170):**
1. Topic parsen → `esp_id` extrahieren
2. Payload validieren (required: `ts`, `uptime`, `heap_free`/`free_heap`, `wifi_rssi`)
3. ESP in DB suchen (REJECT wenn nicht registriert!)
4. Status auf "online" setzen, `last_seen` updaten
5. Metadata in DB aktualisieren
6. WebSocket broadcast `esp_health`

**Device-Timeout (heartbeat_handler.py:37):**
```python
HEARTBEAT_TIMEOUT_SECONDS = 300  # 5 Minuten → Device offline
```

---

#### 10.1.2 Sensor-Daten

**Trigger:** Automatisch via `sensorManager.performAllMeasurements()` in loop() (main.cpp:1083)

| Parameter | Wert | Quelle |
|-----------|------|--------|
| **Default-Interval** | 30 Sekunden | `measurement_interval_(30000)` (sensor_manager.cpp:33) |
| **Konfiguriert in main.cpp** | 5 Sekunden | `sensorManager.setMeasurementInterval(5000)` (main.cpp:979) |
| **QoS** | 0 (default), 1 für safePublish | mqtt_client.cpp:327 |
| **Topic** | `kaiser/{kaiser_id}/esp/{esp_id}/sensor/{gpio}/data` | TopicBuilder::buildSensorDataTopic() |
| **Batch-Topic** | `kaiser/{kaiser_id}/esp/{esp_id}/sensor/batch` | TopicBuilder::buildSensorBatchTopic() |

**Payload-Struktur (Required Fields - sensor_handler.py:326-368):**
```json
{
  "ts": 1704067200,          // REQUIRED: Unix timestamp
  "esp_id": "ESP_12AB34CD",  // REQUIRED
  "gpio": 34,                // REQUIRED
  "sensor_type": "ph",       // REQUIRED
  "raw": 2150,               // REQUIRED (oder "raw_value")
  "value": 0.0,              // Optional: Vorverarbeiteter Wert
  "unit": "",                // Optional
  "quality": "stale",        // Optional
  "raw_mode": true           // REQUIRED seit 2025-12-08!
}
```

**Server-Verarbeitung (sensor_handler.py:78-310):**
1. Topic parsen → `esp_id`, `gpio` extrahieren
2. Payload validieren (5 Pflichtfelder + `raw_mode`)
3. ESP in DB suchen (Warning wenn nicht gefunden)
4. Sensor-Config laden (optional)
5. **Pi-Enhanced Processing** wenn `sensor_config.pi_enhanced == True && raw_mode == True`:
   - Library dynamisch laden (`library_loader.py`)
   - RAW-Wert verarbeiten
   - Processed-Value zurück publizieren (optional)
6. Daten in DB speichern
7. WebSocket broadcast `sensor_data`
8. **Logic Engine triggern** (non-blocking, asyncio.create_task)

---

#### 10.1.3 Actuator-Status

**Trigger:** Nach Command-Execution ODER periodisch alle 30 Sekunden (main.cpp:1087-1091)

| Parameter | Wert | Quelle |
|-----------|------|--------|
| **Periodisch** | 30 Sekunden | `if (millis() - last_actuator_status > 30000)` (main.cpp:1088) |
| **Nach Command** | Sofort | actuator_manager.cpp nach setActuatorState() |
| **QoS** | 1 (safePublish) | actuator_manager.cpp |
| **Topic** | `kaiser/{kaiser_id}/esp/{esp_id}/actuator/{gpio}/status` | TopicBuilder::buildActuatorStatusTopic() |

**Payload-Struktur:**
```json
{
  "ts": 1704067200,
  "esp_id": "ESP_12AB34CD",
  "gpio": 25,
  "actuator_type": "pump",
  "state": "on",
  "value": 1.0,              // 0.0-1.0 (PWM normalisiert)
  "runtime_seconds": 120,
  "emergency_stopped": false
}
```

---

#### 10.1.4 Connection-Loss und Retry-Logik

**Offline-Buffer (mqtt_client.cpp:566-582):**
```cpp
// Max 100 Messages im Buffer
const uint16_t MAX_OFFLINE_MESSAGES = 100;

// Buffer-Eintrag
struct OfflineMessage {
  String topic;
  String payload;
  uint8_t qos;
  unsigned long timestamp;
};
```

**Exponential Backoff (mqtt_client.cpp:587-597):**
```cpp
const unsigned long RECONNECT_BASE_DELAY_MS = 1000;   // 1 Sekunde
const unsigned long RECONNECT_MAX_DELAY_MS = 60000;   // 60 Sekunden max
const uint16_t MAX_RECONNECT_ATTEMPTS = 10;

// Berechnung: delay * 2^attempts (gedeckelt bei 60s)
unsigned long delay = RECONNECT_BASE_DELAY_MS * (1 << reconnect_attempts_);
```

**Circuit Breaker (mqtt_client.cpp:54):**
```cpp
circuit_breaker_("MQTT", 5, 30000, 10000)
// 5 Failures → OPEN
// 30s Recovery Timeout
// 10s Half-Open Test Timeout
```

**Last-Will Message (mqtt_client.cpp:125-138):**
```cpp
// Topic: kaiser/{kaiser_id}/esp/{esp_id}/status/will
// Message: {"status":"offline","reason":"unexpected_disconnect","timestamp":...}
// QoS: 1, Retain: true
```

---

### 10.2 Server → ESP32 Kommunikation

#### 10.2.1 Config-Updates

**Trigger:** REST API `POST /api/v1/esp/{id}/config` oder Zone-Assignment

| Parameter | Wert | Quelle |
|-----------|------|--------|
| **QoS** | 2 (exactly-once) | subscriber.py:119-124 |
| **Topic** | `kaiser/{kaiser_id}/esp/{esp_id}/config` | TopicBuilder::buildConfigTopic() |

**Config-Payload (config_builder.py):**
```json
{
  "sensors": [
    {
      "gpio": 34,
      "sensor_type": "ph",
      "sensor_name": "pH Sensor 1",
      "subzone_id": "grow_area_1",
      "active": true,
      "raw_mode": true
    }
  ],
  "actuators": [
    {
      "gpio": 25,
      "actuator_type": "pump",
      "actuator_name": "Water Pump",
      "active": true
    }
  ],
  "zone": {
    "zone_id": "zone_main",
    "master_zone_id": "master",
    "zone_name": "Main Zone"
  }
}
```

**ESP32-Verarbeitung (main.cpp:517-521):**
1. Callback empfängt Config-Topic
2. `handleSensorConfig()` und `handleActuatorConfig()` aufrufen
3. Validierung, NVS-Speicherung
4. ACK via `config_response` Topic

**Offline-Handling (esp_service.py):**
```python
# Parameter: offline_behavior = "warn" | "skip" | "fail"
# Default: "warn" (loggt Warning, sendet trotzdem)
# "skip": Überspringt offline ESPs
# "fail": Wirft Exception wenn ESP offline
```

---

#### 10.2.2 Actuator-Commands

**Trigger:** REST API `POST /api/v1/actuators/{id}/command` oder Logic Engine

| Parameter | Wert | Quelle |
|-----------|------|--------|
| **QoS** | 1 (at-least-once) | actuator_service.py:135 `retry=True` |
| **Topic** | `kaiser/{kaiser_id}/esp/{esp_id}/actuator/{gpio}/command` | |

**Command-Payload:**
```json
{
  "command": "ON",           // ON, OFF, PWM, TOGGLE
  "value": 1.0,              // 0.0-1.0 (ESP konvertiert zu 0-255)
  "duration": 0,             // Sekunden (0 = unbegrenzt)
  "issued_by": "logic_engine"
}
```

**Safety-Validierung (actuator_service.py:74-107):**
```python
# IMMER vor jedem Command!
safety_result = await self.safety_service.validate_actuator_command(
    esp_id=esp_id,
    gpio=gpio,
    command=command,
    value=value,
)

# Checks:
# - Emergency-Stop aktiv?
# - Value in erlaubtem Bereich (0.0-1.0)?
# - Aktor existiert?
# - Timeout-Protection aktiv?
```

---

#### 10.2.3 Zone-Assignment

**Trigger:** REST API `POST /api/v1/zone/devices/{id}/assign`

| Parameter | Wert | Quelle |
|-----------|------|--------|
| **QoS** | 1 | zone_service.py |
| **Topic** | `kaiser/{kaiser_id}/esp/{esp_id}/zone/assign` | |
| **ACK-Topic** | `kaiser/{kaiser_id}/esp/{esp_id}/zone/ack` | |

**Assignment-Flow (main.cpp:646-726):**
1. Server publiziert Zone-Assignment
2. ESP empfängt, validiert zone_id
3. ESP speichert in NVS via `configManager.updateZoneAssignment()`
4. ESP updated globale Variablen (`g_kaiser`)
5. ESP sendet ACK mit Status
6. ESP sendet neuen Heartbeat

---

### 10.3 Server → Frontend Kommunikation (WebSocket)

#### 10.3.1 WebSocket-Konfiguration

| Parameter | Wert | Quelle |
|-----------|------|--------|
| **Endpoint** | `/api/v1/ws/realtime/{client_id}` | websocket.ts:112 |
| **Auth** | JWT Token als URL-Parameter | `?token=...` |
| **Rate-Limit** | 10 msg/sec | manager.py:39 |
| **Rate-Window** | 1 Sekunde (Sliding Window) | manager.py:269-287 |

#### 10.3.2 Event-Types und Broadcasting

| Event-Type | Handler | Broadcast-Zeitpunkt | Quelle |
|------------|---------|---------------------|--------|
| `sensor_data` | sensor_handler.py | Nach DB-Insert | Zeile 256-269 |
| `esp_health` | heartbeat_handler.py | Nach Status-Update | Zeile 154-168 |
| `actuator_status` | actuator_handler.py | Nach State-Update | |
| `actuator_response` | actuator_response_handler.py | Nach Command-ACK | |
| `actuator_alert` | actuator_alert_handler.py | Bei Emergency/Timeout | |
| `config_response` | config_handler.py | Nach Config-ACK | |
| `zone_assignment` | zone_ack_handler.py | Nach Zone-ACK | |
| `logic_execution` | logic_engine.py | Nach Rule-Trigger | |
| `system_event` | Verschiedene | System-Notifications | |
| `esp_log` | **NEU** (zu implementieren) | Nach ESP-Log-Empfang | |

#### 10.3.3 Filter-System (manager.py:174-215)

```python
# Client-Subscription mit Filtern
filters = {
    "types": ["sensor_data", "esp_health"],  # Nur diese Types
    "esp_ids": ["ESP_12AB34CD"],              # Nur diese ESPs
    "sensor_types": ["ph", "temperature"],    # Nur diese Sensor-Typen
}

# Matching-Logik
def matchesFilters(message, filters):
    # 1. Type-Filter (Whitelist)
    if filters.types and message.type not in filters.types:
        return False

    # 2. ESP-ID-Filter
    if filters.esp_ids and message.data.esp_id not in filters.esp_ids:
        return False

    # 3. Sensor-Type-Filter
    if filters.sensor_types and message.data.sensor_type not in filters.sensor_types:
        return False

    return True
```

---

### 10.4 Frontend → Server Kommunikation

#### 10.4.1 REST API Authentication

**JWT-Flow (websocket.ts:89-144):**
```typescript
// Token-Extraction aus JWT
const payload = JSON.parse(atob(token.split('.')[1]))
this.tokenExpiry = payload.exp * 1000  // ms

// Token-Refresh vor Reconnect
private async refreshTokenIfNeeded(): Promise<boolean> {
  if (!this.isTokenExpired()) return true

  await authStore.refreshTokens()
  return true
}
```

#### 10.4.2 WebSocket-Reconnection (websocket.ts:237-266)

```typescript
// Exponential Backoff mit Jitter
const exponentialDelay = Math.min(
  this.baseReconnectDelay * Math.pow(2, this.reconnectAttempts - 1),  // 1s, 2s, 4s, 8s...
  this.maxReconnectDelay  // max 30s
)
const jitter = exponentialDelay * 0.1 * (Math.random() * 2 - 1)  // ±10%
const delay = Math.round(exponentialDelay + jitter)

// Max 10 Attempts
if (this.reconnectAttempts < this.maxReconnectAttempts) {
  this.scheduleReconnect()
}
```

#### 10.4.3 Visibility-Handling (websocket.ts:272-314)

```typescript
// Tab-Wechsel → Auto-Reconnect
document.addEventListener('visibilitychange', async () => {
  if (document.visibilityState === 'visible') {
    if (!this.isConnected() && this.status !== 'connecting') {
      await this.refreshTokenIfNeeded()
      this.connect()
    }
  }
})
```

---

### 10.5 Server-Zentrisches Prinzip

#### 10.5.1 Architektur-Grundsatz

```
┌───────────────────────────────────────────────────────────────────────┐
│                           GOD-KAISER SERVER                            │
│                                                                        │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐                │
│  │   Logic     │    │   Sensor    │    │   Safety    │                │
│  │   Engine    │    │   Libraries │    │   Service   │                │
│  │             │    │             │    │             │                │
│  │ Cross-ESP   │    │ Pi-Enhanced │    │ Emergency   │                │
│  │ Automation  │    │ Processing  │    │ Validation  │                │
│  └─────────────┘    └─────────────┘    └─────────────┘                │
│                                                                        │
│                    ↑ Alle Entscheidungen hier ↑                        │
└───────────────────────────────────────────────────────────────────────┘
                              ↕ MQTT
┌───────────────────────────────────────────────────────────────────────┐
│                            ESP32 (DUMM)                                │
│                                                                        │
│  • Liest Sensoren aus (RAW-Daten)                                      │
│  • Führt Befehle aus (keine eigene Logik)                              │
│  • Speichert Config (keine Business-Rules)                             │
│  • Emergency-Stop (einzige lokale Entscheidung!)                       │
└───────────────────────────────────────────────────────────────────────┘
```

#### 10.5.2 Entscheidungs-Matrix

| Entscheidung | Wer entscheidet | Code-Location |
|--------------|-----------------|---------------|
| Sensor-Kalibrierung | **Server** | sensor_libraries/active/*.py |
| Actuator-Aktivierung | **Server** | actuator_service.py → MQTT Command |
| Cross-ESP-Logic | **Server** | logic_engine.py |
| Zone-Assignment | **Server** | zone_service.py |
| Value-Validierung | **Server** | safety_service.py |
| **Emergency-Stop** | **ESP32** | safety_controller.cpp (einzige Ausnahme!) |
| GPIO-Conflict-Check | **ESP32** | gpio_manager.cpp (Hardware-Protection) |

#### 10.5.3 ESP32 Fallback-Verhalten (Server offline)

**Was passiert wenn Server offline ist:**

1. **Heartbeat:** Geht in Offline-Buffer (max 100), Retry mit Backoff
2. **Sensor-Daten:** Geht in Offline-Buffer, werden bei Reconnect nachgeliefert
3. **Actuator-Commands:** **KEINE neuen Commands möglich!**
4. **Laufende Aktoren:** Bleiben aktiv bis:
   - Timeout-Protection greift (MAX_RUNTIME)
   - Emergency-Stop manuell ausgelöst wird
   - Strom ausfällt

**Kritische Erkenntnis:**
```
ESP32 KANN NICHT eigenständig entscheiden, Aktoren abzuschalten
(außer Emergency-Stop). Das ist Absicht - Server-Centric Design.
```

---

### 10.6 QoS-Level Übersicht

| Message-Typ | QoS | Begründung |
|-------------|-----|------------|
| Heartbeat | 0 | Best-effort, regelmäßig gesendet |
| Sensor-Daten | 0/1 | Depends on criticality, meist 0 |
| Actuator-Status | 1 | Wichtig für State-Tracking |
| Actuator-Command | 1 | Muss ankommen! |
| Config-Update | 2 | Exactly-once, kritisch |
| Emergency-Stop | 1 | Muss ankommen, mit Retain |
| Last-Will | 1 | Mit Retain für offline-Status |
| ESP-Log (NEU) | 0 | Best-effort, bandwidth-optimiert |

---

### 10.7 Timing-Konstanten Referenz

| Konstante | Wert | Datei:Zeile |
|-----------|------|-------------|
| `HEARTBEAT_INTERVAL_MS` | 60000 (60s) | mqtt_client.h:108 |
| `HEARTBEAT_TIMEOUT_SECONDS` | 300 (5min) | heartbeat_handler.py:37 |
| `RECONNECT_BASE_DELAY_MS` | 1000 (1s) | mqtt_client.cpp:18 |
| `RECONNECT_MAX_DELAY_MS` | 60000 (60s) | mqtt_client.cpp:19 |
| `MAX_RECONNECT_ATTEMPTS` | 10 | mqtt_client.cpp:20 |
| `MAX_OFFLINE_MESSAGES` | 100 | mqtt_client.h (implied) |
| `measurement_interval_` | 30000 (30s) default | sensor_manager.cpp:33 |
| `actuator_status_interval` | 30000 (30s) | main.cpp:1088 |
| `rate_limit_window` | 1000 (1s) | manager.py:38 |
| `rate_limit_max` | 10 msg/sec | manager.py:39 |
| `baseReconnectDelay` | 1000 (1s) | websocket.ts:49 |
| `maxReconnectDelay` | 30000 (30s) | websocket.ts:50 |
| `maxReconnectAttempts` | 10 | websocket.ts:48 |

---

### 10.8 FAQ für Entwickler

**Q: Ich will einen neuen Sensor-Typ hinzufügen - welche Kommunikation muss ich anpassen?**
A: Keine MQTT-Änderung nötig! Das generische Topic `sensor/{gpio}/data` funktioniert für alle Sensor-Typen. Du musst:
1. Sensor-Library in `sensor_libraries/active/` erstellen (Server)
2. Optional: Sensor-Driver in `sensor_drivers/` (ESP32) wenn Hardware-spezifisch

**Q: Ein ESP geht offline - was passiert mit pending Actuator-Commands?**
A: Commands werden NICHT gepuffert! Sie werden sofort mit Error abgelehnt (`MQTT publish failed`). Laufende Aktoren bleiben aktiv bis Timeout-Protection greift.

**Q: Ich will das Heartbeat-Interval ändern - wo?**
A: `mqtt_client.h:108` → `HEARTBEAT_INTERVAL_MS`. Aber Vorsicht:
- Zu kurz: Mehr Traffic, mehr Server-Last
- Zu lang: Langsamere Offline-Detection (min. 5 Minuten wegen `HEARTBEAT_TIMEOUT_SECONDS`)

**Q: Wann genau wird ein WebSocket-Event gebroadcasted?**
A: NACH dem DB-Insert/Commit. Beispiel aus sensor_handler.py:
```python
await session.commit()  # Erst DB

# Dann WebSocket (best-effort)
try:
    ws_manager = await WebSocketManager.get_instance()
    await ws_manager.broadcast("sensor_data", {...})
except Exception as e:
    logger.warning(f"Failed to broadcast: {e}")  # Kein Failure!
```

**Q: Welche QoS-Level werden für welche Topics verwendet?**
A: Siehe Section 10.6. Kurzfassung:
- **QoS 0:** Heartbeat, Sensor-Daten (meist), Logs
- **QoS 1:** Actuator-Commands, Status-Updates, Emergency
- **QoS 2:** Config-Updates (exactly-once wichtig!)
