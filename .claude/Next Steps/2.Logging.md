# DEV-BRIEFING 02: Logging-Infrastruktur

> **Ziel:** Menschenverständliche Logs (Server, MQTT, ESP-Errors, Debug) zentral im Frontend anzeigen
> **Priorität:** HOCH - Essentiell für Debugging und Monitoring
> **Geschätzter Aufwand:** 2-3 Entwicklertage

---

## 1. Problemstellung

### 1.1 Aktuelle Situation

Das System hat bereits grundlegende Logging-Komponenten:
- **Server-Logs:** Python `logging` in Dateien und Konsole ✅ VOLLSTÄNDIG
- **MQTT-Nachrichten:** MqttLogView zeigt WebSocket-Events ✅ VOLLSTÄNDIG
- **ESP-Logs:** Logger-Klasse existiert, aber **KEIN MQTT-Topic für Logs** ❌ LÜCKE

**Kritische Erkenntnisse aus Code-Analyse:**
- ❌ **ESP32 hat KEIN dediziertes Log-Topic** - Logs werden nur lokal gespeichert und über Serial ausgegeben
- ❌ **Server hat KEINEN log_handler.py** - Es gibt 11 Handler, aber keinen für ESP-Logs
- ❌ **WebSocket hat KEINEN `esp_log` Event-Type** - Nur 5 Typen definiert
- ❌ **AuditLog hat KEINEN `ESP_LOG` Event-Type** - 13 Event-Types, aber keinen für ESP-Logs
- ✅ **Logger-Klasse auf ESP32 existiert** - Circular Buffer mit 50 Einträgen
- ✅ **TopicBuilder ist erweiterbar** - Muster für neue Topics vorhanden

### 1.2 Gewünschter Zustand

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Frontend: Unified Log Center                     │
├─────────────────────────────────────────────────────────────────────┤
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌─────────┐ │
│  │ Server Logs  │  │  MQTT Logs   │  │  ESP Logs    │  │ Errors  │ │
│  │              │  │              │  │              │  │         │ │
│  │ - INFO       │  │ - sensor     │  │ - DEBUG      │  │ - 1xxx  │ │
│  │ - WARNING    │  │ - actuator   │  │ - INFO       │  │ - 2xxx  │ │
│  │ - ERROR      │  │ - heartbeat  │  │ - WARNING    │  │ - 3xxx  │ │
│  │ - DEBUG      │  │ - config     │  │ - ERROR      │  │ - 4xxx  │ │
│  └──────────────┘  └──────────────┘  └──────────────┘  └─────────┘ │
│                                                                     │
│  [Filter: ESP-ID] [Filter: Level] [Filter: Zeit] [Suche: ______]   │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 2. Systemverständnis (PFLICHTLEKTÜRE)

**Bevor du Code schreibst, lies diese Dokumentation:**

| Dokument | Pfad | Relevanz |
|----------|------|----------|
| **CLAUDE.md** | `.claude/CLAUDE.md` | Error-Codes (Section 5) |
| **CLAUDE_SERVER.md** | `.claude/CLAUDE_SERVER.md` | Server-Logging, MQTT-Handler |
| **Hierarchie.md** | `Hierarchie.md` | Kommunikationsflüsse |
| **MQTT-Protokoll** | `El Trabajante/docs/Mqtt_Protocoll.md` | Log-Topic-Struktur |
| **View-Summary** | `El Frontend/Docs/02-Individual-Views-Summary.md` | MqttLogView, LogViewerView |

---

## 3. Codebase-Analyse (VOLLSTÄNDIG VERIFIZIERT)

### 3.1 ESP32 Log-System

#### 3.1.1 Logger-Klasse (VOLLSTÄNDIG IMPLEMENTIERT)

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `logger.h` | `El Trabajante/src/utils/logger.h` | ~105 | ✅ Vollständig |
| `logger.cpp` | `El Trabajante/src/utils/logger.cpp` | ~195 | ✅ Vollständig |

**Log-Levels (logger.h:9-15):**
```cpp
enum LogLevel {
  LOG_DEBUG = 0,
  LOG_INFO = 1,
  LOG_WARNING = 2,
  LOG_ERROR = 3,
  LOG_CRITICAL = 4
};
```

**LogEntry-Struktur (logger.h:20-24):**
```cpp
struct LogEntry {
  unsigned long timestamp;      // millis() Timestamp
  LogLevel level;               // Log-Level Enum
  char message[128];            // Fixed-Size Buffer (kein Heap!)
};
```

**Wichtige Methoden:**

| Methode | Datei:Zeile | Beschreibung |
|---------|-------------|--------------|
| `getInstance()` | logger.cpp:11-14 | Singleton-Pattern |
| `begin()` | logger.cpp:32-39 | Initialisierung (Startup-Message) |
| `log(LogLevel, const char*)` | logger.cpp:65-78 | Primäre Log-API |
| `debug/info/warning/error/critical()` | logger.cpp:80-98 | Level-spezifische Wrapper |
| `getLogs(LogLevel, size_t)` | logger.cpp:111-132 | Logs mit Filter abrufen |
| `clearLogs()` | logger.cpp:103-109 | Log-Buffer leeren |
| `getLogCount()` | logger.cpp:134-136 | Anzahl Logs |
| `getLogLevelString(LogLevel)` | logger.cpp:145-154 | Enum → String |
| `getLogLevelFromString(const char*)` | logger.cpp:156-163 | String → Enum |

**Interne Buffer-Verwaltung (logger.cpp:176-193):**
- **Buffer-Größe:** 50 Einträge (`MAX_LOG_ENTRIES`, logger.h:81)
- **Circular Buffer:** `log_buffer_index_` für Schreibposition
- **Timestamp-Quelle:** `millis()` (logger.cpp:181)
- **Message-Truncation:** `strncpy()` mit Null-Terminator (logger.cpp:183-184)

**Serial-Output-Format (logger.cpp:168-174):**
```
[  123456] [ERROR   ] GPIO pin already in use
```

**Convenience-Makros (logger.h:99-103):**
```cpp
#define LOG_DEBUG(msg)    logger.debug(msg)
#define LOG_INFO(msg)     logger.info(msg)
#define LOG_WARNING(msg)  logger.warning(msg)
#define LOG_ERROR(msg)    logger.error(msg)
#define LOG_CRITICAL(msg) logger.critical(msg)
```

**Globale Instanz:**
- logger.h:94: `extern Logger& logger;`
- logger.cpp:6: `Logger& logger = Logger::getInstance();`

#### 3.1.2 Error-Codes (VOLLSTÄNDIG IMPLEMENTIERT)

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `error_codes.h` | `El Trabajante/src/models/error_codes.h` | ~335 | ✅ Vollständig |

**Error-Code-Bereiche:**

| Bereich | Range | Kategorie | Beispiele |
|---------|-------|-----------|-----------|
| **HARDWARE** | 1000-1999 | GPIO, I2C, OneWire, PWM, Sensor, Actuator | `ERROR_GPIO_RESERVED (1001)` |
| **SERVICE** | 2000-2999 | NVS, Config, Logger, Storage, Subzone | `ERROR_NVS_INIT_FAILED (2001)` |
| **COMMUNICATION** | 3000-3999 | WiFi, MQTT, HTTP, Network, DNS | `ERROR_MQTT_CONNECT_FAILED (3011)` |
| **APPLICATION** | 4000-4999 | State, Operation, Command, Payload, Memory | `ERROR_STATE_INVALID (4001)` |

**Wichtige Hardware-Codes (error_codes.h:12-35):**
```cpp
#define ERROR_GPIO_RESERVED         1001   // Pin bereits reserviert
#define ERROR_GPIO_CONFLICT         1002   // GPIO-Konflikt
#define ERROR_GPIO_INIT_FAILED      1003   // Hardware-Init fehlgeschlagen
#define ERROR_I2C_INIT_FAILED       1010   // I2C-Initialisierung fehlgeschlagen
#define ERROR_I2C_DEVICE_NOT_FOUND  1011   // I2C-Gerät nicht gefunden
#define ERROR_SENSOR_READ_FAILED    1040   // Sensor antwortet nicht
#define ERROR_SENSOR_INIT_FAILED    1041   // Sensor-Init fehlgeschlagen
#define ERROR_ACTUATOR_SET_FAILED   1050   // Aktor-Command fehlgeschlagen
#define ERROR_ACTUATOR_INIT_FAILED  1051   // Aktor-Init fehlgeschlagen
```

**Subzone-spezifische Codes (error_codes.h:48-56):**
```cpp
#define ERROR_SUBZONE_INVALID_ID          2500
#define ERROR_SUBZONE_GPIO_CONFLICT       2501
#define ERROR_SUBZONE_PARENT_MISMATCH     2502
#define ERROR_SUBZONE_NOT_FOUND           2503
#define ERROR_SUBZONE_GPIO_INVALID        2504
#define ERROR_SUBZONE_SAFE_MODE_FAILED    2505
#define ERROR_SUBZONE_CONFIG_SAVE_FAILED  2506
```

**Kommunikations-Codes (error_codes.h:58-75):**
```cpp
#define ERROR_MQTT_INIT_FAILED      3010
#define ERROR_MQTT_CONNECT_FAILED   3011
#define ERROR_MQTT_PUBLISH_FAILED   3012
#define ERROR_MQTT_SUBSCRIBE_FAILED 3013
#define ERROR_MQTT_DISCONNECT       3014
#define ERROR_MQTT_BUFFER_FULL      3015
#define ERROR_MQTT_PAYLOAD_INVALID  3016
```

**Helper-Funktionen:**

| Funktion | Datei:Zeile | Beschreibung |
|----------|-------------|--------------|
| `getErrorDescription(uint16_t)` | error_codes.h:205-323 | Error-Code → lesbare Beschreibung |
| `getErrorCodeRange(uint16_t)` | error_codes.h:326-332 | Error-Code → Kategorie-String |

**ConfigErrorCode Enum (error_codes.h:139-149):**
```cpp
enum class ConfigErrorCode : uint8_t {
  NONE = 0,
  JSON_PARSE_ERROR,
  VALIDATION_FAILED,
  GPIO_CONFLICT,
  NVS_WRITE_FAILED,
  TYPE_MISMATCH,
  MISSING_FIELD,
  OUT_OF_RANGE,
  UNKNOWN_ERROR
};
```

#### 3.1.3 TopicBuilder (KEIN LOG-TOPIC VORHANDEN!)

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `topic_builder.h` | `El Trabajante/src/utils/topic_builder.h` | ~85 | ✅ Vollständig |
| `topic_builder.cpp` | `El Trabajante/src/utils/topic_builder.cpp` | ~200 | ⚠️ Kein Log-Topic |

**Statische Konfiguration (topic_builder.cpp:7-9):**
```cpp
char TopicBuilder::topic_buffer_[256];           // 256-Byte Buffer
char TopicBuilder::esp_id_[32] = "unknown";      // Default ESP-ID
char TopicBuilder::kaiser_id_[64] = "god";       // Default Kaiser-ID
```

**Vorhandene Topics (13 Patterns):**

| # | Methode | Topic-Format |
|---|---------|--------------|
| 1 | `buildSensorDataTopic(gpio)` | `kaiser/{kaiser}/esp/{esp}/sensor/{gpio}/data` |
| 2 | `buildSensorBatchTopic()` | `kaiser/{kaiser}/esp/{esp}/sensor/batch` |
| 3 | `buildActuatorCommandTopic(gpio)` | `kaiser/{kaiser}/esp/{esp}/actuator/{gpio}/command` |
| 4 | `buildActuatorStatusTopic(gpio)` | `kaiser/{kaiser}/esp/{esp}/actuator/{gpio}/status` |
| 5 | `buildActuatorResponseTopic(gpio)` | `kaiser/{kaiser}/esp/{esp}/actuator/{gpio}/response` |
| 6 | `buildActuatorAlertTopic(gpio)` | `kaiser/{kaiser}/esp/{esp}/actuator/{gpio}/alert` |
| 7 | `buildActuatorEmergencyTopic()` | `kaiser/{kaiser}/esp/{esp}/actuator/emergency` |
| 8 | `buildSystemHeartbeatTopic()` | `kaiser/{kaiser}/esp/{esp}/system/heartbeat` |
| 9 | `buildSystemCommandTopic()` | `kaiser/{kaiser}/esp/{esp}/system/command` |
| 10 | `buildSystemDiagnosticsTopic()` | `kaiser/{kaiser}/esp/{esp}/system/diagnostics` |
| 11 | `buildConfigTopic()` | `kaiser/{kaiser}/esp/{esp}/config` |
| 12 | `buildConfigResponseTopic()` | `kaiser/{kaiser}/esp/{esp}/config_response` |
| 13 | `buildBroadcastEmergencyTopic()` | `kaiser/broadcast/emergency` |

**Subzone-Topics (topic_builder.cpp:155-190):**
```cpp
buildSubzoneAssignTopic()   → kaiser/{kaiser}/esp/{esp}/subzone/assign
buildSubzoneRemoveTopic()   → kaiser/{kaiser}/esp/{esp}/subzone/remove
buildSubzoneAckTopic()      → kaiser/{kaiser}/esp/{esp}/subzone/ack
buildSubzoneStatusTopic()   → kaiser/{kaiser}/esp/{esp}/subzone/status
buildSubzoneSafeTopic()     → kaiser/{kaiser}/esp/{esp}/subzone/safe
```

**❌ FEHLT: `buildSystemLogTopic()` für ESP-Logs!**

**Erforderliche Änderung (topic_builder.h):**
```cpp
// NEU HINZUFÜGEN:
static const char* buildSystemLogTopic();
// Generiert: kaiser/{kaiser}/esp/{esp}/system/log
```

**Erforderliche Änderung (topic_builder.cpp):**
```cpp
const char* TopicBuilder::buildSystemLogTopic() {
  int written = snprintf(topic_buffer_, sizeof(topic_buffer_),
                         "kaiser/%s/esp/%s/system/log",
                         kaiser_id_, esp_id_);
  return validateTopicBuffer(written);
}
```

#### 3.1.4 MQTT-Client (KEIN LOG-PUBLISH!)

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `mqtt_client.h` | `El Trabajante/src/services/communication/mqtt_client.h` | ~145 | ✅ Vollständig |
| `mqtt_client.cpp` | `El Trabajante/src/services/communication/mqtt_client.cpp` | ~600 | ⚠️ Kein Log-Publish |

**Vorhandene Publish-Methoden:**

| Methode | Datei:Zeile | Beschreibung |
|---------|-------------|--------------|
| `publish(topic, payload, qos)` | mqtt_client.cpp:298-358 | Basis-Publish mit Circuit Breaker |
| `safePublish(topic, payload, qos, retries)` | mqtt_client.cpp:360-385 | Publish mit Retry |
| `publishHeartbeat()` | mqtt_client.cpp:435-466 | System-Heartbeat (60s Interval) |

**Heartbeat-Payload (mqtt_client.cpp:451-462):**
```json
{
  "esp_id": "ESP_12AB34CD",
  "zone_id": "zelt_1",
  "master_zone_id": "master",
  "zone_assigned": true,
  "ts": 1234567890,
  "uptime": 3600,
  "heap_free": 102400,
  "wifi_rssi": -45,
  "sensor_count": 3,
  "actuator_count": 2
}
```

**Circuit-Breaker-Konfiguration (mqtt_client.cpp:54-58):**
```cpp
circuit_breaker_("MQTT", 5, 30000, 10000)
// - Name: "MQTT"
// - Failure Threshold: 5 Fehler
// - Recovery Timeout: 30 Sekunden
// - Half-Open Test: 10 Sekunden
```

**Offline-Buffer (mqtt_client.h:95-97):**
```cpp
static const uint16_t MAX_OFFLINE_MESSAGES = 100;
MQTTMessage offline_buffer_[MAX_OFFLINE_MESSAGES];
uint16_t offline_buffer_count_;
```

**❌ FEHLT: `publishLog()` Methode für ESP-Logs!**

**Erforderliche Änderung (mqtt_client.h):**
```cpp
// NEU HINZUFÜGEN:
bool publishLog(LogLevel level, const char* module, const char* message,
                uint16_t error_code = 0, const char* details_json = nullptr);
```

**Erforderliche Änderung (mqtt_client.cpp):**
```cpp
bool MQTTClient::publishLog(LogLevel level, const char* module, const char* message,
                            uint16_t error_code, const char* details_json) {
    const char* topic = TopicBuilder::buildSystemLogTopic();

    String payload = "{";
    payload += "\"ts\":" + String((unsigned long)timeManager.getUnixTimestamp()) + ",";
    payload += "\"esp_id\":\"" + g_system_config.esp_id + "\",";
    payload += "\"level\":\"" + String(Logger::getLogLevelString(level)) + "\",";
    payload += "\"module\":\"" + String(module) + "\",";
    payload += "\"message\":\"" + String(message) + "\"";

    if (error_code > 0) {
        payload += ",\"error_code\":" + String(error_code);
        payload += ",\"error_description\":\"" + String(getErrorDescription(error_code)) + "\"";
    }

    if (details_json != nullptr) {
        payload += ",\"details\":" + String(details_json);
    }

    payload += "}";

    // QoS 0 für Logs (best-effort)
    return publish(topic, payload, 0);
}
```

> ⚠️ **VERIFIZIERT (2026-01-05) - publishLog() Aufruf-Integration:**
>
> **Analyse des bestehenden Systems:**
> - `publishHeartbeat()` wird automatisch in `loop()` aufgerufen (mqtt_client.cpp:484)
> - `LOG_ERROR(msg)` Makro ruft nur `logger.error(msg)` auf (logger.h:102)
> - Logger schreibt nur in Serial und Circular Buffer - **KEIN automatischer MQTT-Publish!**
>
> **Entscheidung: EXPLIZITER AUFRUF (nicht automatisch)**
>
> Die `publishLog()` Methode soll **explizit** vom Entwickler aufgerufen werden, NICHT automatisch bei jedem LOG_ERROR. Gründe:
> - Bandbreiten-Kontrolle: Nicht jeder lokale Log ist wichtig genug für MQTT
> - Entwickler-Kontrolle: Welche Logs zum Server gehen sollen, entscheidet der Code
> - Performance: Automatisches Publishing würde die loop() verlangsamen
>
> **Beispiel-Verwendung in main.cpp:**
> ```cpp
> // Beispiel 1: Kritischer Fehler mit Error-Code
> if (sensorResult == ERROR_SENSOR_READ_FAILED) {
>     LOG_ERROR("Sensor read failed on GPIO 4");
>     mqttClient.publishLog(LOG_ERROR, "sensor_manager", "Sensor read failed on GPIO 4",
>                           ERROR_SENSOR_READ_FAILED, "{\"gpio\":4}");
> }
>
> // Beispiel 2: System-Startup Log
> void setup() {
>     // ... init code ...
>     mqttClient.publishLog(LOG_INFO, "system", "ESP32 boot complete");
> }
>
> // Beispiel 3: Actuator-Fehler
> if (!actuatorManager.executeCommand(gpio, command)) {
>     mqttClient.publishLog(LOG_ERROR, "actuator_manager", "Command execution failed",
>                           ERROR_ACTUATOR_SET_FAILED, nullptr);
> }
> ```
>
> **Alternative (NICHT EMPFOHLEN):** Automatischer Publish bei LOG_ERROR/LOG_CRITICAL
> würde Änderungen in logger.cpp erfordern und ist weniger flexibel.

---

### 3.2 Server Log-System

#### 3.2.1 Core Logging Config (VOLLSTÄNDIG IMPLEMENTIERT)

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `logging_config.py` | `El Servador/god_kaiser_server/src/core/logging_config.py` | ~140 | ✅ Vollständig |

**Klassen und Funktionen:**

| Komponente | Datei:Zeile | Beschreibung |
|------------|-------------|--------------|
| `JSONFormatter` | logging_config.py:15-46 | JSON-Format für strukturiertes Logging |
| `TextFormatter` | logging_config.py:49-62 | Text-Format für Konsole |
| `setup_logging()` | logging_config.py:65-126 | Haupt-Konfigurationsfunktion |
| `get_logger(name)` | logging_config.py:128-138 | Logger-Instanz abrufen |

**JSONFormatter.format() (logging_config.py:22-46):**
```python
log_record = {
    "timestamp": self.formatTime(record, self.datefmt),
    "level": record.levelname,
    "logger": record.name,
    "message": record.getMessage(),
    "module": record.module,
    "function": record.funcName,
    "line": record.lineno,
}
# Exception-Info und Extra-Fields werden hinzugefügt
```

**setup_logging() Ablauf (logging_config.py:65-126):**
1. Log-Verzeichnis erstellen (Zeile 76)
2. Root-Logger konfigurieren (Zeile 80-92)
3. `RotatingFileHandler` erstellen (Zeile 95-103)
4. `StreamHandler` für Konsole erstellen (Zeile 106-115)
5. Externe Libraries leiser stellen (Zeile 118-120)

**Konfiguration aus Settings:**
- `settings.logging.level` - Log-Level (DEBUG, INFO, WARNING, ERROR)
- `settings.logging.format` - Format (JSON oder text)
- `settings.logging.file_path` - Pfad zur Log-Datei
- `settings.logging.file_max_bytes` - Max Dateigröße vor Rotation
- `settings.logging.file_backup_count` - Anzahl Backup-Dateien

#### 3.2.2 MQTT-Handler (KEIN LOG-HANDLER!)

| Verzeichnis | Pfad | Status |
|-------------|------|--------|
| `handlers/` | `El Servador/god_kaiser_server/src/mqtt/handlers/` | ⚠️ Kein log_handler.py |

**Vorhandene Handler (11 + 1 Base):**

| Handler | Datei | MQTT-Topic |
|---------|-------|------------|
| `BaseMQTTHandler` | `base_handler.py` | (Abstract Base) |
| `SensorDataHandler` | `sensor_handler.py` | `kaiser/{id}/esp/+/sensor/+/data` |
| `ActuatorStatusHandler` | `actuator_handler.py` | `kaiser/{id}/esp/+/actuator/+/status` |
| `ActuatorResponseHandler` | `actuator_response_handler.py` | `kaiser/{id}/esp/+/actuator/+/response` |
| `ActuatorAlertHandler` | `actuator_alert_handler.py` | `kaiser/{id}/esp/+/actuator/+/alert` |
| `HeartbeatHandler` | `heartbeat_handler.py` | `kaiser/{id}/esp/+/system/heartbeat` |
| `ConfigHandler` | `config_handler.py` | `kaiser/{id}/esp/+/config_response` |
| `ZoneAckHandler` | `zone_ack_handler.py` | `kaiser/{id}/esp/+/zone/ack` |
| `SubzoneAckHandler` | `subzone_ack_handler.py` | `kaiser/{id}/esp/+/subzone/ack` |
| `DiscoveryHandler` | `discovery_handler.py` | `kaiser/{id}/discovery/esp32_nodes` (legacy) |
| `KaiserHandler` | `kaiser_handler.py` | (geplant) |

**❌ FEHLT: `log_handler.py` für ESP-Logs!**

#### 3.2.3 Handler-Patterns (WICHTIG!)

> **ACHTUNG:** Es gibt ZWEI verschiedene Handler-Patterns im Server:
>
> 1. **BaseMQTTHandler (base_handler.py)** - Abstrakte Basis-Klasse mit DB-Injection
>    - Wird aktuell NICHT von den Handler-Implementierungen genutzt!
>    - Erfordert `db: AsyncSession` im Constructor
>
> 2. **HeartbeatHandler-Pattern (TATSÄCHLICH GENUTZT)** - Eigene Klassen mit `resilient_session()`
>    - Singleton-Pattern mit `get_xxx_handler()`
>    - Nutzt `resilient_session()` für DB-Zugriff
>    - Nutzt `WebSocketManager.get_instance()` für Broadcasts
>    - **Dies ist das Pattern für den ESPLogHandler!**

**BaseMQTTHandler Referenz (wird NICHT für ESPLogHandler verwendet):**

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `base_handler.py` | `El Servador/god_kaiser_server/src/mqtt/handlers/base_handler.py` | ~570 | ✅ Vollständig |

**Wichtige Datenklassen:**

**ValidationResult (base_handler.py:43-80):**
```python
@dataclass
class ValidationResult:
    valid: bool
    error_code: Optional[int] = None
    error_message: Optional[str] = None
    errors: List[FieldError] = field(default_factory=list)
    data: Any = None

    @classmethod
    def success(cls, data: Any = None) -> "ValidationResult": ...

    @classmethod
    def failure(cls, error_code: int, error_message: str) -> "ValidationResult": ...
```

**TopicParseResult (base_handler.py:83-115):**
```python
@dataclass
class TopicParseResult:
    valid: bool
    kaiser_id: Optional[str] = None
    esp_id: Optional[str] = None
    extra: Dict[str, Any] = field(default_factory=dict)
    error: Optional[str] = None
```

**Handler-Flow (base_handler.py:186-238):**
```python
async def handle(self, topic: str, payload: Dict[str, Any]) -> bool:
    # 1. Topic parsen (Zeile 200)
    topic_result = self.parse_topic(topic)

    # 2. Payload validieren (Zeile 206)
    validation = self.validate_payload(payload)

    # 3. ESP-Device nachschlagen (Zeile 218)
    esp_device = await self._get_esp_device(topic_result.esp_id)

    # 4. Message verarbeiten (Zeile 228)
    await self.process_message(topic_result, payload, esp_device)

    # Error-Isolation: Exceptions werden gefangen (Zeile 233)
```

**Abstrakte Methoden (MÜSSEN implementiert werden):**
- `parse_topic(topic: str) → TopicParseResult`
- `validate_payload(payload: Dict) → ValidationResult`
- `process_message(topic_result, payload, esp_device) → async void`

**Helper-Methoden für Validierung:**

| Methode | Datei:Zeile | Beschreibung |
|---------|-------------|--------------|
| `validate_required_fields()` | base_handler.py:291-321 | Pflichtfelder prüfen |
| `validate_field_type()` | base_handler.py:323-352 | Typ-Validierung |
| `validate_string_field()` | base_handler.py:354-393 | String-Validierung |
| `validate_numeric_field()` | base_handler.py:395-427 | Numerische Validierung |

**WebSocket-Broadcast-Methoden:**

| Methode | Datei:Zeile | Beschreibung |
|---------|-------------|--------------|
| `broadcast_event(type, data)` | base_handler.py:460-476 | Event an alle Clients |
| `broadcast_to_esp(esp_id, type, data)` | base_handler.py:478-493 | Event an ESP-spezifische Clients |

**Audit-Logging-Methoden:**

| Methode | Datei:Zeile | Beschreibung |
|---------|-------------|--------------|
| `_log_validation_error()` | base_handler.py:499-517 | Validation-Fehler loggen |
| `_log_processing_error()` | base_handler.py:519-536 | Processing-Fehler loggen |
| `log_device_event()` | base_handler.py:538-565 | Generische Event-Logs |

#### 3.2.4 MQTT-Subscriber (HANDLER-REGISTRIERUNG)

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `subscriber.py` | `El Servador/god_kaiser_server/src/mqtt/subscriber.py` | ~325 | ✅ Vollständig |

**Wichtige Methoden:**

| Methode | Datei:Zeile | Beschreibung |
|---------|-------------|--------------|
| `__init__()` | subscriber.py:34-68 | ThreadPoolExecutor erstellen |
| `register_handler(pattern, handler)` | subscriber.py:82-97 | Handler registrieren |
| `subscribe_all()` | subscriber.py:99-132 | Alle Patterns subscriben |
| `_route_message(topic, payload)` | subscriber.py:147-182 | Message zu Handler routen |
| `_execute_handler(handler, topic, payload)` | subscriber.py:184-245 | Handler ausführen (async/sync) |
| `get_stats()` | subscriber.py:287-305 | Performance-Metriken |

**Handler-Ausführung (subscriber.py:184-245):**
```python
def _execute_handler(self, handler, topic: str, payload: Dict) -> None:
    # Async Handler erkennen (Zeile 202)
    if asyncio.iscoroutinefunction(handler):
        # In MAIN Event-Loop schedulen (Zeile 214)
        future = asyncio.run_coroutine_threadsafe(
            handler(topic, payload),
            self._main_loop
        )
        # 30-Sekunden Timeout (Zeile 221)
        future.result(timeout=30)
```

**QoS-Bestimmung (subscriber.py:119-124):**
```python
def _get_qos_for_pattern(self, pattern: str) -> int:
    if "heartbeat" in pattern:
        return 0  # Best-effort
    elif "config" in pattern:
        return 2  # Exactly-once
    else:
        return 1  # At-least-once
```

#### 3.2.5 Handler-Registrierung in main.py

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `main.py` | `El Servador/god_kaiser_server/src/main.py` | ~350 | ⚠️ Kein Log-Handler |

**Aktuelle Handler-Registrierung (main.py:194-233):**
```python
# Subscriber erstellen (Zeile 181)
_subscriber_instance = Subscriber(max_workers=settings.mqtt.subscriber_max_workers)

# Handler registrieren (Zeile 194-233)
_subscriber_instance.register_handler(
    f"kaiser/{kaiser_id}/esp/+/sensor/+/data",
    sensor_handler.handle_sensor_data
)
_subscriber_instance.register_handler(
    f"kaiser/{kaiser_id}/esp/+/actuator/+/status",
    actuator_handler.handle_actuator_status
)
# ... weitere Handler ...
_subscriber_instance.register_handler(
    f"kaiser/{kaiser_id}/esp/+/subzone/ack",
    subzone_ack_handler.handle_subzone_ack
)
```

**❌ FEHLT: Log-Handler Registrierung:**
```python
# NEU HINZUFÜGEN nach Zeile 233:
_subscriber_instance.register_handler(
    f"kaiser/{kaiser_id}/esp/+/system/log",
    log_handler.handle_esp_log
)
```

#### 3.2.6 WebSocket Manager (KEIN ESP_LOG EVENT-TYPE!)

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `manager.py` | `El Servador/god_kaiser_server/src/websocket/manager.py` | ~310 | ⚠️ Kein esp_log Typ |

**Vorhandene Event-Types:**
- `sensor_data`
- `actuator_status`
- `esp_health`
- `system_event`
- `config_response`

**❌ FEHLT: `esp_log` Event-Type!**

**Wichtige Methoden:**

| Methode | Datei:Zeile | Beschreibung |
|---------|-------------|--------------|
| `get_instance()` | manager.py:41-53 | Singleton-Getter |
| `connect(websocket, client_id)` | manager.py:74-87 | Client verbinden |
| `subscribe(client_id, filters)` | manager.py:126-143 | Client-Filter setzen |
| `broadcast(type, data, esp_id)` | manager.py:174-235 | Event broadcasten |
| `broadcast_threadsafe(type, data, esp_id)` | manager.py:237-256 | Thread-safe Broadcast |

**Broadcast-Methode (manager.py:174-235):**
```python
async def broadcast(
    self,
    message_type: str,
    data: Dict[str, Any],
    esp_id: Optional[str] = None
) -> int:
    message = {
        "type": message_type,
        "timestamp": int(datetime.now(timezone.utc).timestamp()),
        "data": data
    }
    # Client-Filter anwenden (Zeile 194-216)
    # Rate-Limiting prüfen (Zeile 222)
    # Nachricht senden (Zeile 228)
```

**Rate-Limiting (manager.py:258-287):**
- Limit: 10 Messages/Sekunde pro Client
- Sliding-Window-Algorithmus mit `collections.deque`

#### 3.2.7 Database Models (KEIN ESP_LOG MODEL!)

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `audit_log.py` | `El Servador/god_kaiser_server/src/db/models/audit_log.py` | ~235 | ⚠️ Kein ESP_LOG Event |

**AuditLog Model (audit_log.py:26-178):**

| Spalte | Typ | Beschreibung |
|--------|-----|--------------|
| `id` | UUID | Primary Key |
| `event_type` | String(50) | Event-Klassifikation |
| `severity` | String(20) | info/warning/error/critical |
| `source_type` | String(30) | esp32/user/system/api/mqtt/scheduler |
| `source_id` | String(100) | z.B. esp_id |
| `status` | String(20) | success/failed/pending |
| `message` | Text | Lesbare Beschreibung |
| `details` | JSON | Event-spezifische Daten |
| `error_code` | String(50) | Error-Code falls vorhanden |
| `error_description` | Text | Error-Beschreibung |
| `ip_address` | String(45) | Für API/Web-Events |
| `correlation_id` | String(100) | Für Event-Tracing |
| `created_at` | DateTime | Timestamp |

**Vorhandene Event-Types (audit_log.py:182-211):**
```python
class AuditEventType:
    CONFIG_RESPONSE = "config_response"
    CONFIG_PUBLISHED = "config_published"
    CONFIG_FAILED = "config_failed"
    LOGIN_SUCCESS = "login_success"
    LOGIN_FAILED = "login_failed"
    LOGOUT = "logout"
    TOKEN_REVOKED = "token_revoked"
    PERMISSION_DENIED = "permission_denied"
    API_KEY_INVALID = "api_key_invalid"
    RATE_LIMIT_EXCEEDED = "rate_limit_exceeded"
    EMERGENCY_STOP = "emergency_stop"
    SERVICE_START = "service_start"
    SERVICE_STOP = "service_stop"
    DEVICE_REGISTERED = "device_registered"
    DEVICE_OFFLINE = "device_offline"
    MQTT_ERROR = "mqtt_error"
    DATABASE_ERROR = "database_error"
    VALIDATION_ERROR = "validation_error"
```

**❌ FEHLT: `ESP_LOG_MESSAGE = "esp_log_message"`**

**Severity-Konstanten (audit_log.py:214-220):**
```python
class AuditSeverity:
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"
```

**Source-Type-Konstanten (audit_log.py:223-231):**
```python
class AuditSourceType:
    ESP32 = "esp32"
    USER = "user"
    SYSTEM = "system"
    API = "api"
    MQTT = "mqtt"
    SCHEDULER = "scheduler"
```

#### 3.2.8 Audit Log Repository (KEINE ESP-LOG METHODE!)

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `audit_log_repo.py` | `El Servador/god_kaiser_server/src/db/repositories/audit_log_repo.py` | ~420 | ⚠️ Kein log_esp_message |

**Vorhandene Logging-Methoden:**

| Methode | Datei:Zeile | Beschreibung |
|---------|-------------|--------------|
| `log_config_response()` | audit_log_repo.py:54-103 | Config-Response loggen |
| `log_mqtt_error()` | audit_log_repo.py:106-133 | MQTT-Fehler loggen |
| `log_validation_error()` | audit_log_repo.py:136-165 | Validation-Fehler loggen |
| `log_emergency_stop()` | audit_log_repo.py:168-189 | Emergency-Stop loggen |
| `log_device_event()` | audit_log_repo.py:200-238 | Generische Device-Events |

**❌ FEHLT: `log_esp_message()` für ESP-Logs:**
```python
# NEU HINZUFÜGEN:
async def log_esp_message(
    self,
    esp_id: str,
    level: str,
    module: str,
    message: str,
    error_code: Optional[int] = None,
    details: Optional[Dict[str, Any]] = None
) -> AuditLog:
    """ESP32 Log-Nachricht speichern."""
    severity = self._map_esp_level_to_severity(level)

    return await self.create(
        event_type=AuditEventType.ESP_LOG_MESSAGE,
        severity=severity,
        source_type=AuditSourceType.ESP32,
        source_id=esp_id,
        status="success",
        message=message,
        details={
            "module": module,
            "log_level": level,
            **(details or {})
        },
        error_code=str(error_code) if error_code else None,
        error_description=self._get_error_description(error_code) if error_code else None
    )

def _map_esp_level_to_severity(self, level: str) -> str:
    mapping = {
        "DEBUG": AuditSeverity.INFO,
        "INFO": AuditSeverity.INFO,
        "WARNING": AuditSeverity.WARNING,
        "ERROR": AuditSeverity.ERROR,
        "CRITICAL": AuditSeverity.CRITICAL,
    }
    return mapping.get(level.upper(), AuditSeverity.INFO)
```

#### 3.2.9 Debug API (KEIN ESP-LOGS ENDPOINT!)

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `debug.py` | `El Servador/god_kaiser_server/src/api/v1/debug.py` | ~400+ | ⚠️ Kein /esp-logs |

**Vorhandene Endpoints:**

| Endpoint | Methode | Beschreibung |
|----------|---------|--------------|
| `/v1/debug/logs` | GET | Server-Log-Dateien abfragen |
| `/v1/debug/logs/files` | GET | Verfügbare Log-Dateien auflisten |
| `/v1/debug/mock-esp` | POST | Mock-ESP erstellen |
| `/v1/debug/mock-esp/{id}` | PATCH | Mock-ESP aktualisieren |
| `/v1/debug/mock-esp/{id}` | DELETE | Mock-ESP löschen |
| `/v1/debug/mock-esp/{id}/messages` | GET | Mock-ESP Nachrichten |

**❌ FEHLT: `/v1/debug/esp-logs` Endpoint!**

---

### 3.3 Frontend Log-System

#### 3.3.1 MqttLogView (VOLLSTÄNDIG IMPLEMENTIERT)

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `MqttLogView.vue` | `El Frontend/src/views/MqttLogView.vue` | ~285 | ✅ Vollständig |

**Komponenten-Typ:** Real-time WebSocket Message Viewer

**WebSocket-Integration (MqttLogView.vue:19-23, 125-135):**
```typescript
// Singleton-Pattern
const { subscribe, unsubscribe, isConnected } = useWebSocket({
  autoConnect: true,
  autoReconnect: true,
})

// Subscribe zu allen Message-Types
subscribe(
  { types: messageTypes },
  handleWebSocketMessage
)
```

**Unterstützte Event-Types (MqttLogView.vue:44-54):**
```typescript
messageTypes: MessageType[] = [
  'sensor_data',           // Sensor-Messwerte
  'actuator_status',       // Aktor-Zustandsänderungen
  'actuator_response',     // Command-Bestätigungen
  'actuator_alert',        // Emergency/Timeout-Alerts
  'esp_health',            // Device-Health-Info
  'config_response',       // Config-Bestätigungen
  'zone_assignment',       // Zone-ACK-Bestätigungen
  'logic_execution',       // Logic-Rule-Triggers
  'system_event',          // System-Notifications
]
```

**UI-Struktur:**

| Bereich | Zeilen | Beschreibung |
|---------|--------|--------------|
| Header | 141-179 | Connection-Status, Pause/Resume, Filters, Clear |
| Filter-Panel | 181-225 | Multi-Select Checkboxes, ESP-ID, Topic-Contains |
| Message-Display | 233-280 | Scrollable, Max 500 Messages, Collapsible Rows |
| Message-Row | 240-278 | Time, Type-Badge, ESP-ID, Topic, JSON-Payload |

**Message-Struktur (MqttLogView.vue:63-70):**
```typescript
const msg: MqttMessage = {
  id: `${Date.now()}_${Math.random().toString(36).slice(2)}`,
  timestamp: new Date().toISOString(),
  type: (message.type as MessageType) || 'system_event',
  topic: (message.data.topic as string) || '',
  payload: (message.data.payload || message.data) as Record<string, unknown>,
  esp_id: (message.data.esp_id as string) || undefined,
}
```

**Type-Color-Mapping (MqttLogView.vue:100-113):**
```typescript
const typeColors = {
  'sensor_data': 'badge-info',        // Blau
  'actuator_status': 'badge-success', // Grün
  'actuator_response': 'badge-success',
  'actuator_alert': 'badge-danger',   // Rot
  'system_event': 'badge-danger',
  'config_response': 'badge-warning', // Gelb
  'logic_execution': 'badge-warning',
  'esp_health': 'badge-gray',         // Grau
  'zone_assignment': 'badge-gray',
}
```

#### 3.3.2 LogViewerView (VOLLSTÄNDIG IMPLEMENTIERT)

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `LogViewerView.vue` | `El Frontend/src/views/LogViewerView.vue` | ~430 | ✅ Vollständig |

**Komponenten-Typ:** Server-side Log File Viewer mit HTTP-Polling

**HTTP-Polling (LogViewerView.vue:58-114):**
```typescript
// Log-Dateien laden (Zeile 58-69)
async function loadLogFiles(): Promise<void> {
  const response = await logsApi.listFiles()
  logFiles.value = response.files
}

// Logs mit Filtern laden (Zeile 72-97)
async function loadLogs(): Promise<void> {
  const response = await logsApi.queryLogs(currentQueryParams.value)
  logs.value = response.logs
  totalCount.value = response.total_count
  hasMore.value = response.has_more
}

// Real-time Polling alle 3 Sekunden (Zeile 99-114)
function toggleRealtime(): void {
  isRealtime.value = !isRealtime.value
  if (isRealtime.value) {
    realtimeInterval.value = setInterval(() => loadLogs(), 3000)
  }
}
```

**Filter-Capabilities (LogViewerView.vue:17-56):**

| Filter | Typ | Beschreibung |
|--------|-----|--------------|
| `selectedLevel` | LogLevel | DEBUG/INFO/WARNING/ERROR/CRITICAL |
| `moduleFilter` | String | Logger-Modul-Name |
| `searchQuery` | String | Volltext-Suche |
| `selectedFile` | String | Log-Datei-Auswahl |
| `startTime` | ISO 8601 | Zeit-Range Start |
| `endTime` | ISO 8601 | Zeit-Range Ende |
| `page` | Number | Seiten-Nummer |
| `pageSize` | Number | Items pro Seite (default: 100, max: 1000) |

**UI-Struktur:**

| Bereich | Zeilen | Beschreibung |
|---------|--------|--------------|
| Header | 173-205 | Live/Pause Toggle, Refresh Button |
| Filter-Card | 222-318 | File-Selector, Level-Dropdown, Module, Search, Time-Range |
| Logs-Table | 321-424 | Sticky Header, Expandable Rows, Load More |
| Expanded-Details | 366-391 | Module, Function, Line, Full Message, Exception, Extra Data |

**Log-Entry-Struktur:**
```typescript
interface LogEntry {
  timestamp: string
  level: LogLevel
  logger: string        // Modul-Pfad
  message: string
  module?: string
  function?: string
  line?: number
  exception?: string    // Traceback
  extra?: Record<string, unknown>
}
```

#### 3.3.3 WebSocket Service (SINGLETON)

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `websocket.ts` | `El Frontend/src/services/websocket.ts` | ~580 | ✅ Vollständig |

**WebSocket-Konfiguration (websocket.ts:108-112):**
```typescript
// Endpoint: /api/v1/ws/realtime/{client_id}
// Protokoll: ws:// oder wss:// basierend auf Page-Protokoll
// Auth: JWT-Token als URL-Parameter
```

**Reconnection-Strategie (websocket.ts:237-266):**
- Exponential Backoff: 1s, 2s, 4s, 8s, 16s (max 30s)
- Base Delay: 1000ms, Max Delay: 30000ms
- Jitter (±10%) um Thundering Herd zu vermeiden
- Max 10 Reconnect-Versuche

**Rate-Limiting (websocket.ts:337-372):**
- Limit: 10 Messages/Sekunde
- Warning bei Überschreitung

**Filter-Types (websocket.ts:24-29):**
```typescript
interface WebSocketFilters {
  types?: MessageType[]      // Message-Type Whitelist
  esp_ids?: string[]         // Device-ID Whitelist
  sensor_types?: string[]    // Sensor-Type Whitelist
  topicPattern?: string      // Topic Regex Pattern
}
```

**Wichtige Methoden:**

| Methode | Datei:Zeile | Beschreibung |
|---------|-------------|--------------|
| `connect()` | websocket.ts:149-207 | Verbindung herstellen |
| `disconnect()` | websocket.ts:209-225 | Verbindung trennen |
| `subscribe(filters, callback)` | websocket.ts:427-521 | Event-Subscription |
| `unsubscribe(id)` | websocket.ts:523-535 | Subscription entfernen |
| `routeMessage(message)` | websocket.ts:374-421 | Message zu Subscriptions routen |

#### 3.3.4 useWebSocket Composable

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `useWebSocket.ts` | `El Frontend/src/composables/useWebSocket.ts` | ~265 | ✅ Vollständig |

**Reactive State (useWebSocket.ts:37-50):**
```typescript
isConnected: Ref<boolean>
isConnecting: Ref<boolean>
connectionError: Ref<string | null>
connectionStatus: Computed<'connecting'|'connected'|'error'|'disconnected'>
reconnectAttempts: Ref<number>
lastMessage: Ref<WebSocketMessage | null>
messageCount: Ref<number>
rateLimitWarning: Ref<boolean>
activeFilters: Ref<WebSocketFilters | null>
```

**Wichtige Methoden:**

| Methode | Datei:Zeile | Beschreibung |
|---------|-------------|--------------|
| `connect()` | useWebSocket.ts:70-93 | Verbindung herstellen |
| `disconnect()` | useWebSocket.ts:98-107 | Verbindung trennen |
| `subscribe(filters, callback)` | useWebSocket.ts:113-150 | Mit Filtern subscriben |
| `unsubscribe()` | useWebSocket.ts:152-165 | Subscription entfernen |
| `on(type, callback)` | useWebSocket.ts:167-184 | Für spezifischen Type subscriben |
| `cleanup()` | useWebSocket.ts:233-239 | Alles aufräumen |

#### 3.3.5 Logs API Client

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `logs.ts` | `El Frontend/src/api/logs.ts` | ~100 | ✅ Vollständig |

**API-Funktionen (logs.ts:66-96):**
```typescript
// Log-Dateien auflisten
logsApi.listFiles(): Promise<LogFilesResponse>
// GET /debug/logs/files

// Logs mit Filtern abfragen
logsApi.queryLogs(params: LogQueryParams): Promise<LogsResponse>
// GET /debug/logs?level=...&module=...&search=...
```

**Request-Parameter (logs.ts:51-60):**
```typescript
interface LogQueryParams {
  level?: LogLevel              // DEBUG|INFO|WARNING|ERROR|CRITICAL
  module?: string               // Filter nach Logger-Modul
  search?: string               // Volltext-Suche in Messages
  start_time?: string           // ISO 8601 Datetime
  end_time?: string             // ISO 8601 Datetime
  file?: string                 // Log-Dateiname
  page?: number                 // Seiten-Nummer
  page_size?: number            // Items pro Seite (1-1000)
}
```

**Response-Types (logs.ts:27-49):**
```typescript
interface LogsResponse {
  success: boolean
  logs: LogEntry[]
  total_count: number           // Gesamt-Anzahl
  page: number
  page_size: number
  has_more: boolean             // Weitere Seiten vorhanden
}

interface LogFile {
  name: string                  // Dateiname
  path: string                  // Voller Pfad
  size_bytes: number
  size_human: string            // z.B. "2.5 MB"
  modified: string              // Letzte Änderung
  is_current: boolean           // Aktuelle Log-Datei
}
```

#### 3.3.6 Router-Konfiguration

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `index.ts` | `El Frontend/src/router/index.ts` | ~120 | ✅ Vollständig |

**Logging-relevante Routen:**

| Pfad | Name | Komponente | Auth |
|------|------|------------|------|
| `/logs` | `logs` | `LogViewerView.vue` | Admin only |
| `/audit` | `audit` | `AuditLogView.vue` | Authenticated |
| `/mqtt-log` | `mqtt-log` | `MqttLogView.vue` | Authenticated |

**❌ FEHLT: `/log-center` Route für Unified Log Center!**

#### 3.3.7 Type-Definitionen

| Datei | Pfad | Zeilen | Status |
|-------|------|--------|--------|
| `index.ts` | `El Frontend/src/types/index.ts` | ~200 | ⚠️ Kein esp_log |

**WebSocket Message-Types (types/index.ts:161-186):**
```typescript
export type MessageType =
  | 'sensor_data'           // Sensor-Handler
  | 'actuator_status'       // Actuator-Handler
  | 'actuator_response'     // Actuator-Response-Handler
  | 'actuator_alert'        // Actuator-Alert-Handler
  | 'esp_health'            // Heartbeat-Handler
  | 'config_response'       // Config-Handler
  | 'zone_assignment'       // Zone-ACK-Handler
  | 'logic_execution'       // Logic-Engine
  | 'system_event'          // System-Notifications
```

**❌ FEHLT: `| 'esp_log'` für ESP-Logs!**

---

## 4. Status-Zusammenfassung

### Was VOLLSTÄNDIG implementiert ist:

| Komponente | Pfad | Status |
|------------|------|--------|
| ESP32 Logger-Klasse | `El Trabajante/src/utils/logger.*` | ✅ Vollständig |
| ESP32 Error-Codes | `El Trabajante/src/models/error_codes.h` | ✅ Vollständig |
| ESP32 TopicBuilder (ohne Log) | `El Trabajante/src/utils/topic_builder.*` | ✅ Vollständig |
| ESP32 MQTT-Client (ohne publishLog) | `El Trabajante/src/services/communication/mqtt_client.*` | ✅ Vollständig |
| Server Logging-Config | `El Servador/.../core/logging_config.py` | ✅ Vollständig |
| Server MQTT-Subscriber | `El Servador/.../mqtt/subscriber.py` | ✅ Vollständig |
| Server BaseMQTTHandler | `El Servador/.../mqtt/handlers/base_handler.py` | ✅ Vollständig |
| Server AuditLog Model | `El Servador/.../db/models/audit_log.py` | ✅ Vollständig |
| Server AuditLog Repository | `El Servador/.../db/repositories/audit_log_repo.py` | ✅ Vollständig |
| Server WebSocket Manager | `El Servador/.../websocket/manager.py` | ✅ Vollständig |
| Frontend MqttLogView | `El Frontend/src/views/MqttLogView.vue` | ✅ Vollständig |
| Frontend LogViewerView | `El Frontend/src/views/LogViewerView.vue` | ✅ Vollständig |
| Frontend WebSocket Service | `El Frontend/src/services/websocket.ts` | ✅ Vollständig |
| Frontend useWebSocket | `El Frontend/src/composables/useWebSocket.ts` | ✅ Vollständig |
| Frontend Logs API | `El Frontend/src/api/logs.ts` | ✅ Vollständig |

### Was FEHLT (zu implementieren):

| Komponente | Pfad | Aufwand |
|------------|------|---------|
| **ESP32: Log-Topic in TopicBuilder** | `El Trabajante/src/utils/topic_builder.*` | 30 min |
| **ESP32: publishLog() in MQTT-Client** | `El Trabajante/src/services/communication/mqtt_client.*` | 1h |
| **Server: log_handler.py** | `El Servador/.../mqtt/handlers/log_handler.py` | 2h |
| **Server: Handler-Registrierung in main.py** | `El Servador/.../main.py` (nach Zeile 233) | 15 min |
| **Server: ESP_LOG_MESSAGE Event-Type** | `El Servador/.../db/models/audit_log.py` | 15 min |
| **Server: log_esp_message() Methode** | `El Servador/.../db/repositories/audit_log_repo.py` | 1h |
| **Server: /v1/debug/esp-logs Endpoint** | `El Servador/.../api/v1/debug.py` | 1h |
| **Server: esp_log WebSocket Event-Type** | `El Servador/.../websocket/manager.py` | 15 min |
| **Frontend: esp_log MessageType** | `El Frontend/src/types/index.ts` | 5 min |
| **Frontend: LogCenterView.vue** | `El Frontend/src/views/LogCenterView.vue` | 3h |
| **Frontend: /log-center Route** | `El Frontend/src/router/index.ts` | 15 min |

---

## 5. Implementierung (PHASE 2)

### 5.1 ESP32: TopicBuilder erweitern

**Datei:** `El Trabajante/src/utils/topic_builder.h`

```cpp
// Nach Zeile 45 hinzufügen:

/**
 * @brief Build system log topic
 * @return Topic string: kaiser/{kaiser_id}/esp/{esp_id}/system/log
 */
static const char* buildSystemLogTopic();
```

**Datei:** `El Trabajante/src/utils/topic_builder.cpp`

```cpp
// Nach Zeile 95 hinzufügen (nach buildSystemDiagnosticsTopic):

const char* TopicBuilder::buildSystemLogTopic() {
  int written = snprintf(topic_buffer_, sizeof(topic_buffer_),
                         "kaiser/%s/esp/%s/system/log",
                         kaiser_id_, esp_id_);
  return validateTopicBuffer(written);
}
```

### 5.2 ESP32: MQTT-Client publishLog() hinzufügen

**Datei:** `El Trabajante/src/services/communication/mqtt_client.h`

```cpp
// Nach Zeile 85 hinzufügen (nach publishHeartbeat Deklaration):

/**
 * @brief Publish log message to server
 * @param level Log level (LOG_DEBUG, LOG_INFO, LOG_WARNING, LOG_ERROR, LOG_CRITICAL)
 * @param module Module name (e.g., "sensor_manager", "actuator_manager")
 * @param message Log message text
 * @param error_code Optional error code (0 = no error)
 * @param details_json Optional JSON string with additional details
 * @return true if published successfully
 */
bool publishLog(LogLevel level, const char* module, const char* message,
                uint16_t error_code = 0, const char* details_json = nullptr);
```

**Datei:** `El Trabajante/src/services/communication/mqtt_client.cpp`

```cpp
// Nach Zeile 470 hinzufügen (nach publishHeartbeat):

bool MQTTClient::publishLog(LogLevel level, const char* module, const char* message,
                            uint16_t error_code, const char* details_json) {
    if (!isConnected()) {
        return false;
    }

    // Nur ERROR und CRITICAL werden gesendet (bandwidth optimization)
    if (level < LOG_ERROR) {
        return true;  // Success, aber nicht gesendet
    }

    const char* topic = TopicBuilder::buildSystemLogTopic();

    time_t unix_timestamp = timeManager.getUnixTimestamp();

    String payload = "{";
    payload += "\"ts\":" + String((unsigned long)unix_timestamp) + ",";
    payload += "\"esp_id\":\"" + g_system_config.esp_id + "\",";
    payload += "\"level\":\"" + String(Logger::getLogLevelString(level)) + "\",";
    payload += "\"module\":\"" + String(module) + "\",";
    payload += "\"message\":\"" + String(message) + "\"";

    if (error_code > 0) {
        payload += ",\"error_code\":" + String(error_code);
        payload += ",\"error_description\":\"" + String(getErrorDescription(error_code)) + "\"";
    }

    if (details_json != nullptr && strlen(details_json) > 0) {
        payload += ",\"details\":" + String(details_json);
    }

    payload += "}";

    // QoS 0 für Logs (best-effort, kein ACK benötigt)
    return publish(topic, payload, 0);
}
```

### 5.3 Server: ESP Log Handler erstellen

> **WICHTIG:** Der Handler nutzt das gleiche Pattern wie `heartbeat_handler.py` (NICHT BaseMQTTHandler),
> da die bestehenden Handler `resilient_session()` und Singleton-Pattern verwenden.

**Neue Datei:** `El Servador/god_kaiser_server/src/mqtt/handlers/esp_log_handler.py`

```python
"""
MQTT Handler: ESP32 Log Messages

Processes log messages from ESP32 devices:
- Stores logs in AuditLog table
- Broadcasts to WebSocket for real-time display
- Supports error code lookup

Topic: kaiser/{kaiser_id}/esp/{esp_id}/system/log

Pattern: Follows HeartbeatHandler pattern (NOT BaseMQTTHandler)
- Uses resilient_session() for database access
- Singleton pattern with get_esp_log_handler()
- Module-level handle_esp_log() for MQTT subscriber registration
"""
import re
from typing import Dict, Any, Optional

from ...core.logging_config import get_logger
from ...db.models.audit_log import AuditLog
from ...db.repositories.audit_log_repo import AuditLogRepository
from ...db.session import resilient_session
from ...websocket.manager import WebSocketManager

logger = get_logger(__name__)

# Topic Pattern: kaiser/{kaiser_id}/esp/{esp_id}/system/log
TOPIC_PATTERN = re.compile(
    r"^kaiser/(?P<kaiser_id>[^/]+)/esp/(?P<esp_id>[^/]+)/system/log$"
)

# ESP Log-Level zu Audit-Severity Mapping
LEVEL_TO_SEVERITY = {
    "DEBUG": "info",
    "INFO": "info",
    "WARNING": "warning",
    "ERROR": "error",
    "CRITICAL": "critical",
}

# Required payload fields
REQUIRED_FIELDS = ["ts", "esp_id", "level", "message"]


class ESPLogHandler:
    """
    Handler für ESP32 Log-Nachrichten.

    Flow:
    1. Parse topic → extract esp_id
    2. Validate payload structure
    3. Store in AuditLog table
    4. Broadcast via WebSocket
    """

    async def handle_esp_log(self, topic: str, payload: dict) -> bool:
        """
        Handle ESP log message.

        Expected topic: kaiser/{kaiser_id}/esp/{esp_id}/system/log

        Expected payload:
        {
            "ts": 1735818000,
            "esp_id": "ESP_12AB34CD",
            "level": "ERROR",
            "module": "sensor_manager",
            "message": "Failed to read DS18B20",
            "error_code": 1040,
            "error_description": "Sensor konnte nicht gelesen werden",
            "details": {"gpio": 4}
        }

        Args:
            topic: MQTT topic string
            payload: Parsed JSON payload dict

        Returns:
            True if message processed successfully, False otherwise
        """
        # Step 1: Parse topic
        match = TOPIC_PATTERN.match(topic)
        if not match:
            logger.warning(f"Invalid topic format: {topic}")
            return False

        topic_esp_id = match.group("esp_id")

        # Step 2: Validate payload
        missing = [f for f in REQUIRED_FIELDS if f not in payload]
        if missing:
            logger.warning(
                f"Missing required fields in ESP log: {missing}",
                extra={"topic": topic},
            )
            return False

        # Extract payload fields
        esp_id = payload.get("esp_id", topic_esp_id)
        level = payload.get("level", "INFO").upper()
        message = payload.get("message", "")
        module = payload.get("module", "unknown")
        error_code = payload.get("error_code")
        error_description = payload.get("error_description")
        details = payload.get("details", {})
        ts = payload.get("ts", 0)

        # Validate level
        if level not in LEVEL_TO_SEVERITY:
            logger.warning(f"Invalid log level: {level}")
            level = "INFO"

        severity = LEVEL_TO_SEVERITY.get(level, "info")

        # Step 3: Log to server log (with appropriate level)
        log_method = getattr(logger, severity, logger.info)
        log_method(
            f"ESP Log [{esp_id}][{module}]: {message}",
            extra={
                "esp_id": esp_id,
                "module": module,
                "error_code": error_code,
            }
        )

        # Step 4: Store in AuditLog table
        try:
            async with resilient_session() as session:
                audit_repo = AuditLogRepository(session)

                await audit_repo.create(
                    event_type="esp_log_message",  # AuditEventType.ESP_LOG_MESSAGE
                    severity=severity,
                    source_type="esp32",  # AuditSourceType.ESP32
                    source_id=esp_id,
                    status="success",
                    message=message,
                    details={
                        "module": module,
                        "log_level": level,
                        "original_timestamp": ts,
                        **(details if isinstance(details, dict) else {}),
                    },
                    error_code=str(error_code) if error_code else None,
                    error_description=error_description,
                )
                await session.commit()

        except Exception as e:
            logger.error(f"Failed to store ESP log in database: {e}")
            # Continue to WebSocket broadcast even if DB fails

        # Step 5: WebSocket Broadcast
        try:
            ws_manager = await WebSocketManager.get_instance()
            await ws_manager.broadcast(
                message_type="esp_log",
                data={
                    "esp_id": esp_id,
                    "level": level,
                    "module": module,
                    "message": message,
                    "error_code": error_code,
                    "error_description": error_description,
                    "details": details,
                    "timestamp": ts,
                },
            )
        except Exception as e:
            logger.warning(f"Failed to broadcast ESP log via WebSocket: {e}")
            # Non-critical, don't fail the handler

        return True


# ============================================================================
# Singleton Pattern (same as HeartbeatHandler)
# ============================================================================

_handler_instance: Optional[ESPLogHandler] = None


def get_esp_log_handler() -> ESPLogHandler:
    """Get or create singleton handler instance."""
    global _handler_instance
    if _handler_instance is None:
        _handler_instance = ESPLogHandler()
    return _handler_instance


async def handle_esp_log(topic: str, payload: dict) -> bool:
    """
    Handle ESP log message (convenience function).

    This is the entry point registered with MQTT subscriber.

    Args:
        topic: MQTT topic string
        payload: Parsed JSON payload dict

    Returns:
        True if message processed successfully
    """
    handler = get_esp_log_handler()
    return await handler.handle_esp_log(topic, payload)
```

### 5.4 Server: Handler in main.py registrieren

**Datei:** `El Servador/god_kaiser_server/src/main.py`

> ⚠️ **VERIFIZIERT (2026-01-05):** Die Zeilennummern wurden gegen den echten Code geprüft:
> - Handler-Imports sind in Zeilen 36-46, NICHT Zeile 17
> - Handler-Registrierungen sind in Zeilen 194-283
> - Der Log-Handler sollte nach `subzone_ack_handler` (Zeile 233) eingefügt werden

```python
# Zeile 46: Import hinzufügen (innerhalb des bestehenden from .mqtt.handlers import (...) Blocks)
from .mqtt.handlers import (
    actuator_handler,
    actuator_response_handler,
    actuator_alert_handler,
    config_handler,
    discovery_handler,
    heartbeat_handler,
    sensor_handler,
    subzone_ack_handler,
    zone_ack_handler,
    esp_log_handler,  # NEU HINZUFÜGEN
)

# Nach Zeile 233 hinzufügen (nach subzone_ack_handler Registrierung):
_subscriber_instance.register_handler(
    f"kaiser/{kaiser_id}/esp/+/system/log",
    esp_log_handler.handle_esp_log
)
logger.info("Registered ESP Log handler for system/log topic")
```

### 5.5 Server: ESP_LOG_MESSAGE Event-Type hinzufügen

**Datei:** `El Servador/god_kaiser_server/src/db/models/audit_log.py`

```python
# In class AuditEventType (nach Zeile 211):
ESP_LOG_MESSAGE = "esp_log_message"
ESP_DIAGNOSTIC = "esp_diagnostic"
```

### 5.6 Server: /v1/debug/esp-logs Endpoint

**Datei:** `El Servador/god_kaiser_server/src/api/v1/debug.py`

```python
# Nach den bestehenden Endpoints hinzufügen:

from typing import List, Optional
from datetime import datetime
from pydantic import BaseModel, Field


class ESPLogResponse(BaseModel):
    """Response-Schema für ESP-Logs."""
    id: str
    esp_id: str
    level: str
    module: Optional[str]
    message: str
    error_code: Optional[str]
    error_description: Optional[str]
    details: Optional[dict]
    timestamp: datetime

    class Config:
        from_attributes = True


class ESPLogsListResponse(BaseModel):
    """Liste von ESP-Logs mit Pagination."""
    success: bool
    logs: List[ESPLogResponse]
    total_count: int
    page: int
    page_size: int
    has_more: bool


@router.get("/esp-logs", response_model=ESPLogsListResponse)
async def get_esp_logs(
    esp_id: Optional[str] = None,
    level: Optional[str] = Query(None, description="Log-Level: DEBUG, INFO, WARNING, ERROR, CRITICAL"),
    module: Optional[str] = None,
    error_code: Optional[int] = None,
    start_time: Optional[datetime] = None,
    end_time: Optional[datetime] = None,
    page: int = Query(1, ge=1),
    page_size: int = Query(100, ge=1, le=1000),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_admin_user),
):
    """
    ESP32-Logs abfragen mit Filtern.

    Filter:
    - esp_id: Filter nach spezifischem ESP
    - level: Filter nach Log-Level
    - module: Filter nach ESP-Modul
    - error_code: Filter nach Error-Code
    - start_time/end_time: Zeitraum-Filter
    """
    from ...db.models.audit_log import AuditLog, AuditEventType, AuditSourceType
    from sqlalchemy import select, func, and_

    # Basis-Query
    conditions = [
        AuditLog.event_type == AuditEventType.ESP_LOG_MESSAGE,
        AuditLog.source_type == AuditSourceType.ESP32,
    ]

    # Filter anwenden
    if esp_id:
        conditions.append(AuditLog.source_id == esp_id)

    if level:
        # Level ist in details.log_level gespeichert
        conditions.append(AuditLog.details["log_level"].astext == level.upper())

    if module:
        conditions.append(AuditLog.details["module"].astext.ilike(f"%{module}%"))

    if error_code:
        conditions.append(AuditLog.error_code == str(error_code))

    if start_time:
        conditions.append(AuditLog.created_at >= start_time)

    if end_time:
        conditions.append(AuditLog.created_at <= end_time)

    # Total Count
    count_query = select(func.count()).where(and_(*conditions)).select_from(AuditLog)
    total_count = await db.scalar(count_query) or 0

    # Logs abrufen
    offset = (page - 1) * page_size
    query = (
        select(AuditLog)
        .where(and_(*conditions))
        .order_by(AuditLog.created_at.desc())
        .offset(offset)
        .limit(page_size)
    )

    result = await db.execute(query)
    logs = result.scalars().all()

    # Response formatieren
    log_responses = []
    for log in logs:
        details = log.details or {}
        log_responses.append(ESPLogResponse(
            id=str(log.id),
            esp_id=log.source_id,
            level=details.get("log_level", "INFO"),
            module=details.get("module"),
            message=log.message,
            error_code=log.error_code,
            error_description=log.error_description,
            details=details,
            timestamp=log.created_at,
        ))

    return ESPLogsListResponse(
        success=True,
        logs=log_responses,
        total_count=total_count,
        page=page,
        page_size=page_size,
        has_more=offset + len(logs) < total_count,
    )


@router.get("/error-codes")
async def get_error_codes():
    """
    Gibt alle Error-Codes mit menschenlesbaren Beschreibungen zurück.
    Konsolidiert ESP32 und Server Error-Codes.
    """
    return {
        "esp32": {
            "ranges": {
                "1000-1999": "HARDWARE (GPIO, I2C, SPI, OneWire, Sensor, Actuator)",
                "2000-2999": "SERVICE (NVS, Config, Logger, Storage, Subzone)",
                "3000-3999": "COMMUNICATION (WiFi, MQTT, HTTP, Network)",
                "4000-4999": "APPLICATION (State, Operation, Command, Payload)",
            },
            "codes": {
                "1001": {"name": "ERROR_GPIO_RESERVED", "description": "Pin bereits reserviert", "severity": "ERROR"},
                "1002": {"name": "ERROR_GPIO_CONFLICT", "description": "GPIO-Konflikt", "severity": "ERROR"},
                "1003": {"name": "ERROR_GPIO_INIT_FAILED", "description": "GPIO-Initialisierung fehlgeschlagen", "severity": "CRITICAL"},
                "1010": {"name": "ERROR_I2C_INIT_FAILED", "description": "I2C-Initialisierung fehlgeschlagen", "severity": "CRITICAL"},
                "1011": {"name": "ERROR_I2C_DEVICE_NOT_FOUND", "description": "I2C-Gerät nicht gefunden", "severity": "WARNING"},
                "1040": {"name": "ERROR_SENSOR_READ_FAILED", "description": "Sensor konnte nicht gelesen werden", "severity": "WARNING"},
                "1041": {"name": "ERROR_SENSOR_INIT_FAILED", "description": "Sensor-Initialisierung fehlgeschlagen", "severity": "ERROR"},
                "1050": {"name": "ERROR_ACTUATOR_SET_FAILED", "description": "Aktor-Befehl fehlgeschlagen", "severity": "ERROR"},
                "1051": {"name": "ERROR_ACTUATOR_INIT_FAILED", "description": "Aktor-Initialisierung fehlgeschlagen", "severity": "CRITICAL"},
                "3010": {"name": "ERROR_MQTT_INIT_FAILED", "description": "MQTT-Initialisierung fehlgeschlagen", "severity": "CRITICAL"},
                "3011": {"name": "ERROR_MQTT_CONNECT_FAILED", "description": "MQTT-Verbindung fehlgeschlagen", "severity": "ERROR"},
                "3012": {"name": "ERROR_MQTT_PUBLISH_FAILED", "description": "MQTT-Publish fehlgeschlagen", "severity": "WARNING"},
                "3013": {"name": "ERROR_MQTT_SUBSCRIBE_FAILED", "description": "MQTT-Subscribe fehlgeschlagen", "severity": "ERROR"},
            }
        },
        "server": {
            "ranges": {
                "5000-5099": "CONFIG (Validation-Fehler)",
                "5100-5199": "MQTT (Handler-Fehler)",
                "5200-5299": "VALIDATION (Payload-Fehler)",
                "5300-5399": "DATABASE (DB-Operation-Fehler)",
                "5400-5499": "SERVICE (Business-Logic-Fehler)",
                "5500-5599": "AUDIT (Audit-Log-Fehler)",
            },
            "codes": {
                "5001": {"name": "ERROR_CONFIG_INVALID", "description": "Ungültige Konfiguration", "severity": "ERROR"},
                "5101": {"name": "ERROR_MQTT_HANDLER_FAILED", "description": "MQTT-Handler fehlgeschlagen", "severity": "ERROR"},
                "5201": {"name": "ERROR_PAYLOAD_MISSING_FIELDS", "description": "Pflichtfelder fehlen im Payload", "severity": "WARNING"},
                "5301": {"name": "ERROR_DB_QUERY_FAILED", "description": "Datenbankabfrage fehlgeschlagen", "severity": "ERROR"},
            }
        }
    }
```

### 5.7 Frontend: esp_log MessageType hinzufügen

**Datei:** `El Frontend/src/types/index.ts`

```typescript
// Nach Zeile 175 (vor die schließende Klammer von MessageType):
  | 'esp_log'               // ESP32 Log-Nachrichten
```

### 5.8 Frontend: Logs API erweitern

**Datei:** `El Frontend/src/api/logs.ts`

```typescript
// Nach den bestehenden Interfaces hinzufügen:

export interface ESPLog {
  id: string
  esp_id: string
  level: 'DEBUG' | 'INFO' | 'WARNING' | 'ERROR' | 'CRITICAL'
  module: string | null
  message: string
  error_code: string | null
  error_description: string | null
  details: Record<string, unknown> | null
  timestamp: string
}

export interface ESPLogsResponse {
  success: boolean
  logs: ESPLog[]
  total_count: number
  page: number
  page_size: number
  has_more: boolean
}

export interface ESPLogQueryParams {
  esp_id?: string
  level?: string
  module?: string
  error_code?: number
  start_time?: string
  end_time?: string
  page?: number
  page_size?: number
}

export interface ErrorCodesResponse {
  esp32: {
    ranges: Record<string, string>
    codes: Record<string, { name: string; description: string; severity: string }>
  }
  server: {
    ranges: Record<string, string>
    codes: Record<string, { name: string; description: string; severity: string }>
  }
}

// In logsApi Objekt hinzufügen:
export const logsApi = {
  // Bestehende Methoden...
  listFiles: (): Promise<LogFilesResponse> =>
    apiClient.get('/debug/logs/files').then(r => r.data),

  queryLogs: (params: LogQueryParams): Promise<LogsResponse> =>
    apiClient.get('/debug/logs', { params }).then(r => r.data),

  // NEU:
  getESPLogs: (params: ESPLogQueryParams): Promise<ESPLogsResponse> =>
    apiClient.get('/debug/esp-logs', { params }).then(r => r.data),

  getErrorCodes: (): Promise<ErrorCodesResponse> =>
    apiClient.get('/debug/error-codes').then(r => r.data),
}
```

---

## 6. Datenfluss

### 6.1 ESP → Server → Frontend

```
┌─────────────────┐    MQTT (QoS 0)    ┌─────────────────┐    WebSocket    ┌─────────────────┐
│     ESP32       │───────────────────▶│     Server      │────────────────▶│    Frontend     │
│                 │                    │                 │                 │                 │
│ publishLog()    │                    │ esp_log_handler │                 │ MqttLogView     │
│  ↓              │                    │      ↓          │                 │ LogCenterView   │
│ TopicBuilder    │                    │ AuditLog DB     │                 │                 │
│ .buildSystem    │                    │      ↓          │                 │                 │
│ LogTopic()      │                    │ broadcast_event │                 │                 │
│                 │                    │ ("esp_log")     │                 │                 │
└─────────────────┘                    └─────────────────┘                 └─────────────────┘

Topic: kaiser/{kaiser_id}/esp/{esp_id}/system/log

Payload:
{
  "ts": 1234567890,
  "esp_id": "ESP_12AB34CD",
  "level": "ERROR",
  "module": "sensor_manager",
  "message": "Failed to read DS18B20",
  "error_code": 1040,
  "error_description": "Sensor konnte nicht gelesen werden",
  "details": {"gpio": 4}
}
```

### 6.2 Log-Levels und Farben

| Level | ESP32-Funktion | Server-Severity | Frontend-Badge |
|-------|----------------|-----------------|----------------|
| DEBUG | `LOG_DEBUG()` | info | badge-gray |
| INFO | `LOG_INFO()` | info | badge-info (blau) |
| WARNING | `LOG_WARNING()` | warning | badge-warning (gelb) |
| ERROR | `LOG_ERROR()` | error | badge-danger (rot) |
| CRITICAL | `LOG_CRITICAL()` | critical | badge-danger (dunkelrot) |

---

## 7. Implementierungs-Checkliste

### Phase 1: ESP32 (30 min)

- [ ] `buildSystemLogTopic()` in topic_builder.h/cpp hinzufügen
- [ ] `publishLog()` in mqtt_client.h/cpp hinzufügen
- [ ] Build testen: `cd "El Trabajante" && pio run -e esp32_dev`

### Phase 2: Server Backend (3-4h)

- [ ] `esp_log_handler.py` erstellen (Pattern wie HeartbeatHandler - NICHT BaseMQTTHandler!)
- [ ] Handler in `main.py` importieren und registrieren
- [ ] `ESP_LOG_MESSAGE` Event-Type in audit_log.py hinzufügen
- [ ] `/v1/debug/esp-logs` Endpoint in debug.py hinzufügen
- [ ] `/v1/debug/error-codes` Endpoint in debug.py hinzufügen
- [ ] Server-Tests ausführen: `cd "El Servador" && poetry run pytest -v`

### Phase 3: Frontend (3h)

- [ ] `esp_log` MessageType in types/index.ts hinzufügen
- [ ] logs.ts API-Client erweitern
- [ ] `LogCenterView.vue` erstellen (Tab-basiert)
- [ ] Route `/log-center` hinzufügen
- [ ] Sidebar-Navigation erweitern
- [ ] WebSocket `esp_log` Handler in MqttLogView erweitern

### Phase 4: Integration & Test (1h)

- [ ] ESP32 mit Server testen
- [ ] Frontend mit echten Logs testen
- [ ] Performance-Test (viele Logs)
- [ ] Dokumentation aktualisieren

---

## 8. Code-Locations Referenz (VOLLSTÄNDIG)

### ESP32

| Komponente | Pfad | Beschreibung |
|------------|------|--------------|
| **Logger-Klasse** | `El Trabajante/src/utils/logger.h:9-103` | Log-Levels, LogEntry, Makros |
| **Logger-Implementation** | `El Trabajante/src/utils/logger.cpp:6-193` | Singleton, Circular Buffer |
| **Error-Codes** | `El Trabajante/src/models/error_codes.h:12-332` | Alle Error-Codes + Helper |
| **TopicBuilder** | `El Trabajante/src/utils/topic_builder.h:15-85` | Topic-Generierung |
| **TopicBuilder-Impl** | `El Trabajante/src/utils/topic_builder.cpp:7-195` | 18 Topic-Pattern |
| **MQTT-Client** | `El Trabajante/src/services/communication/mqtt_client.h:17-145` | MQTTConfig, Methoden |
| **MQTT-Client-Impl** | `El Trabajante/src/services/communication/mqtt_client.cpp:32-600` | Publish, Heartbeat |

### Server

| Komponente | Pfad | Beschreibung |
|------------|------|--------------|
| **Logging-Config** | `El Servador/.../core/logging_config.py:15-138` | JSON/Text Formatter, Setup |
| **BaseMQTTHandler** | `El Servador/.../mqtt/handlers/base_handler.py:43-565` | Validation, Topic-Parse, Audit |
| **MQTT-Subscriber** | `El Servador/.../mqtt/subscriber.py:34-323` | Handler-Registrierung, Routing |
| **main.py Lifespan** | `El Servador/.../main.py:81-323` | Startup/Shutdown, Handler-Registration |
| **AuditLog Model** | `El Servador/.../db/models/audit_log.py:26-231` | Spalten, Event-Types, Severity |
| **AuditLog Repo** | `El Servador/.../db/repositories/audit_log_repo.py:54-420` | CRUD, Logging-Methoden |
| **WebSocket Manager** | `El Servador/.../websocket/manager.py:41-308` | Singleton, Broadcast, Rate-Limit |
| **Debug API** | `El Servador/.../api/v1/debug.py:82-400+` | Logs, Mock-ESP, Database-Explorer |

### Frontend

| Komponente | Pfad | Beschreibung |
|------------|------|--------------|
| **MqttLogView** | `El Frontend/src/views/MqttLogView.vue:1-285` | WebSocket Real-time |
| **LogViewerView** | `El Frontend/src/views/LogViewerView.vue:1-430` | Server-Logs HTTP-Polling |
| **WebSocket Service** | `El Frontend/src/services/websocket.ts:24-580` | Singleton, Reconnect, Filter |
| **useWebSocket** | `El Frontend/src/composables/useWebSocket.ts:17-262` | Vue Composable Wrapper |
| **Logs API** | `El Frontend/src/api/logs.ts:27-96` | HTTP-Client für Logs |
| **Types** | `El Frontend/src/types/index.ts:161-195` | MessageType, MqttMessage |
| **Router** | `El Frontend/src/router/index.ts:66-98` | Log-Routes |

---

## 9. Wichtige Hinweise

### 9.1 ESP32 Log-Bandbreite

**WICHTIG:** ESP32 sendet nur ERROR und CRITICAL Logs via MQTT!

```cpp
// In publishLog():
if (level < LOG_ERROR) {
    return true;  // Nicht senden, aber als Erfolg werten
}
```

DEBUG, INFO und WARNING bleiben lokal im Circular Buffer (50 Einträge) und werden nur über Serial ausgegeben.

### 9.2 Log-Retention

Nutze bestehenden `AuditRetentionService` als Vorlage:
- DEBUG-Logs: 7 Tage
- INFO-Logs: 14 Tage
- WARNING-Logs: 30 Tage
- ERROR/CRITICAL-Logs: 90 Tage

### 9.3 Performance-Indizes

In AuditLog sind bereits Indizes definiert:
- `created_at` (für Time-Range Queries)
- `severity, created_at` (für Level-Filter)
- `source_type, source_id, created_at` (für ESP-Filter)

### 9.4 Mock-ESP Log-Support

`MockESP32Client` kann erweitert werden um `publish_log()` für Tests:
```python
# In mock_esp_client.py
async def publish_log(self, level: str, module: str, message: str, error_code: int = 0):
    topic = f"kaiser/{self.kaiser_id}/esp/{self.esp_id}/system/log"
    payload = {
        "ts": int(time.time()),
        "esp_id": self.esp_id,
        "level": level,
        "module": module,
        "message": message,
        "error_code": error_code,
    }
    await self.publish(topic, payload)
```

---

**Dokument-Version:** 2.0
**Erstellt:** 2026-01-05
**Aktualisiert:** 2026-01-05
**Autor:** Claude (Manager-Modus)

---

## Changelog

### v2.0 (2026-01-05)
- Vollständige Codebase-Analyse mit Zeilennummern
- Alle relevanten Dateien dokumentiert
- Status-Übersicht: Was existiert vs. was fehlt
- Konkrete Implementierungsvorlagen basierend auf existierenden Patterns
- Error-Code-Referenz vollständig aus error_codes.h
- WebSocket und BaseMQTTHandler Pattern dokumentiert
- Frontend-Analyse: MqttLogView, LogViewerView, WebSocket Service

### v3.0 (2026-01-05)
- **NEU: Section 10 - Kommunikationsflüsse** hinzugefügt
- Vollständige Analyse aller Kommunikationspfade aus echtem Code
- ESP32→Server: Heartbeat, Sensor, Actuator Flows dokumentiert
- Server→ESP32: Config, Commands, Zone Flows dokumentiert
- Server→Frontend: WebSocket Events mit Broadcasting-Logik
- Frontend→Server: REST API und WebSocket Subscription
- Server-Zentrisches Prinzip mit ESP32 Fallback-Verhalten
- QoS-Levels, Timing-Konstanten, Retry-Logik dokumentiert

### v4.0 (2026-01-05) - KRITISCHE REVIEW & ERWEITERUNGEN
- **KRITISCHE KORREKTUR in Section 5.3:** ESPLogHandler komplett neu geschrieben!
  - ❌ FALSCH: Vererbung von `BaseMQTTHandler` mit `self.db`, `self.audit_repo`
  - ✅ KORREKT: Eigene Klasse mit `resilient_session()` Pattern (wie HeartbeatHandler)
  - ✅ KORREKT: Singleton-Pattern mit `get_esp_log_handler()`
  - ✅ KORREKT: `WebSocketManager.get_instance()` für Broadcast
- **NEU: Section 11 - LogCenterView.vue** vollständige Implementation hinzugefügt
- **NEU: Section 12 - Error-Codes Endpoint vollständig** (alle 60+ Codes dynamisch)
- **NEU: Section 13 - Design-Entscheidungen** (DEBUG/INFO/WARNING Sichtbarkeit)
- **NEU: Section 14 - MockESP32Client.publish_log()** für Tests
- **Aktualisiert: Implementierungs-Checkliste** mit allen fehlenden Komponenten

---

## 10. Kommunikationsflüsse (VOLLSTÄNDIGE ANALYSE)

> **WICHTIG:** Diese Sektion dokumentiert die tatsächlichen Kommunikationsflüsse aus dem echten Code.
> Alle Werte wurden aus den Quelldateien extrahiert und verifiziert.

---

### 10.1 ESP32 → Server Kommunikation

#### 10.1.1 Heartbeat

**Trigger:** Automatisch in `mqttClient.loop()` (mqtt_client.cpp:484)

| Parameter | Wert | Quelle |
|-----------|------|--------|
| **Interval** | 60 Sekunden | `HEARTBEAT_INTERVAL_MS = 60000` (mqtt_client.h:108) |
| **QoS** | 0 (best-effort) | mqtt_client.cpp:465 `publish(topic, payload, 0)` |
| **Topic** | `kaiser/{kaiser_id}/esp/{esp_id}/system/heartbeat` | TopicBuilder::buildSystemHeartbeatTopic() |
| **Retry** | Nein (QoS 0) | - |

**Payload-Struktur (mqtt_client.cpp:451-462):**
```json
{
  "esp_id": "ESP_12AB34CD",
  "zone_id": "zone_main",
  "master_zone_id": "master",
  "zone_assigned": true,
  "ts": 1704067200,          // Unix timestamp (NTP-sync)
  "uptime": 123456,          // Sekunden seit Boot
  "heap_free": 45000,        // Bytes (ESP.getFreeHeap())
  "wifi_rssi": -45,          // dBm (WiFi.RSSI())
  "sensor_count": 3,         // Aktive Sensoren
  "actuator_count": 2        // Aktive Aktoren
}
```

**Server-Verarbeitung (heartbeat_handler.py:55-170):**
1. Topic parsen → `esp_id` extrahieren
2. Payload validieren (required: `ts`, `uptime`, `heap_free`/`free_heap`, `wifi_rssi`)
3. ESP in DB suchen (REJECT wenn nicht registriert!)
4. Status auf "online" setzen, `last_seen` updaten
5. Metadata in DB aktualisieren
6. WebSocket broadcast `esp_health`

**Device-Timeout (heartbeat_handler.py:37):**
```python
HEARTBEAT_TIMEOUT_SECONDS = 300  # 5 Minuten → Device offline
```

---

#### 10.1.2 Sensor-Daten

**Trigger:** Automatisch via `sensorManager.performAllMeasurements()` in loop() (main.cpp:1083)

| Parameter | Wert | Quelle |
|-----------|------|--------|
| **Default-Interval** | 30 Sekunden | `measurement_interval_(30000)` (sensor_manager.cpp:33) |
| **Konfiguriert in main.cpp** | 5 Sekunden | `sensorManager.setMeasurementInterval(5000)` (main.cpp:979) |
| **QoS** | 0 (default), 1 für safePublish | mqtt_client.cpp:327 |
| **Topic** | `kaiser/{kaiser_id}/esp/{esp_id}/sensor/{gpio}/data` | TopicBuilder::buildSensorDataTopic() |
| **Batch-Topic** | `kaiser/{kaiser_id}/esp/{esp_id}/sensor/batch` | TopicBuilder::buildSensorBatchTopic() |

**Payload-Struktur (Required Fields - sensor_handler.py:326-368):**
```json
{
  "ts": 1704067200,          // REQUIRED: Unix timestamp
  "esp_id": "ESP_12AB34CD",  // REQUIRED
  "gpio": 34,                // REQUIRED
  "sensor_type": "ph",       // REQUIRED
  "raw": 2150,               // REQUIRED (oder "raw_value")
  "value": 0.0,              // Optional: Vorverarbeiteter Wert
  "unit": "",                // Optional
  "quality": "stale",        // Optional
  "raw_mode": true           // REQUIRED seit 2025-12-08!
}
```

**Server-Verarbeitung (sensor_handler.py:78-310):**
1. Topic parsen → `esp_id`, `gpio` extrahieren
2. Payload validieren (5 Pflichtfelder + `raw_mode`)
3. ESP in DB suchen (Warning wenn nicht gefunden)
4. Sensor-Config laden (optional)
5. **Pi-Enhanced Processing** wenn `sensor_config.pi_enhanced == True && raw_mode == True`:
   - Library dynamisch laden (`library_loader.py`)
   - RAW-Wert verarbeiten
   - Processed-Value zurück publizieren (optional)
6. Daten in DB speichern
7. WebSocket broadcast `sensor_data`
8. **Logic Engine triggern** (non-blocking, asyncio.create_task)

---

#### 10.1.3 Actuator-Status

**Trigger:** Nach Command-Execution ODER periodisch alle 30 Sekunden (main.cpp:1087-1091)

| Parameter | Wert | Quelle |
|-----------|------|--------|
| **Periodisch** | 30 Sekunden | `if (millis() - last_actuator_status > 30000)` (main.cpp:1088) |
| **Nach Command** | Sofort | actuator_manager.cpp nach setActuatorState() |
| **QoS** | 1 (safePublish) | actuator_manager.cpp |
| **Topic** | `kaiser/{kaiser_id}/esp/{esp_id}/actuator/{gpio}/status` | TopicBuilder::buildActuatorStatusTopic() |

**Payload-Struktur:**
```json
{
  "ts": 1704067200,
  "esp_id": "ESP_12AB34CD",
  "gpio": 25,
  "actuator_type": "pump",
  "state": "on",
  "value": 1.0,              // 0.0-1.0 (PWM normalisiert)
  "runtime_seconds": 120,
  "emergency_stopped": false
}
```

---

#### 10.1.4 Connection-Loss und Retry-Logik

**Offline-Buffer (mqtt_client.cpp:566-582):**
```cpp
// Max 100 Messages im Buffer
const uint16_t MAX_OFFLINE_MESSAGES = 100;

// Buffer-Eintrag
struct OfflineMessage {
  String topic;
  String payload;
  uint8_t qos;
  unsigned long timestamp;
};
```

**Exponential Backoff (mqtt_client.cpp:587-597):**
```cpp
const unsigned long RECONNECT_BASE_DELAY_MS = 1000;   // 1 Sekunde
const unsigned long RECONNECT_MAX_DELAY_MS = 60000;   // 60 Sekunden max
const uint16_t MAX_RECONNECT_ATTEMPTS = 10;

// Berechnung: delay * 2^attempts (gedeckelt bei 60s)
unsigned long delay = RECONNECT_BASE_DELAY_MS * (1 << reconnect_attempts_);
```

**Circuit Breaker (mqtt_client.cpp:54):**
```cpp
circuit_breaker_("MQTT", 5, 30000, 10000)
// 5 Failures → OPEN
// 30s Recovery Timeout
// 10s Half-Open Test Timeout
```

**Last-Will Message (mqtt_client.cpp:125-138):**
```cpp
// Topic: kaiser/{kaiser_id}/esp/{esp_id}/status/will
// Message: {"status":"offline","reason":"unexpected_disconnect","timestamp":...}
// QoS: 1, Retain: true
```

---

### 10.2 Server → ESP32 Kommunikation

#### 10.2.1 Config-Updates

**Trigger:** REST API `POST /api/v1/esp/{id}/config` oder Zone-Assignment

| Parameter | Wert | Quelle |
|-----------|------|--------|
| **QoS** | 2 (exactly-once) | subscriber.py:119-124 |
| **Topic** | `kaiser/{kaiser_id}/esp/{esp_id}/config` | TopicBuilder::buildConfigTopic() |

**Config-Payload (config_builder.py):**
```json
{
  "sensors": [
    {
      "gpio": 34,
      "sensor_type": "ph",
      "sensor_name": "pH Sensor 1",
      "subzone_id": "grow_area_1",
      "active": true,
      "raw_mode": true
    }
  ],
  "actuators": [
    {
      "gpio": 25,
      "actuator_type": "pump",
      "actuator_name": "Water Pump",
      "active": true
    }
  ],
  "zone": {
    "zone_id": "zone_main",
    "master_zone_id": "master",
    "zone_name": "Main Zone"
  }
}
```

**ESP32-Verarbeitung (main.cpp:517-521):**
1. Callback empfängt Config-Topic
2. `handleSensorConfig()` und `handleActuatorConfig()` aufrufen
3. Validierung, NVS-Speicherung
4. ACK via `config_response` Topic

**Offline-Handling (esp_service.py):**
```python
# Parameter: offline_behavior = "warn" | "skip" | "fail"
# Default: "warn" (loggt Warning, sendet trotzdem)
# "skip": Überspringt offline ESPs
# "fail": Wirft Exception wenn ESP offline
```

---

#### 10.2.2 Actuator-Commands

**Trigger:** REST API `POST /api/v1/actuators/{id}/command` oder Logic Engine

| Parameter | Wert | Quelle |
|-----------|------|--------|
| **QoS** | 1 (at-least-once) | actuator_service.py:135 `retry=True` |
| **Topic** | `kaiser/{kaiser_id}/esp/{esp_id}/actuator/{gpio}/command` | |

**Command-Payload:**
```json
{
  "command": "ON",           // ON, OFF, PWM, TOGGLE
  "value": 1.0,              // 0.0-1.0 (ESP konvertiert zu 0-255)
  "duration": 0,             // Sekunden (0 = unbegrenzt)
  "issued_by": "logic_engine"
}
```

**Safety-Validierung (actuator_service.py:74-107):**
```python
# IMMER vor jedem Command!
safety_result = await self.safety_service.validate_actuator_command(
    esp_id=esp_id,
    gpio=gpio,
    command=command,
    value=value,
)

# Checks:
# - Emergency-Stop aktiv?
# - Value in erlaubtem Bereich (0.0-1.0)?
# - Aktor existiert?
# - Timeout-Protection aktiv?
```

---

#### 10.2.3 Zone-Assignment

**Trigger:** REST API `POST /api/v1/zone/devices/{id}/assign`

| Parameter | Wert | Quelle |
|-----------|------|--------|
| **QoS** | 1 | zone_service.py |
| **Topic** | `kaiser/{kaiser_id}/esp/{esp_id}/zone/assign` | |
| **ACK-Topic** | `kaiser/{kaiser_id}/esp/{esp_id}/zone/ack` | |

**Assignment-Flow (main.cpp:646-726):**
1. Server publiziert Zone-Assignment
2. ESP empfängt, validiert zone_id
3. ESP speichert in NVS via `configManager.updateZoneAssignment()`
4. ESP updated globale Variablen (`g_kaiser`)
5. ESP sendet ACK mit Status
6. ESP sendet neuen Heartbeat

---

### 10.3 Server → Frontend Kommunikation (WebSocket)

#### 10.3.1 WebSocket-Konfiguration

| Parameter | Wert | Quelle |
|-----------|------|--------|
| **Endpoint** | `/api/v1/ws/realtime/{client_id}` | websocket.ts:112 |
| **Auth** | JWT Token als URL-Parameter | `?token=...` |
| **Rate-Limit** | 10 msg/sec | manager.py:39 |
| **Rate-Window** | 1 Sekunde (Sliding Window) | manager.py:269-287 |

#### 10.3.2 Event-Types und Broadcasting

| Event-Type | Handler | Broadcast-Zeitpunkt | Quelle |
|------------|---------|---------------------|--------|
| `sensor_data` | sensor_handler.py | Nach DB-Insert | Zeile 256-269 |
| `esp_health` | heartbeat_handler.py | Nach Status-Update | Zeile 154-168 |
| `actuator_status` | actuator_handler.py | Nach State-Update | |
| `actuator_response` | actuator_response_handler.py | Nach Command-ACK | |
| `actuator_alert` | actuator_alert_handler.py | Bei Emergency/Timeout | |
| `config_response` | config_handler.py | Nach Config-ACK | |
| `zone_assignment` | zone_ack_handler.py | Nach Zone-ACK | |
| `logic_execution` | logic_engine.py | Nach Rule-Trigger | |
| `system_event` | Verschiedene | System-Notifications | |
| `esp_log` | **NEU** (zu implementieren) | Nach ESP-Log-Empfang | |

#### 10.3.3 Filter-System (manager.py:174-215)

```python
# Client-Subscription mit Filtern
filters = {
    "types": ["sensor_data", "esp_health"],  # Nur diese Types
    "esp_ids": ["ESP_12AB34CD"],              # Nur diese ESPs
    "sensor_types": ["ph", "temperature"],    # Nur diese Sensor-Typen
}

# Matching-Logik
def matchesFilters(message, filters):
    # 1. Type-Filter (Whitelist)
    if filters.types and message.type not in filters.types:
        return False

    # 2. ESP-ID-Filter
    if filters.esp_ids and message.data.esp_id not in filters.esp_ids:
        return False

    # 3. Sensor-Type-Filter
    if filters.sensor_types and message.data.sensor_type not in filters.sensor_types:
        return False

    return True
```

---

### 10.4 Frontend → Server Kommunikation

#### 10.4.1 REST API Authentication

**JWT-Flow (websocket.ts:89-144):**
```typescript
// Token-Extraction aus JWT
const payload = JSON.parse(atob(token.split('.')[1]))
this.tokenExpiry = payload.exp * 1000  // ms

// Token-Refresh vor Reconnect
private async refreshTokenIfNeeded(): Promise<boolean> {
  if (!this.isTokenExpired()) return true

  await authStore.refreshTokens()
  return true
}
```

#### 10.4.2 WebSocket-Reconnection (websocket.ts:237-266)

```typescript
// Exponential Backoff mit Jitter
const exponentialDelay = Math.min(
  this.baseReconnectDelay * Math.pow(2, this.reconnectAttempts - 1),  // 1s, 2s, 4s, 8s...
  this.maxReconnectDelay  // max 30s
)
const jitter = exponentialDelay * 0.1 * (Math.random() * 2 - 1)  // ±10%
const delay = Math.round(exponentialDelay + jitter)

// Max 10 Attempts
if (this.reconnectAttempts < this.maxReconnectAttempts) {
  this.scheduleReconnect()
}
```

#### 10.4.3 Visibility-Handling (websocket.ts:272-314)

```typescript
// Tab-Wechsel → Auto-Reconnect
document.addEventListener('visibilitychange', async () => {
  if (document.visibilityState === 'visible') {
    if (!this.isConnected() && this.status !== 'connecting') {
      await this.refreshTokenIfNeeded()
      this.connect()
    }
  }
})
```

---

### 10.5 Server-Zentrisches Prinzip

#### 10.5.1 Architektur-Grundsatz

```
┌───────────────────────────────────────────────────────────────────────┐
│                           GOD-KAISER SERVER                            │
│                                                                        │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐                │
│  │   Logic     │    │   Sensor    │    │   Safety    │                │
│  │   Engine    │    │   Libraries │    │   Service   │                │
│  │             │    │             │    │             │                │
│  │ Cross-ESP   │    │ Pi-Enhanced │    │ Emergency   │                │
│  │ Automation  │    │ Processing  │    │ Validation  │                │
│  └─────────────┘    └─────────────┘    └─────────────┘                │
│                                                                        │
│                    ↑ Alle Entscheidungen hier ↑                        │
└───────────────────────────────────────────────────────────────────────┘
                              ↕ MQTT
┌───────────────────────────────────────────────────────────────────────┐
│                            ESP32 (DUMM)                                │
│                                                                        │
│  • Liest Sensoren aus (RAW-Daten)                                      │
│  • Führt Befehle aus (keine eigene Logik)                              │
│  • Speichert Config (keine Business-Rules)                             │
│  • Emergency-Stop (einzige lokale Entscheidung!)                       │
└───────────────────────────────────────────────────────────────────────┘
```

#### 10.5.2 Entscheidungs-Matrix

| Entscheidung | Wer entscheidet | Code-Location |
|--------------|-----------------|---------------|
| Sensor-Kalibrierung | **Server** | sensor_libraries/active/*.py |
| Actuator-Aktivierung | **Server** | actuator_service.py → MQTT Command |
| Cross-ESP-Logic | **Server** | logic_engine.py |
| Zone-Assignment | **Server** | zone_service.py |
| Value-Validierung | **Server** | safety_service.py |
| **Emergency-Stop** | **ESP32** | safety_controller.cpp (einzige Ausnahme!) |
| GPIO-Conflict-Check | **ESP32** | gpio_manager.cpp (Hardware-Protection) |

#### 10.5.3 ESP32 Fallback-Verhalten (Server offline)

**Was passiert wenn Server offline ist:**

1. **Heartbeat:** Geht in Offline-Buffer (max 100), Retry mit Backoff
2. **Sensor-Daten:** Geht in Offline-Buffer, werden bei Reconnect nachgeliefert
3. **Actuator-Commands:** **KEINE neuen Commands möglich!**
4. **Laufende Aktoren:** Bleiben aktiv bis:
   - Timeout-Protection greift (MAX_RUNTIME)
   - Emergency-Stop manuell ausgelöst wird
   - Strom ausfällt

**Kritische Erkenntnis:**
```
ESP32 KANN NICHT eigenständig entscheiden, Aktoren abzuschalten
(außer Emergency-Stop). Das ist Absicht - Server-Centric Design.
```

---

### 10.6 QoS-Level Übersicht

| Message-Typ | QoS | Begründung |
|-------------|-----|------------|
| Heartbeat | 0 | Best-effort, regelmäßig gesendet |
| Sensor-Daten | 0/1 | Depends on criticality, meist 0 |
| Actuator-Status | 1 | Wichtig für State-Tracking |
| Actuator-Command | 1 | Muss ankommen! |
| Config-Update | 2 | Exactly-once, kritisch |
| Emergency-Stop | 1 | Muss ankommen, mit Retain |
| Last-Will | 1 | Mit Retain für offline-Status |
| ESP-Log (NEU) | 0 | Best-effort, bandwidth-optimiert |

---

### 10.7 Timing-Konstanten Referenz

| Konstante | Wert | Datei:Zeile |
|-----------|------|-------------|
| `HEARTBEAT_INTERVAL_MS` | 60000 (60s) | mqtt_client.h:108 |
| `HEARTBEAT_TIMEOUT_SECONDS` | 300 (5min) | heartbeat_handler.py:37 |
| `RECONNECT_BASE_DELAY_MS` | 1000 (1s) | mqtt_client.cpp:18 |
| `RECONNECT_MAX_DELAY_MS` | 60000 (60s) | mqtt_client.cpp:19 |
| `MAX_RECONNECT_ATTEMPTS` | 10 | mqtt_client.cpp:20 |
| `MAX_OFFLINE_MESSAGES` | 100 | mqtt_client.h (implied) |
| `measurement_interval_` | 30000 (30s) default | sensor_manager.cpp:33 |
| `actuator_status_interval` | 30000 (30s) | main.cpp:1088 |
| `rate_limit_window` | 1000 (1s) | manager.py:38 |
| `rate_limit_max` | 10 msg/sec | manager.py:39 |
| `baseReconnectDelay` | 1000 (1s) | websocket.ts:49 |
| `maxReconnectDelay` | 30000 (30s) | websocket.ts:50 |
| `maxReconnectAttempts` | 10 | websocket.ts:48 |

---

### 10.8 FAQ für Entwickler

**Q: Ich will einen neuen Sensor-Typ hinzufügen - welche Kommunikation muss ich anpassen?**
A: Keine MQTT-Änderung nötig! Das generische Topic `sensor/{gpio}/data` funktioniert für alle Sensor-Typen. Du musst:
1. Sensor-Library in `sensor_libraries/active/` erstellen (Server)
2. Optional: Sensor-Driver in `sensor_drivers/` (ESP32) wenn Hardware-spezifisch

**Q: Ein ESP geht offline - was passiert mit pending Actuator-Commands?**
A: Commands werden NICHT gepuffert! Sie werden sofort mit Error abgelehnt (`MQTT publish failed`). Laufende Aktoren bleiben aktiv bis Timeout-Protection greift.

**Q: Ich will das Heartbeat-Interval ändern - wo?**
A: `mqtt_client.h:108` → `HEARTBEAT_INTERVAL_MS`. Aber Vorsicht:
- Zu kurz: Mehr Traffic, mehr Server-Last
- Zu lang: Langsamere Offline-Detection (min. 5 Minuten wegen `HEARTBEAT_TIMEOUT_SECONDS`)

**Q: Wann genau wird ein WebSocket-Event gebroadcasted?**
A: NACH dem DB-Insert/Commit. Beispiel aus sensor_handler.py:
```python
await session.commit()  # Erst DB

# Dann WebSocket (best-effort)
try:
    ws_manager = await WebSocketManager.get_instance()
    await ws_manager.broadcast("sensor_data", {...})
except Exception as e:
    logger.warning(f"Failed to broadcast: {e}")  # Kein Failure!
```

**Q: Welche QoS-Level werden für welche Topics verwendet?**
A: Siehe Section 10.6. Kurzfassung:
- **QoS 0:** Heartbeat, Sensor-Daten (meist), Logs
- **QoS 1:** Actuator-Commands, Status-Updates, Emergency
- **QoS 2:** Config-Updates (exactly-once wichtig!)

---

## 11. LogCenterView.vue - Unified Log Center (FEHLTE!)

> **KRITISCH:** Diese Komponente war im ursprünglichen Plan nicht spezifiziert.
> Hier ist die vollständige Implementation.

**Datei:** `El Frontend/src/views/LogCenterView.vue`

```vue
<template>
  <div class="log-center-view p-6">
    <!-- Header mit Connection-Status -->
    <div class="flex justify-between items-center mb-6">
      <h1 class="text-2xl font-bold text-white">Log Center</h1>
      <div class="flex items-center gap-4">
        <!-- WebSocket Status -->
        <div class="flex items-center gap-2">
          <span
            class="w-3 h-3 rounded-full"
            :class="isConnected ? 'bg-green-500' : 'bg-red-500'"
          ></span>
          <span class="text-sm text-gray-400">
            {{ isConnected ? 'Live' : 'Offline' }}
          </span>
        </div>
        <!-- Auto-Refresh Toggle -->
        <button
          @click="toggleAutoRefresh"
          class="btn btn-sm"
          :class="autoRefresh ? 'btn-success' : 'btn-outline'"
        >
          {{ autoRefresh ? '⏸️ Pause' : '▶️ Live' }}
        </button>
        <!-- Clear Button -->
        <button @click="clearLogs" class="btn btn-sm btn-outline btn-error">
          🗑️ Clear
        </button>
      </div>
    </div>

    <!-- Tab Navigation -->
    <div class="tabs tabs-boxed mb-6 bg-base-200">
      <a
        v-for="tab in tabs"
        :key="tab.id"
        class="tab"
        :class="{ 'tab-active': activeTab === tab.id }"
        @click="activeTab = tab.id"
      >
        {{ tab.icon }} {{ tab.label }}
        <span v-if="getTabCount(tab.id) > 0" class="badge badge-sm ml-2">
          {{ getTabCount(tab.id) }}
        </span>
      </a>
    </div>

    <!-- Filter Bar -->
    <div class="card bg-base-200 p-4 mb-6">
      <div class="flex flex-wrap gap-4 items-center">
        <!-- Level Filter -->
        <div class="form-control">
          <label class="label label-text text-sm">Level</label>
          <select v-model="filters.level" class="select select-sm select-bordered">
            <option value="">All</option>
            <option value="DEBUG">DEBUG</option>
            <option value="INFO">INFO</option>
            <option value="WARNING">WARNING</option>
            <option value="ERROR">ERROR</option>
            <option value="CRITICAL">CRITICAL</option>
          </select>
        </div>

        <!-- ESP-ID Filter -->
        <div class="form-control">
          <label class="label label-text text-sm">ESP-ID</label>
          <input
            v-model="filters.espId"
            type="text"
            placeholder="ESP_..."
            class="input input-sm input-bordered w-40"
          />
        </div>

        <!-- Module Filter (nur für ESP-Tab) -->
        <div v-if="activeTab === 'esp'" class="form-control">
          <label class="label label-text text-sm">Module</label>
          <input
            v-model="filters.module"
            type="text"
            placeholder="sensor_manager..."
            class="input input-sm input-bordered w-40"
          />
        </div>

        <!-- Error-Code Filter -->
        <div v-if="activeTab === 'errors'" class="form-control">
          <label class="label label-text text-sm">Error Code</label>
          <input
            v-model="filters.errorCode"
            type="number"
            placeholder="1040"
            class="input input-sm input-bordered w-32"
          />
        </div>

        <!-- Search -->
        <div class="form-control flex-1">
          <label class="label label-text text-sm">Search</label>
          <input
            v-model="filters.search"
            type="text"
            placeholder="Search in messages..."
            class="input input-sm input-bordered"
          />
        </div>

        <!-- Time Range -->
        <div class="form-control">
          <label class="label label-text text-sm">Time Range</label>
          <select v-model="filters.timeRange" class="select select-sm select-bordered">
            <option value="1h">Last Hour</option>
            <option value="6h">Last 6 Hours</option>
            <option value="24h">Last 24 Hours</option>
            <option value="7d">Last 7 Days</option>
            <option value="all">All Time</option>
          </select>
        </div>

        <!-- Reset Button -->
        <button @click="resetFilters" class="btn btn-sm btn-ghost mt-6">
          ↩️ Reset
        </button>
      </div>
    </div>

    <!-- Log Content -->
    <div class="card bg-base-200">
      <!-- Server Logs Tab -->
      <div v-if="activeTab === 'server'" class="p-4">
        <div class="overflow-x-auto max-h-[600px] overflow-y-auto">
          <table class="table table-sm table-zebra">
            <thead class="sticky top-0 bg-base-300 z-10">
              <tr>
                <th class="w-32">Time</th>
                <th class="w-20">Level</th>
                <th class="w-40">Logger</th>
                <th>Message</th>
                <th class="w-24">Actions</th>
              </tr>
            </thead>
            <tbody>
              <tr v-for="log in filteredServerLogs" :key="log.id">
                <td class="font-mono text-xs">{{ formatTime(log.timestamp) }}</td>
                <td>
                  <span :class="getLevelBadgeClass(log.level)">{{ log.level }}</span>
                </td>
                <td class="text-xs text-gray-400 truncate max-w-[200px]">
                  {{ log.logger }}
                </td>
                <td class="max-w-[400px]">
                  <div class="truncate" :title="log.message">{{ log.message }}</div>
                </td>
                <td>
                  <button @click="showLogDetails(log)" class="btn btn-xs btn-ghost">
                    🔍
                  </button>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <!-- MQTT Logs Tab -->
      <div v-if="activeTab === 'mqtt'" class="p-4">
        <MqttLogEmbedded :filters="mqttFilters" />
      </div>

      <!-- ESP Logs Tab -->
      <div v-if="activeTab === 'esp'" class="p-4">
        <div class="overflow-x-auto max-h-[600px] overflow-y-auto">
          <table class="table table-sm table-zebra">
            <thead class="sticky top-0 bg-base-300 z-10">
              <tr>
                <th class="w-32">Time</th>
                <th class="w-20">Level</th>
                <th class="w-28">ESP-ID</th>
                <th class="w-32">Module</th>
                <th>Message</th>
                <th class="w-24">Error</th>
                <th class="w-16">Actions</th>
              </tr>
            </thead>
            <tbody>
              <tr v-for="log in filteredEspLogs" :key="log.id">
                <td class="font-mono text-xs">{{ formatTime(log.timestamp) }}</td>
                <td>
                  <span :class="getLevelBadgeClass(log.level)">{{ log.level }}</span>
                </td>
                <td class="font-mono text-xs">{{ log.esp_id }}</td>
                <td class="text-xs text-gray-400">{{ log.module || '-' }}</td>
                <td class="max-w-[300px]">
                  <div class="truncate" :title="log.message">{{ log.message }}</div>
                </td>
                <td>
                  <button
                    v-if="log.error_code"
                    @click="showErrorCodeInfo(log.error_code)"
                    class="btn btn-xs btn-error btn-outline"
                  >
                    {{ log.error_code }}
                  </button>
                  <span v-else class="text-gray-500">-</span>
                </td>
                <td>
                  <button @click="showEspLogDetails(log)" class="btn btn-xs btn-ghost">
                    🔍
                  </button>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <!-- Load More -->
        <div v-if="espLogsHasMore" class="text-center mt-4">
          <button @click="loadMoreEspLogs" class="btn btn-sm btn-outline">
            Load More ({{ espLogsTotalCount - espLogs.length }} remaining)
          </button>
        </div>
      </div>

      <!-- Errors Tab -->
      <div v-if="activeTab === 'errors'" class="p-4">
        <div class="overflow-x-auto max-h-[600px] overflow-y-auto">
          <table class="table table-sm table-zebra">
            <thead class="sticky top-0 bg-base-300 z-10">
              <tr>
                <th class="w-32">Time</th>
                <th class="w-24">Source</th>
                <th class="w-20">Code</th>
                <th class="w-40">Name</th>
                <th>Description</th>
                <th class="w-16">Actions</th>
              </tr>
            </thead>
            <tbody>
              <tr v-for="error in filteredErrors" :key="error.id" class="bg-red-900/20">
                <td class="font-mono text-xs">{{ formatTime(error.timestamp) }}</td>
                <td class="text-xs">
                  <span class="badge badge-sm">{{ error.source_type }}</span>
                  <div class="text-gray-400">{{ error.source_id }}</div>
                </td>
                <td>
                  <button
                    @click="showErrorCodeInfo(error.error_code)"
                    class="btn btn-xs btn-error"
                  >
                    {{ error.error_code }}
                  </button>
                </td>
                <td class="text-xs font-mono">{{ getErrorName(error.error_code) }}</td>
                <td>{{ error.error_description || error.message }}</td>
                <td>
                  <button @click="showErrorDetails(error)" class="btn btn-xs btn-ghost">
                    🔍
                  </button>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <!-- Error Code Modal -->
    <dialog ref="errorCodeModal" class="modal">
      <div class="modal-box bg-base-200">
        <h3 class="font-bold text-lg mb-4">Error Code: {{ selectedErrorCode }}</h3>
        <div v-if="errorCodeInfo" class="space-y-4">
          <div>
            <span class="text-gray-400">Name:</span>
            <span class="ml-2 font-mono">{{ errorCodeInfo.name }}</span>
          </div>
          <div>
            <span class="text-gray-400">Range:</span>
            <span class="ml-2">{{ getErrorRange(selectedErrorCode) }}</span>
          </div>
          <div>
            <span class="text-gray-400">Severity:</span>
            <span
              class="ml-2 badge"
              :class="getSeverityBadgeClass(errorCodeInfo.severity)"
            >
              {{ errorCodeInfo.severity }}
            </span>
          </div>
          <div>
            <span class="text-gray-400">Description:</span>
            <p class="mt-1 text-white">{{ errorCodeInfo.description }}</p>
          </div>
        </div>
        <div class="modal-action">
          <button class="btn" @click="closeErrorCodeModal">Close</button>
        </div>
      </div>
    </dialog>

    <!-- Log Details Modal -->
    <dialog ref="logDetailsModal" class="modal">
      <div class="modal-box bg-base-200 max-w-3xl">
        <h3 class="font-bold text-lg mb-4">Log Details</h3>
        <div v-if="selectedLog" class="space-y-4">
          <div class="grid grid-cols-2 gap-4">
            <div>
              <span class="text-gray-400">Timestamp:</span>
              <span class="ml-2 font-mono">{{ selectedLog.timestamp }}</span>
            </div>
            <div>
              <span class="text-gray-400">Level:</span>
              <span
                class="ml-2 badge"
                :class="getLevelBadgeClass(selectedLog.level)"
              >
                {{ selectedLog.level }}
              </span>
            </div>
          </div>
          <div>
            <span class="text-gray-400">Message:</span>
            <pre class="mt-1 p-3 bg-base-300 rounded text-sm overflow-x-auto">{{
              selectedLog.message
            }}</pre>
          </div>
          <div v-if="selectedLog.details">
            <span class="text-gray-400">Details:</span>
            <pre class="mt-1 p-3 bg-base-300 rounded text-sm overflow-x-auto">{{
              JSON.stringify(selectedLog.details, null, 2)
            }}</pre>
          </div>
        </div>
        <div class="modal-action">
          <button class="btn" @click="closeLogDetailsModal">Close</button>
        </div>
      </div>
    </dialog>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted, watch } from 'vue'
import { useWebSocket } from '@/composables/useWebSocket'
import { logsApi } from '@/api/logs'
import type { ESPLog, ErrorCodesResponse } from '@/api/logs'
import MqttLogEmbedded from '@/components/logs/MqttLogEmbedded.vue'

// Tabs
const tabs = [
  { id: 'server', label: 'Server Logs', icon: '🖥️' },
  { id: 'mqtt', label: 'MQTT Messages', icon: '📡' },
  { id: 'esp', label: 'ESP Logs', icon: '🔌' },
  { id: 'errors', label: 'Errors', icon: '❌' },
]
const activeTab = ref('server')

// WebSocket
const { subscribe, unsubscribe, isConnected } = useWebSocket({
  autoConnect: true,
  autoReconnect: true,
})

// State
const autoRefresh = ref(true)
const filters = ref({
  level: '',
  espId: '',
  module: '',
  errorCode: '',
  search: '',
  timeRange: '24h',
})

// Server Logs (HTTP polling)
const serverLogs = ref<any[]>([])
const serverLogsLoading = ref(false)
let serverLogsInterval: number | null = null

// ESP Logs
const espLogs = ref<ESPLog[]>([])
const espLogsPage = ref(1)
const espLogsTotalCount = ref(0)
const espLogsHasMore = ref(false)

// Error Codes Reference
const errorCodes = ref<ErrorCodesResponse | null>(null)

// Modals
const errorCodeModal = ref<HTMLDialogElement | null>(null)
const logDetailsModal = ref<HTMLDialogElement | null>(null)
const selectedErrorCode = ref<string>('')
const errorCodeInfo = ref<any>(null)
const selectedLog = ref<any>(null)

// Real-time ESP logs via WebSocket
const realtimeEspLogs = ref<ESPLog[]>([])
let subscriptionId: string | null = null

// Computed
const filteredServerLogs = computed(() => {
  let logs = serverLogs.value
  if (filters.value.level) {
    logs = logs.filter((l) => l.level === filters.value.level)
  }
  if (filters.value.search) {
    const search = filters.value.search.toLowerCase()
    logs = logs.filter(
      (l) =>
        l.message.toLowerCase().includes(search) ||
        l.logger.toLowerCase().includes(search)
    )
  }
  return logs.slice(0, 500)
})

const filteredEspLogs = computed(() => {
  // Combine realtime + historical
  let logs = [...realtimeEspLogs.value, ...espLogs.value]
  // Remove duplicates by id
  logs = logs.filter((log, index, self) =>
    index === self.findIndex((l) => l.id === log.id)
  )
  // Apply filters
  if (filters.value.level) {
    logs = logs.filter((l) => l.level === filters.value.level)
  }
  if (filters.value.espId) {
    logs = logs.filter((l) =>
      l.esp_id.toLowerCase().includes(filters.value.espId.toLowerCase())
    )
  }
  if (filters.value.module) {
    logs = logs.filter((l) =>
      l.module?.toLowerCase().includes(filters.value.module.toLowerCase())
    )
  }
  if (filters.value.search) {
    const search = filters.value.search.toLowerCase()
    logs = logs.filter((l) => l.message.toLowerCase().includes(search))
  }
  // Sort by timestamp desc
  return logs.sort(
    (a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
  )
})

const filteredErrors = computed(() => {
  // Filter logs with error_code
  let logs = [...realtimeEspLogs.value, ...espLogs.value].filter(
    (l) => l.error_code
  )
  if (filters.value.errorCode) {
    logs = logs.filter((l) => l.error_code === filters.value.errorCode)
  }
  if (filters.value.espId) {
    logs = logs.filter((l) =>
      l.esp_id.toLowerCase().includes(filters.value.espId.toLowerCase())
    )
  }
  return logs.map((l) => ({
    id: l.id,
    timestamp: l.timestamp,
    source_type: 'esp32',
    source_id: l.esp_id,
    error_code: l.error_code,
    error_description: l.error_description,
    message: l.message,
  }))
})

const mqttFilters = computed(() => ({
  types: filters.value.level
    ? undefined
    : ['sensor_data', 'actuator_status', 'esp_health', 'config_response'],
  esp_ids: filters.value.espId ? [filters.value.espId] : undefined,
}))

// Tab counts
function getTabCount(tabId: string): number {
  switch (tabId) {
    case 'server':
      return serverLogs.value.length
    case 'esp':
      return filteredEspLogs.value.length
    case 'errors':
      return filteredErrors.value.length
    default:
      return 0
  }
}

// Time formatting
function formatTime(timestamp: string): string {
  const date = new Date(timestamp)
  return date.toLocaleTimeString('de-DE', {
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
  })
}

// Level badge classes
function getLevelBadgeClass(level: string): string {
  const classes: Record<string, string> = {
    DEBUG: 'badge badge-sm badge-ghost',
    INFO: 'badge badge-sm badge-info',
    WARNING: 'badge badge-sm badge-warning',
    ERROR: 'badge badge-sm badge-error',
    CRITICAL: 'badge badge-sm badge-error bg-red-900',
  }
  return classes[level] || 'badge badge-sm'
}

function getSeverityBadgeClass(severity: string): string {
  const classes: Record<string, string> = {
    info: 'badge-info',
    warning: 'badge-warning',
    error: 'badge-error',
    critical: 'badge-error bg-red-900',
  }
  return classes[severity] || 'badge-ghost'
}

// Error code helpers
function getErrorName(code: string): string {
  if (!errorCodes.value) return code
  const esp32Code = errorCodes.value.esp32.codes[code]
  if (esp32Code) return esp32Code.name
  const serverCode = errorCodes.value.server.codes[code]
  if (serverCode) return serverCode.name
  return `UNKNOWN_${code}`
}

function getErrorRange(code: string): string {
  const codeNum = parseInt(code)
  if (codeNum >= 1000 && codeNum < 2000) return 'HARDWARE (1000-1999)'
  if (codeNum >= 2000 && codeNum < 3000) return 'SERVICE (2000-2999)'
  if (codeNum >= 3000 && codeNum < 4000) return 'COMMUNICATION (3000-3999)'
  if (codeNum >= 4000 && codeNum < 5000) return 'APPLICATION (4000-4999)'
  if (codeNum >= 5000 && codeNum < 6000) return 'SERVER (5000-5999)'
  return 'UNKNOWN'
}

// Modal handlers
function showErrorCodeInfo(code: string) {
  selectedErrorCode.value = code
  if (errorCodes.value) {
    errorCodeInfo.value =
      errorCodes.value.esp32.codes[code] ||
      errorCodes.value.server.codes[code] ||
      { name: 'UNKNOWN', description: 'Unknown error code', severity: 'error' }
  }
  errorCodeModal.value?.showModal()
}

function closeErrorCodeModal() {
  errorCodeModal.value?.close()
}

function showLogDetails(log: any) {
  selectedLog.value = log
  logDetailsModal.value?.showModal()
}

function showEspLogDetails(log: ESPLog) {
  selectedLog.value = log
  logDetailsModal.value?.showModal()
}

function showErrorDetails(error: any) {
  selectedLog.value = error
  logDetailsModal.value?.showModal()
}

function closeLogDetailsModal() {
  logDetailsModal.value?.close()
}

// Data loading
async function loadServerLogs() {
  if (serverLogsLoading.value) return
  serverLogsLoading.value = true
  try {
    const response = await logsApi.queryLogs({
      level: filters.value.level || undefined,
      search: filters.value.search || undefined,
      page: 1,
      page_size: 500,
    })
    serverLogs.value = response.logs
  } catch (error) {
    console.error('Failed to load server logs:', error)
  } finally {
    serverLogsLoading.value = false
  }
}

async function loadEspLogs(append = false) {
  try {
    const response = await logsApi.getESPLogs({
      esp_id: filters.value.espId || undefined,
      level: filters.value.level || undefined,
      module: filters.value.module || undefined,
      error_code: filters.value.errorCode
        ? parseInt(filters.value.errorCode)
        : undefined,
      page: append ? espLogsPage.value + 1 : 1,
      page_size: 100,
    })
    if (append) {
      espLogs.value = [...espLogs.value, ...response.logs]
      espLogsPage.value++
    } else {
      espLogs.value = response.logs
      espLogsPage.value = 1
    }
    espLogsTotalCount.value = response.total_count
    espLogsHasMore.value = response.has_more
  } catch (error) {
    console.error('Failed to load ESP logs:', error)
  }
}

async function loadMoreEspLogs() {
  await loadEspLogs(true)
}

async function loadErrorCodes() {
  try {
    errorCodes.value = await logsApi.getErrorCodes()
  } catch (error) {
    console.error('Failed to load error codes:', error)
  }
}

// Actions
function clearLogs() {
  serverLogs.value = []
  espLogs.value = []
  realtimeEspLogs.value = []
}

function resetFilters() {
  filters.value = {
    level: '',
    espId: '',
    module: '',
    errorCode: '',
    search: '',
    timeRange: '24h',
  }
}

function toggleAutoRefresh() {
  autoRefresh.value = !autoRefresh.value
  if (autoRefresh.value) {
    startPolling()
    subscribeToEspLogs()
  } else {
    stopPolling()
    unsubscribeFromEspLogs()
  }
}

// Polling
function startPolling() {
  if (serverLogsInterval) return
  serverLogsInterval = window.setInterval(loadServerLogs, 3000)
}

function stopPolling() {
  if (serverLogsInterval) {
    clearInterval(serverLogsInterval)
    serverLogsInterval = null
  }
}

// WebSocket subscription
function subscribeToEspLogs() {
  subscriptionId = subscribe(
    { types: ['esp_log'] },
    (message) => {
      if (message.type === 'esp_log') {
        const log: ESPLog = {
          id: `ws_${Date.now()}_${Math.random().toString(36).slice(2)}`,
          esp_id: message.data.esp_id,
          level: message.data.level,
          module: message.data.module,
          message: message.data.message,
          error_code: message.data.error_code,
          error_description: message.data.error_description,
          details: message.data.details,
          timestamp: new Date().toISOString(),
        }
        realtimeEspLogs.value.unshift(log)
        // Keep max 100 realtime logs
        if (realtimeEspLogs.value.length > 100) {
          realtimeEspLogs.value = realtimeEspLogs.value.slice(0, 100)
        }
      }
    }
  )
}

function unsubscribeFromEspLogs() {
  if (subscriptionId) {
    unsubscribe(subscriptionId)
    subscriptionId = null
  }
}

// Watchers
watch(activeTab, async (newTab) => {
  if (newTab === 'server') {
    await loadServerLogs()
  } else if (newTab === 'esp' || newTab === 'errors') {
    await loadEspLogs()
  }
})

watch(
  () => filters.value,
  async () => {
    if (activeTab.value === 'server') {
      await loadServerLogs()
    } else if (activeTab.value === 'esp' || activeTab.value === 'errors') {
      await loadEspLogs()
    }
  },
  { deep: true }
)

// Lifecycle
onMounted(async () => {
  await loadErrorCodes()
  await loadServerLogs()
  await loadEspLogs()
  if (autoRefresh.value) {
    startPolling()
    subscribeToEspLogs()
  }
})

onUnmounted(() => {
  stopPolling()
  unsubscribeFromEspLogs()
})
</script>

<style scoped>
.log-center-view {
  min-height: calc(100vh - 64px);
}
</style>
```

---

## 12. Error-Codes Endpoint - Vollständige Implementation

> **KRITISCH:** Der ursprüngliche Plan hatte nur ~15 Codes. Hier ist die vollständige Implementation
> mit ALLEN 60+ Codes aus `error_codes.h`.

**Datei:** `El Servador/god_kaiser_server/src/api/v1/debug.py`

```python
@router.get("/error-codes")
async def get_error_codes():
    """
    Gibt ALLE Error-Codes mit menschenlesbaren Beschreibungen zurück.
    Dynamisch generiert aus den definierten Konstanten.
    """
    return {
        "esp32": {
            "ranges": {
                "1000-1099": "GPIO (Pin-Reservation, Conflicts, Init)",
                "1010-1019": "I2C (Bus-Errors, Device Not Found)",
                "1020-1029": "OneWire (DS18B20, Init, Read)",
                "1030-1039": "PWM (Channel-Errors, Init)",
                "1040-1049": "Sensor (Read-Errors, Timeout)",
                "1050-1059": "Actuator (Set-Errors, Conflicts)",
                "2000-2099": "NVS (Storage-Errors)",
                "2010-2019": "Config (Validation, Load/Save)",
                "2020-2029": "Logger (Buffer, Init)",
                "2030-2039": "Storage (Generic)",
                "2500-2599": "Subzone (Management-Errors)",
                "3000-3009": "WiFi (Connection-Errors)",
                "3010-3019": "MQTT (Broker-Errors, Publish)",
                "3020-3029": "HTTP (Request-Errors)",
                "3030-3039": "Network (Generic)",
                "4000-4019": "State (Machine-Errors)",
                "4020-4029": "Command (Parse, Execution)",
                "4030-4039": "Payload (Validation)",
                "4040-4049": "Memory (Heap, Allocation)",
                "4050-4059": "System (Init, Restart)",
                "4060-4069": "Task (FreeRTOS)",
            },
            "codes": {
                # HARDWARE (1000-1999)
                "1001": {"name": "ERROR_GPIO_RESERVED", "description": "GPIO pin is reserved by system", "severity": "error"},
                "1002": {"name": "ERROR_GPIO_CONFLICT", "description": "GPIO pin already in use by another component", "severity": "error"},
                "1003": {"name": "ERROR_GPIO_INIT_FAILED", "description": "Failed to initialize GPIO pin", "severity": "critical"},
                "1004": {"name": "ERROR_GPIO_INVALID_MODE", "description": "Invalid GPIO pin mode specified", "severity": "error"},
                "1005": {"name": "ERROR_GPIO_READ_FAILED", "description": "Failed to read GPIO pin value", "severity": "warning"},
                "1006": {"name": "ERROR_GPIO_WRITE_FAILED", "description": "Failed to write GPIO pin value", "severity": "error"},
                "1010": {"name": "ERROR_I2C_INIT_FAILED", "description": "Failed to initialize I2C bus", "severity": "critical"},
                "1011": {"name": "ERROR_I2C_DEVICE_NOT_FOUND", "description": "I2C device not found on bus", "severity": "warning"},
                "1012": {"name": "ERROR_I2C_READ_FAILED", "description": "Failed to read from I2C device", "severity": "warning"},
                "1013": {"name": "ERROR_I2C_WRITE_FAILED", "description": "Failed to write to I2C device", "severity": "error"},
                "1014": {"name": "ERROR_I2C_BUS_ERROR", "description": "I2C bus error (SDA/SCL stuck or timeout)", "severity": "critical"},
                "1020": {"name": "ERROR_ONEWIRE_INIT_FAILED", "description": "Failed to initialize OneWire bus", "severity": "critical"},
                "1021": {"name": "ERROR_ONEWIRE_NO_DEVICES", "description": "No OneWire devices found on bus", "severity": "warning"},
                "1022": {"name": "ERROR_ONEWIRE_READ_FAILED", "description": "Failed to read from OneWire device", "severity": "warning"},
                "1030": {"name": "ERROR_PWM_INIT_FAILED", "description": "Failed to initialize PWM controller", "severity": "critical"},
                "1031": {"name": "ERROR_PWM_CHANNEL_FULL", "description": "All PWM channels already in use", "severity": "error"},
                "1032": {"name": "ERROR_PWM_SET_FAILED", "description": "Failed to set PWM duty cycle", "severity": "error"},
                "1040": {"name": "ERROR_SENSOR_READ_FAILED", "description": "Failed to read sensor data", "severity": "warning"},
                "1041": {"name": "ERROR_SENSOR_INIT_FAILED", "description": "Failed to initialize sensor", "severity": "error"},
                "1042": {"name": "ERROR_SENSOR_NOT_FOUND", "description": "Sensor not configured or not found", "severity": "warning"},
                "1043": {"name": "ERROR_SENSOR_TIMEOUT", "description": "Sensor read timeout (device not responding)", "severity": "warning"},
                "1050": {"name": "ERROR_ACTUATOR_SET_FAILED", "description": "Failed to set actuator state", "severity": "error"},
                "1051": {"name": "ERROR_ACTUATOR_INIT_FAILED", "description": "Failed to initialize actuator", "severity": "critical"},
                "1052": {"name": "ERROR_ACTUATOR_NOT_FOUND", "description": "Actuator not configured or not found", "severity": "warning"},
                "1053": {"name": "ERROR_ACTUATOR_CONFLICT", "description": "Actuator GPIO conflict with sensor", "severity": "error"},

                # SUBZONE (2500-2599)
                "2500": {"name": "ERROR_SUBZONE_INVALID_ID", "description": "Invalid subzone_id format (must be 1-32 chars, alphanumeric + underscore)", "severity": "error"},
                "2501": {"name": "ERROR_SUBZONE_GPIO_CONFLICT", "description": "GPIO already assigned to different subzone", "severity": "error"},
                "2502": {"name": "ERROR_SUBZONE_PARENT_MISMATCH", "description": "parent_zone_id doesn't match ESP zone assignment", "severity": "error"},
                "2503": {"name": "ERROR_SUBZONE_NOT_FOUND", "description": "Subzone doesn't exist", "severity": "warning"},
                "2504": {"name": "ERROR_SUBZONE_GPIO_INVALID", "description": "GPIO not in safe pins list", "severity": "error"},
                "2505": {"name": "ERROR_SUBZONE_SAFE_MODE_FAILED", "description": "Safe-mode activation failed for subzone", "severity": "critical"},
                "2506": {"name": "ERROR_SUBZONE_CONFIG_SAVE_FAILED", "description": "Failed to save subzone configuration to NVS", "severity": "error"},

                # SERVICE (2000-2999)
                "2001": {"name": "ERROR_NVS_INIT_FAILED", "description": "Failed to initialize NVS (Non-Volatile Storage)", "severity": "critical"},
                "2002": {"name": "ERROR_NVS_READ_FAILED", "description": "Failed to read from NVS", "severity": "error"},
                "2003": {"name": "ERROR_NVS_WRITE_FAILED", "description": "Failed to write to NVS (storage full or corrupted)", "severity": "error"},
                "2004": {"name": "ERROR_NVS_NAMESPACE_FAILED", "description": "Failed to open NVS namespace", "severity": "error"},
                "2005": {"name": "ERROR_NVS_CLEAR_FAILED", "description": "Failed to clear NVS namespace", "severity": "warning"},
                "2010": {"name": "ERROR_CONFIG_INVALID", "description": "Configuration data is invalid", "severity": "error"},
                "2011": {"name": "ERROR_CONFIG_MISSING", "description": "Required configuration is missing", "severity": "error"},
                "2012": {"name": "ERROR_CONFIG_LOAD_FAILED", "description": "Failed to load configuration from NVS", "severity": "error"},
                "2013": {"name": "ERROR_CONFIG_SAVE_FAILED", "description": "Failed to save configuration to NVS", "severity": "error"},
                "2014": {"name": "ERROR_CONFIG_VALIDATION", "description": "Configuration validation failed", "severity": "error"},
                "2020": {"name": "ERROR_LOGGER_INIT_FAILED", "description": "Failed to initialize logger system", "severity": "warning"},
                "2021": {"name": "ERROR_LOGGER_BUFFER_FULL", "description": "Logger buffer is full (messages dropped)", "severity": "warning"},
                "2030": {"name": "ERROR_STORAGE_INIT_FAILED", "description": "Failed to initialize storage manager", "severity": "critical"},
                "2031": {"name": "ERROR_STORAGE_READ_FAILED", "description": "Failed to read from storage", "severity": "error"},
                "2032": {"name": "ERROR_STORAGE_WRITE_FAILED", "description": "Failed to write to storage", "severity": "error"},

                # COMMUNICATION (3000-3999)
                "3001": {"name": "ERROR_WIFI_INIT_FAILED", "description": "Failed to initialize WiFi module", "severity": "critical"},
                "3002": {"name": "ERROR_WIFI_CONNECT_TIMEOUT", "description": "WiFi connection timeout", "severity": "error"},
                "3003": {"name": "ERROR_WIFI_CONNECT_FAILED", "description": "WiFi connection failed (wrong password or SSID not found)", "severity": "error"},
                "3004": {"name": "ERROR_WIFI_DISCONNECT", "description": "WiFi disconnected unexpectedly", "severity": "warning"},
                "3005": {"name": "ERROR_WIFI_NO_SSID", "description": "WiFi SSID not configured", "severity": "error"},
                "3010": {"name": "ERROR_MQTT_INIT_FAILED", "description": "Failed to initialize MQTT client", "severity": "critical"},
                "3011": {"name": "ERROR_MQTT_CONNECT_FAILED", "description": "MQTT broker connection failed", "severity": "error"},
                "3012": {"name": "ERROR_MQTT_PUBLISH_FAILED", "description": "Failed to publish MQTT message", "severity": "warning"},
                "3013": {"name": "ERROR_MQTT_SUBSCRIBE_FAILED", "description": "Failed to subscribe to MQTT topic", "severity": "error"},
                "3014": {"name": "ERROR_MQTT_DISCONNECT", "description": "MQTT disconnected from broker", "severity": "warning"},
                "3015": {"name": "ERROR_MQTT_BUFFER_FULL", "description": "MQTT offline buffer is full (messages dropped)", "severity": "warning"},
                "3016": {"name": "ERROR_MQTT_PAYLOAD_INVALID", "description": "MQTT payload is invalid or malformed", "severity": "error"},
                "3020": {"name": "ERROR_HTTP_INIT_FAILED", "description": "Failed to initialize HTTP client", "severity": "error"},
                "3021": {"name": "ERROR_HTTP_REQUEST_FAILED", "description": "HTTP request failed (server unreachable)", "severity": "warning"},
                "3022": {"name": "ERROR_HTTP_RESPONSE_INVALID", "description": "HTTP response is invalid or malformed", "severity": "error"},
                "3023": {"name": "ERROR_HTTP_TIMEOUT", "description": "HTTP request timeout", "severity": "warning"},
                "3030": {"name": "ERROR_NETWORK_UNREACHABLE", "description": "Network is unreachable", "severity": "error"},
                "3031": {"name": "ERROR_DNS_FAILED", "description": "DNS lookup failed (hostname not resolved)", "severity": "error"},
                "3032": {"name": "ERROR_CONNECTION_LOST", "description": "Network connection lost", "severity": "warning"},

                # APPLICATION (4000-4999)
                "4001": {"name": "ERROR_STATE_INVALID", "description": "Invalid system state", "severity": "error"},
                "4002": {"name": "ERROR_STATE_TRANSITION", "description": "Invalid state transition", "severity": "error"},
                "4003": {"name": "ERROR_STATE_MACHINE_STUCK", "description": "State machine is stuck (no valid transitions)", "severity": "critical"},
                "4010": {"name": "ERROR_OPERATION_TIMEOUT", "description": "Operation timeout", "severity": "warning"},
                "4011": {"name": "ERROR_OPERATION_FAILED", "description": "Operation failed", "severity": "error"},
                "4012": {"name": "ERROR_OPERATION_CANCELLED", "description": "Operation cancelled by user or system", "severity": "info"},
                "4020": {"name": "ERROR_COMMAND_INVALID", "description": "Command is invalid or unknown", "severity": "error"},
                "4021": {"name": "ERROR_COMMAND_PARSE_FAILED", "description": "Failed to parse command", "severity": "error"},
                "4022": {"name": "ERROR_COMMAND_EXEC_FAILED", "description": "Command execution failed", "severity": "error"},
                "4030": {"name": "ERROR_PAYLOAD_INVALID", "description": "Payload is invalid or malformed", "severity": "error"},
                "4031": {"name": "ERROR_PAYLOAD_TOO_LARGE", "description": "Payload size exceeds maximum allowed", "severity": "error"},
                "4032": {"name": "ERROR_PAYLOAD_PARSE_FAILED", "description": "Failed to parse payload (JSON syntax error)", "severity": "error"},
                "4040": {"name": "ERROR_MEMORY_FULL", "description": "Memory is full (heap exhausted)", "severity": "critical"},
                "4041": {"name": "ERROR_MEMORY_ALLOCATION", "description": "Failed to allocate memory", "severity": "critical"},
                "4042": {"name": "ERROR_MEMORY_LEAK", "description": "Memory leak detected", "severity": "warning"},
                "4050": {"name": "ERROR_SYSTEM_INIT_FAILED", "description": "System initialization failed", "severity": "critical"},
                "4051": {"name": "ERROR_SYSTEM_RESTART", "description": "System restart requested", "severity": "info"},
                "4052": {"name": "ERROR_SYSTEM_SAFE_MODE", "description": "System entered safe mode (errors detected)", "severity": "warning"},
                "4060": {"name": "ERROR_TASK_FAILED", "description": "FreeRTOS task failed", "severity": "error"},
                "4061": {"name": "ERROR_TASK_TIMEOUT", "description": "FreeRTOS task timeout", "severity": "warning"},
                "4062": {"name": "ERROR_TASK_QUEUE_FULL", "description": "FreeRTOS task queue is full", "severity": "warning"},
            }
        },
        "server": {
            "ranges": {
                "5000-5099": "CONFIG (Validation, Mapping)",
                "5100-5199": "MQTT (Handler, Publish)",
                "5200-5299": "VALIDATION (Payload, Schema)",
                "5300-5399": "DATABASE (Query, Transaction)",
                "5400-5499": "SERVICE (Business Logic)",
                "5500-5599": "AUDIT (Logging, Retention)",
            },
            "codes": {
                "5001": {"name": "ERROR_CONFIG_INVALID", "description": "Invalid configuration value", "severity": "error"},
                "5002": {"name": "ERROR_CONFIG_MAPPING_FAILED", "description": "Field mapping failed", "severity": "error"},
                "5101": {"name": "ERROR_MQTT_HANDLER_FAILED", "description": "MQTT handler execution failed", "severity": "error"},
                "5102": {"name": "ERROR_MQTT_PUBLISH_FAILED", "description": "Failed to publish MQTT message", "severity": "warning"},
                "5201": {"name": "ERROR_PAYLOAD_MISSING_FIELDS", "description": "Required fields missing in payload", "severity": "warning"},
                "5202": {"name": "ERROR_PAYLOAD_INVALID_TYPE", "description": "Field has invalid type", "severity": "error"},
                "5203": {"name": "ERROR_PAYLOAD_INVALID_VALUE", "description": "Field value is invalid", "severity": "error"},
                "5301": {"name": "ERROR_DB_QUERY_FAILED", "description": "Database query failed", "severity": "error"},
                "5302": {"name": "ERROR_DB_TRANSACTION_FAILED", "description": "Database transaction failed", "severity": "error"},
                "5303": {"name": "ERROR_DB_CONNECTION_LOST", "description": "Database connection lost", "severity": "critical"},
                "5401": {"name": "ERROR_SERVICE_UNAVAILABLE", "description": "Service temporarily unavailable", "severity": "error"},
                "5402": {"name": "ERROR_SAFETY_CHECK_FAILED", "description": "Safety validation failed", "severity": "error"},
                "5501": {"name": "ERROR_AUDIT_LOG_FAILED", "description": "Failed to write audit log", "severity": "warning"},
            }
        }
    }
```

---

## 13. Design-Entscheidungen (USER-REVIEW ERFORDERLICH!)

### 13.1 DEBUG/INFO/WARNING Logs - Sichtbarkeit im Frontend

**AKTUELLE DESIGN-ENTSCHEIDUNG (Section 9.1):**

```cpp
// ESP32: publishLog() - NUR ERROR und CRITICAL werden gesendet!
if (level < LOG_ERROR) {
    return true;  // DEBUG, INFO, WARNING bleiben lokal
}
```

**Konsequenz:**
| Log-Level | Im Frontend sichtbar? | Wo verfügbar? |
|-----------|----------------------|---------------|
| DEBUG | ❌ NEIN | Serial Monitor, lokaler Buffer (50 Einträge) |
| INFO | ❌ NEIN | Serial Monitor, lokaler Buffer |
| WARNING | ❌ NEIN | Serial Monitor, lokaler Buffer |
| ERROR | ✅ JA | Serial + MQTT → Frontend |
| CRITICAL | ✅ JA | Serial + MQTT → Frontend |

**ALTERNATIVE OPTIONEN:**

#### Option A: Status Quo (empfohlen für Production)
- ✅ Minimale Bandwidth-Nutzung
- ✅ Nur kritische Fehler im Frontend
- ❌ DEBUG/INFO nicht remote sichtbar

#### Option B: Konfigurierbares Level (On-Demand)
```cpp
// Server sendet Level-Threshold via Config:
// "log_publish_level": "INFO"
// ESP passt publishLog() Filter dynamisch an
```
- ✅ Flexibel für Debugging
- ⚠️ Erfordert zusätzliche Config-Integration

#### Option C: REST-API Log-Abruf (On-Demand)
```cpp
// ESP32: Endpoint für Log-Abruf
// GET /api/logs?level=DEBUG&count=50
// Server proxied Anfrage an ESP
```
- ✅ Volle Kontrolle, kein dauerhafter Traffic
- ❌ Komplexere Implementation (HTTP-Server auf ESP)

### 13.2 Empfehlung

**Für diesen Plan:** Option A (Status Quo) beibehalten.

**Begründung:**
1. ESP32-Logs sind primär für Debugging bei Problemen gedacht
2. ERROR/CRITICAL sind die relevanten Logs für Production-Monitoring
3. DEBUG/INFO können bei Bedarf via Serial Monitor abgerufen werden
4. Bandwidth-Optimierung ist kritisch für viele ESPs

**User-Entscheidung erforderlich:**
- [ ] Option A beibehalten (empfohlen)
- [ ] Option B implementieren (konfigurierbares Level)
- [ ] Option C implementieren (REST-API Abruf)

---

## 14. MockESP32Client.publish_log() - Test-Implementation

**Datei:** `El Servador/god_kaiser_server/tests/esp32/mocks/mock_esp32_client.py`

> ⚠️ **VERIFIZIERT (2026-01-05):** Dateiname ist `mock_esp32_client.py` (mit "32"), nicht `mock_esp_client.py`!

```python
# Nach den bestehenden publish_* Methoden hinzufügen:

async def publish_log(
    self,
    level: str,
    message: str,
    module: str = "test_module",
    error_code: Optional[int] = None,
    details: Optional[Dict[str, Any]] = None
) -> bool:
    """
    Publiziere Log-Nachricht für Tests.

    Args:
        level: Log-Level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
        message: Log-Nachricht
        module: ESP32-Modul (default: "test_module")
        error_code: Optional Error-Code
        details: Optional zusätzliche Details

    Returns:
        True wenn erfolgreich publiziert
    """
    topic = f"kaiser/{self.kaiser_id}/esp/{self.esp_id}/system/log"

    payload = {
        "ts": int(time.time()),
        "esp_id": self.esp_id,
        "level": level.upper(),
        "module": module,
        "message": message,
    }

    if error_code is not None:
        payload["error_code"] = error_code
        # Error-Description aus error_codes.py
        # VERIFIZIERT: Funktion existiert in src/core/error_codes.py:483
        from god_kaiser_server.src.core.error_codes import get_error_code_description
        payload["error_description"] = get_error_code_description(error_code)

    if details:
        payload["details"] = details

    return await self.publish(topic, payload, qos=0)


# Convenience-Methoden für verschiedene Log-Levels
async def log_debug(self, message: str, module: str = "test_module") -> bool:
    """Publiziere DEBUG Log."""
    return await self.publish_log("DEBUG", message, module)

async def log_info(self, message: str, module: str = "test_module") -> bool:
    """Publiziere INFO Log."""
    return await self.publish_log("INFO", message, module)

async def log_warning(self, message: str, module: str = "test_module") -> bool:
    """Publiziere WARNING Log."""
    return await self.publish_log("WARNING", message, module)

async def log_error(
    self,
    message: str,
    module: str = "test_module",
    error_code: Optional[int] = None
) -> bool:
    """Publiziere ERROR Log."""
    return await self.publish_log("ERROR", message, module, error_code)

async def log_critical(
    self,
    message: str,
    module: str = "test_module",
    error_code: Optional[int] = None
) -> bool:
    """Publiziere CRITICAL Log."""
    return await self.publish_log("CRITICAL", message, module, error_code)
```

---

## 15. Aktualisierte Implementierungs-Checkliste

### Phase 1: ESP32 (30-45 min)

- [ ] `buildSystemLogTopic()` in topic_builder.h/cpp hinzufügen (Section 5.1)
- [ ] `publishLog()` in mqtt_client.h/cpp hinzufügen (Section 5.2)
- [ ] Build testen: `cd "El Trabajante" && pio run -e esp32_dev`

### Phase 2: Server Backend (4-5h)

- [ ] `esp_log_handler.py` erstellen (Section 5.3, **KORRIGIERTE VERSION**)
- [ ] Handler in `main.py` importieren und registrieren

      > ⚠️ **VERIFIZIERT (2026-01-05):** Tatsächliche Zeilennummern in main.py:
      > - Handler-Imports: Zeilen 36-46 (letzte: `zone_ack_handler`)
      > - Handler-Registrierungen: Zeilen 194-283
      > - Letzte Registrierung: Zeile ~282 (`kaiser/broadcast/emergency`)

      ```python
      # Zeile 46: Import hinzufügen (nach zone_ack_handler)
      from .mqtt.handlers import (
          ...
          zone_ack_handler,
          esp_log_handler,  # NEU
      )

      # Nach Zeile 233 (nach subzone_ack_handler): Handler registrieren
      # HINWEIS: VOR den Mock-ESP-Command-Handlern (Zeile 270+)
      _subscriber_instance.register_handler(
          f"kaiser/{kaiser_id}/esp/+/system/log",
          esp_log_handler.handle_esp_log
      )
      logger.info("Registered ESP Log handler for system/log topic")
      ```
- [ ] `ESP_LOG_MESSAGE` Event-Type in audit_log.py hinzufügen (Section 5.5)
- [ ] `/v1/debug/esp-logs` Endpoint in debug.py hinzufügen (Section 5.6)
- [ ] `/v1/debug/error-codes` Endpoint hinzufügen (Section 12, **VOLLSTÄNDIG**)
- [ ] `MockESP32Client.publish_log()` hinzufügen (Section 14)
- [ ] Server-Tests ausführen: `cd "El Servador" && poetry run pytest -v`

### Phase 3: Frontend (4-5h)

- [ ] `esp_log` MessageType in types/index.ts hinzufügen (Section 5.7)
- [ ] logs.ts API-Client erweitern (Section 5.8)
- [ ] **`LogCenterView.vue` erstellen (Section 11, NEU!)**
- [ ] `MqttLogEmbedded.vue` Komponente erstellen (siehe VERIFIZIERUNG unten)
- [ ] Route `/log-center` in router/index.ts hinzufügen
- [ ] Sidebar-Navigation erweitern
- [ ] WebSocket `esp_log` Handler in MqttLogView erweitern

> ⚠️ **VERIFIZIERT (2026-01-05) - MqttLogEmbedded.vue Entscheidung:**
>
> **Analyse von MqttLogView.vue (283 Zeilen):**
> - Zeilen 1-137: Script mit WebSocket-Integration, Filter-Logic, Event-Handler
> - Zeilen 139-282: Template mit Header, Filter-Panel, Message-Liste
>
> **Option A (EMPFOHLEN):** MqttLogView.vue direkt als Komponente einbetten
> - LogCenterView.vue nutzt `<MqttLogView />` als Tab-Inhalt
> - Keine Code-Duplizierung, MqttLogView bleibt die Single Source of Truth
> - Einfachste Lösung, schnellste Implementierung
>
> **Option B:** MqttLogEmbedded.vue als "Headless" Variante
> - Nur die Message-Liste (Zeilen 233-280) extrahieren
> - Props für Filter von Parent erhalten
> - Mehr Flexibilität aber auch mehr Wartungsaufwand
>
> **Empfehlung:** Option A verwenden - MqttLogView.vue direkt einbetten.
> In LogCenterView.vue einfach:
> ```vue
> <template>
>   <div>
>     <TabPanel value="mqtt">
>       <MqttLogView />  <!-- Direkt eingebettet -->
>     </TabPanel>
>   </div>
> </template>
> ```

### Phase 4: Integration & Test (1-2h)

- [ ] ESP32 mit Server testen (echte Logs)
- [ ] MockESP32Client Log-Tests ausführen
- [ ] Frontend mit echten Logs testen
- [ ] Performance-Test (viele Logs gleichzeitig)
- [ ] Dokumentation aktualisieren (CLAUDE.md, Mqtt_Protocoll.md)

---

## 16. Abschließende Hinweise

### Was dieser Plan NICHT abdeckt (Out of Scope):

1. **Log-Retention-Policy Implementation** - Nutze bestehenden `AuditRetentionService`
2. **Log-Export-Funktion** - Kann später als Feature hinzugefügt werden
3. **Log-Alerting** - Kann über Logic Engine realisiert werden
4. **Log-Aggregation über mehrere Server** - Out of Scope für Single-Server-Setup

### Abhängigkeiten:

| Komponente | Abhängig von |
|------------|--------------|
| ESPLogHandler | resilient_session, AuditLogRepository, WebSocketManager |
| LogCenterView | WebSocket Service, Logs API |
| publishLog() | TopicBuilder, TimeManager, error_codes.h |

### Risiken:

1. **Bandwidth bei vielen ESPs**: Wenn viele ESPs ERROR-Logs senden, könnte der Server überlastet werden. Mitigation: QoS 0 + Rate-Limiting auf Server-Seite.

2. **Circular Buffer Overflow**: Lokaler ESP-Buffer (50 Einträge) könnte bei schnellem Logging überlaufen. Mitigation: Ist by-design - älteste Logs werden überschrieben.

3. **Frontend-Performance**: Viele Logs in LogCenterView könnten Performance-Probleme verursachen. Mitigation: Virtualisierung für große Listen (vue-virtual-scroller).

---

**Dokument-Version:** 5.0
**Aktualisiert:** 2026-01-05
**Status:** VERIFIZIERT UND KORRIGIERT

---

## Changelog v5.0 - Verifikation gegen echten Code (2026-01-05)

### 🔍 Verifikation 1: MockESP32Client Dateipfad
- **Gefunden:** Datei heißt `mock_esp32_client.py` (mit "32"), nicht `mock_esp_client.py`
- **Korrigiert:** Section 14 - Dateipfad aktualisiert

### 🔍 Verifikation 2: Error-Code Helper
- **Gefunden:** `get_error_code_description()` existiert in `src/core/error_codes.py:483` ✅
- **Korrigiert:** Import-Pfad in Section 14 von relativen zu absoluten Import geändert

### 🔍 Verifikation 3: main.py Zeilennummern
- **Gefunden:** Inkonsistente Zeilennummern im Dokument (17 vs 46, 233 vs 279)
- **Tatsächliche Werte:**
  - Handler-Imports: Zeilen 36-46
  - Handler-Registrierungen: Zeilen 194-283
  - Letzte Registrierung: Zeile ~282 (`kaiser/broadcast/emergency`)
- **Korrigiert:** Section 5.4 und Phase 2 Checkliste mit verifizierten Zeilennummern

### 🔍 Verifikation 4: MqttLogEmbedded.vue
- **Gefunden:** Komponente ist nirgends definiert, MqttLogView.vue ist vollständig (283 Zeilen)
- **Entscheidung:** Option A empfohlen - MqttLogView.vue direkt in LogCenterView einbetten
- **Korrigiert:** Phase 3 Checkliste mit Empfehlung und Beispiel-Code

### 🔍 Verifikation 5: ESP32 publishLog() Integration
- **Gefunden:** LOG_ERROR Makros rufen nur logger.error() auf, kein automatischer MQTT-Publish
- **Gefunden:** publishHeartbeat() wird automatisch in loop() aufgerufen (mqtt_client.cpp:484)
- **Entscheidung:** publishLog() soll EXPLIZIT aufgerufen werden (nicht automatisch)
- **Korrigiert:** Section 3.1.4 erweitert mit Beispiel-Code für Verwendung
